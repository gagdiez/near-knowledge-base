<html itemscope itemtype="https://schema.org/FAQPage">
<head>
    <title>NEAR FAQ</title>
</head>
<body>
<h1>
    Frequently Asked Questions (FAQ)
</h1>


<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are benefits of Access Keys?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Since the concept of Access Keys is unique to NEAR it is worth to first understand why and how they can be used.</p>
<h4>Using An App Safely</h4>
<p>Imagine that you want to play a web3 game consisting of a web-app and a smart contract. You can create a key that only
allows to <strong>call specific methods</strong> in the game's contract.
You can safely give the key to the game, so it can sign <strong>game-related transactions</strong> for you without needing to interrupt
the gameplay on each transaction.</p>
<h4>Replacing Keys</h4>
<p>If you think any of your keys could be compromised, you can simply remove them or swap them with a new one. Just as how
you would change your password on any website.</p>
<h4>Implementing Key Recovery</h4>
<p>You could implement a key-recovery <a href="https://docs.near.org/concepts/basics/accounts/../smartcontracts/smartcontracts">contract</a> in your account, and create a
&quot;recovery key&quot; for someone you trust. Such key could only be used to start the recovery.
When needed, that third-party component could trigger the recovery process, helping to create a new master for you.</p>
<p><a href="https://docs.near.org/concepts/basics/accounts/access-keys">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Key Types?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR implements two types of access keys: <code>FullAccess</code> keys and <code>FunctionCall</code> keys.</p>
<p><a href="https://docs.near.org/concepts/basics/accounts/access-keys">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Full Access Keys?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>As the name suggests, <code>FullAccess</code> keys have full control of an account, similar to having administrator privileges on your operating system.
Particularly, Full Access keys can be used to sign transactions doing <a href="https://nomicon.io/RuntimeSpec/Actions">any action</a> in your account's behalf:</p>
<ol>
<li>Create immediate <a href="https://docs.near.org/concepts/basics/accounts/account-id#rules-for-creating-named-accounts">sub-accounts</a>.</li>
<li>Delete your account (but <strong>not</strong> sub-accounts, since they have their own keys).</li>
<li>Add or remove Access Keys.</li>
<li>Deploy a smart contract in the account.</li>
<li>Call methods on any contract (yours or others).</li>
<li>Transfer NEAR Ⓝ.
If you hand a <code>FullAccess</code> to someone, they will have <strong>total control over the account</strong>.</li>
</ol>
<p>You <strong>add the first</strong> Full Access Key of the account when <a href="https://docs.near.org/concepts/basics/accounts/creating-accounts">the account is created</a>.</p>
<p><a href="https://docs.near.org/concepts/basics/accounts/access-keys#full-access-keys">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is Function Call Key?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>FunctionCall</code> keys only have permission to call <strong>non-payable</strong> methods on contracts, i.e. methods that <strong>do not</strong> require you to attach NEAR Ⓝ.
<code>FunctionCall</code> keys are defined by three attributes:</p>
<ol>
<li><code>receiver_id</code>: The <strong>contract</strong> which the key allows to call. No other contract can be called using this key.</li>
<li><code>method_names</code>: The contract's <strong>methods</strong> the key allows to call (Optional). If omitted, all methods may be called.</li>
<li><code>allowance</code>: The <strong>amount of Ⓝ</strong> allowed to spend on <a href="https://docs.near.org/concepts/basics/accounts/../transactions/gas">gas</a> (Optional). If omitted, the key will only be allowed to call view methods (read-only).
Function Call keys main purpose is to be handled to apps, so they can make contract calls in your name.
NEAR simplifies creating and giving <code>FunctionCall</code> keys to dApps by implementing a <a href="https://docs.near.org/develop/integrate/frontend#user-sign-in"><strong>sign-in</strong></a> process. Briefly, dApps
can ask you to sign-in using the <a href="https://testnet.mynearwallet.com">wallet</a>, which automatically creates and gives a <code>FunctionCall</code> key to the dApp.
With the <code>FunctionCall</code> key, the dApp will then be able to call specific methods <strong>in your account's behalf</strong>, with a default allowance of 0.25Ⓝ for gas.
If the dApps requests to transfer <strong>any amount of tokens</strong> with the <code>FunctionCall</code> key, the user will be once more prompt by the wallet to <strong>authorize the transaction</strong>.</li>
</ol>
<p><a href="https://docs.near.org/concepts/basics/accounts/access-keys#function-call-keys">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is locked account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If you remove all keys from an account, then the account will become <strong>locked</strong>, meaning that no external actor can perform transactions in the
account's name.
In practice, this means that only the account's smart contract can transfer assets, create sub-accounts, or update its own code.
Locking an account is very useful when one wants to deploy a contract, and let the community be assured that only the contract is in control of the account.</p>
<p><a href="https://docs.near.org/concepts/basics/accounts/access-keys">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is implicit account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Implicit accounts are similar to the classic Bitcoin/Ethereum accounts. They are defined by a 64 character address, which corresponds
to a unique ED25519 key-pair.
For example:</p>
<ul>
<li>The public key in base58: <code>BGCCDDHfysuuVnaNVtEhhqeT4k9Muyem3Kpgq2U1m9HX</code></li>
<li>Refers to the implicit account: <code>98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de</code></li>
</ul>
<p>Check our section on how to <a href="https://docs.near.org/concepts/basics/accounts/creating-accounts#local-implicit-account">create implicit accounts</a></p>
<p><a href="https://docs.near.org/concepts/basics/accounts/account-id#implicit-accounts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is named account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In NEAR, users can register <strong>named accounts</strong> (e.g. <code>bob.near</code>) which are simpler to use and remember.
Moreover, named accounts can create <strong>sub-accounts</strong> of themselves, helping to better organize related-accounts.
In this way, named accounts work as domains, particularly:</p>
<ol>
<li>Only the <a href="https://explorer.near.org/accounts/registrar"><code>registrar</code></a> account can create short top-level accounts (&lt;32 char).</li>
<li>Anyone can create long (&gt;= 32 chars) top-level accounts.</li>
<li>An account can only create <strong>immediate</strong> sub-accounts of itself.
In other words:</li>
<li>Only <a href="https://explorer.near.org/accounts/registrar"><code>registrar</code></a> can create short top-level accounts (e.g. <code>near</code>, <code>aurora</code>).</li>
<li>Anyone can create long top-level accounts, e.g. <code>verylongaccountnamethatis32chars</code>.</li>
<li><code>near</code> can create <code>bob.near</code>, and <code>bob.near</code> can create <code>app.bob.near</code>.</li>
<li><code>near</code> <strong>cannot</strong> create <code>app.bob.near</code>, and <code>test.near</code> <strong>cannot</strong> create <code>sub.example.near</code>.
Currently, <strong>mainnet</strong> accounts are sub-accounts of <code>.near</code> (<code>example.near</code>), and <strong>testnet</strong> accounts are sub-accounts of <code>testnet</code>
(<code>example.testnet</code>).
info
Accounts have <strong>no control</strong> over sub-accounts, since they do <strong>NOT</strong> share <a href="https://docs.near.org/concepts/basics/accounts/#access-keys-access-keys">access keys</a></li>
</ol>
<p>Check our section on how to <a href="https://docs.near.org/concepts/basics/accounts/creating-accounts#local-named-account">create named accounts</a></p>
<p><a href="https://docs.near.org/concepts/basics/accounts/account-id">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is  The NEAR Wallet?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The NEAR wallet is our web-based user-friendly wallet. You can readily use it without installing software or add-ons.</p>
<h4>Testnet</h4>
<p>In <strong>testnet</strong> you can directly create <a href="https://docs.near.org/concepts/basics/accounts/account-id#named-accounts">named accounts</a>. Simply go to the <a href="https://testnet.mynearwallet.com/create">wallet</a>,
pick a name, and you are ready to go. Remember to save somewhere safe the mnemonic phrase.</p>
<h4>Mainnet</h4>
<p>In the <strong>mainnet</strong> <a href="https://mynearwallet.com/">wallet</a> you will be first given an <a href="https://docs.near.org/concepts/basics/accounts/account-id#implicit-accounts-implicit-accounts">implicit account</a>, which you need to fund. After
that, you can use your <a href="https://docs.near.org/concepts/basics/accounts/account-id.md#implicit-accounts-implicit-accounts">implicit account</a> to create a <a href="https://docs.near.org/concepts/basics/accounts/account-id#named-accounts">named one</a>.</p>
<p><a href="https://docs.near.org/concepts/basics/accounts/creating-accounts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Local Implicit Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Create an implicit account locally takes two steps: first you create a key-pair locally, and then you derive its address.</p>
<h4>1. Create a ED25519 key-pair locally using <a href="https://docs.near.org/tools/near-cli">near cli</a></h4>
<pre><code class="language-bash"># 1. Generate key pair
near generate-key my-new-account
</code></pre>
<p>A new key-pair will be stored at <code>~/.near-credentials/testnet/my-new-account.json</code>.</p>
<h4>2. Convert the public_key to an account ID. {#converting-a-public-key-to-an-account-id}</h4>
<p>Use <a href="https://docs.near.org/tools/near-cli"><code>near-cli</code></a> once more to convert the <code>public_key</code> from the <code>.json</code> file to its related NEAR account address.</p>
<pre><code class="language-bash"># Open the javascript console of near-cli
near repl
</code></pre>
<pre><code class="language-javascript">// Paste this code in the javascript console
const pk58 = 'ed25519:&lt;data&gt;'
nearAPI.utils.PublicKey.fromString(pk58).data.hexSlice()
</code></pre>
<p>The output string will be the account ID in hex (without <code>'</code>), for example <code>98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de</code>.
You can now share this id with someone and ask them to transfer tokens. At least <strong>0.001Ⓝ</strong> is needed to start using the account.</p>
<p>You can also use <strong>other languages</strong> to infer the implicit address, for example, in python you can use the <code>base58</code> package: <code>base58.b58decode(&lt;data&gt;).hex()</code></p>
<p><a href="https://docs.near.org/concepts/basics/accounts/creating-accounts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Local Named Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order to create a named account you have to ask the relevant smart contract to create a sub-account for you: <code>near</code> in mainnet, and <code>testnet</code> in testnet.
You can use <code>near-cli</code> for this:</p>
<pre><code class="language-bash">near call testnet create_account '{&quot;new_account_id&quot;: &quot;&lt;account-name&gt;.testnet&quot;, &quot;new_public_key&quot;: &quot;ed25519:&lt;data&gt;&quot;}' --deposit 0.00182 --accountId &lt;account-with-funds&gt;
</code></pre>
<p>Notice that you need an <strong>already funded</strong> account, since you are making a contract call.</p>
<p>The public key that you pass will become the <a href="https://docs.near.org/concepts/basics/accounts/access-keys#full-access-keys-full-access-keys">Full Access key</a> of the account.</p>
<p>info
For <strong>sub-accounts</strong> check the <a href="https://docs.near.org/tools/near-cli#near-create-account-near-create-account">near-cli create-account</a> docs.</p>
<p><a href="https://docs.near.org/concepts/basics/accounts/creating-accounts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Mainnet?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>mainnet</code> is for production ready smart contracts and live token transfers. Contracts ready for <code>mainnet</code> should have gone through rigorous testing and independent security reviews if necessary. <code>mainnet</code> is the only network where state is guaranteed to persist over time <em>(subject to the typical security guarantees of the network's validation process)</em>.</p>
<ul>
<li>[ Status: <a href="https://docs.near.org/concepts/basics/./">https://status.nearprotocol.com/</a> ]</li>
<li>[ <a href="https://explorer.near.org">Explorer</a> ]</li>
<li>[ <a href="https://wallet.near.org">Wallet</a> ]</li>
<li>[ <a href="https://near-nodes.io/intro/node-data-snapshots">Data Snapshots</a> ]</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/networks#mainnet">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Testnet?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>testnet</code> is a public network and the final testing network for <code>nearcore</code> changes before deployment to <code>mainnet</code>. <code>testnet</code> is intended for testing all aspects of the NEAR platform prior to <code>mainnet</code> deployment. From account creation, mock token transfers, development tooling, and smart contract development, the <code>testnet</code> environment closely resembles <code>mainnet</code> behavior. All <code>nearcore</code> changes are deployed as release candidates on first testnet, before the changes are released on <code>mainnet</code>. A number of <code>testnet</code> validators validate transactions and create new blocks. dApp developers deploy their applications on <code>testnet</code> before deploying on <code>mainnet</code>. It is important to note that <code>testnet</code> has its own transactions and states.</p>
<ul>
<li>[ Status: <a href="https://docs.near.org/concepts/basics/./">https://rpc.testnet.near.org/status</a> ]</li>
<li>[ <a href="https://explorer.testnet.near.org">Explorer</a> ]</li>
<li>[ <a href="https://wallet.testnet.near.org">Wallet</a> ]</li>
<li>[ <a href="https://near-nodes.io/intro/node-data-snapshots">Data Snapshots</a> ]</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/networks#testnet">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Betanet?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>betanet</code> is a public network, where <code>nearcore</code> is run to test its stability and backward compatibility. Validators on <code>betanet</code> are participants in the Betanet Analysis Group, where they engage in active discussions, submit bug reports, and participate in issue resolution. On <code>betanet</code> protocol changes, there are automated hard forks, where the state is compressed into a new genesis. As such, new genesis exists frequently on <code>betanet</code>, and there are no historical data snapshots. <code>betanet</code> usually has daily releases with protocol features that are not yet stabilized. State is maintained as much as possible but there is no guarantees with its high volatility.</p>
<ul>
<li>[ Status: <a href="https://docs.near.org/concepts/basics/./">https://rpc.betanet.near.org/status</a> ]</li>
<li>[ <a href="https://wallet.betanet.near.org">Wallet</a> ]</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/networks#betanet">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Localnet?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>localnet</code> is intended for developers who want to work with the NEAR platform independent of the public blockchain. You will need to generate nodes yourself. <code>localnet</code> gives you the total control over accounts, economics, and other factors for more advanced use cases (including making changes to <code>nearcore</code>). For developers, <code>localnet</code> is the right choice if you prefer to avoid leaking information about your work during the development process.
More on local development <a href="https://near-nodes.io/validator/running-a-node">here</a>
<code>near-cli</code> <a href="https://docs.near.org/concepts/basics/tools/near-cli#network-selection">network selection</a> variable is <code>local</code></p>
<p><a href="https://docs.near.org/concepts/basics/networks#localnet">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Accounts?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR uses human-readable account names such as <code>alice.near</code> or <code>bob.near</code> instead of a public hash such as<code>0x71C7656EC7ab88b098defB751B7401B5f6d8976F</code>.
These accounts also have the permission to create subaccounts such as <code>nft.alice.near</code> or <code>example2.bob.near</code>. It's important to know that only the root account can create the subaccount. So only <code>alice.near</code> can create <code>nft.alice.near</code> and only <code>nft.alice.near</code> can create <code>example.nft.alice.near</code>. Note that <code>alice.near</code> <em><strong>does not</strong></em> have permission to create <code>example.nft.alice.near</code>. Only the direct parent account has permission to create a subaccount.</p>
<p>For more information see the <strong><a href="https://docs.near.org/concepts/basics/concepts/basics/accounts/model">accounts section</a></strong>.</p>
<p><a href="https://docs.near.org/concepts/basics/overview">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Keys?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>On most blockchains, there is one <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public/private key pair</a> per account. On NEAR, each account can have many key pairs associated with them which we call &quot;Access Keys&quot;. There are two types of &quot;Access Keys&quot;:</p>
<ul>
<li><a href="https://docs.near.org/concepts/basics/concepts/basics/accounts/access-keys#full-access-keys">Full Access</a> <em>(Grants full control to the account)</em></li>
<li><a href="https://docs.near.org/concepts/basics/concepts/basics/accounts/access-keys#function-call-keys">Function Call</a> <em>(Allows for only non-monetary transaction signing)</em>
Full access keys allow for full control of the account. You can send funds, create sub-accounts, delete the account, and more. Function call keys only allow for calling certain methods on a specific smart contract that <strong>do not</strong> allow the transferring of funds. These keys can be used by dApp developers to allow users to sign simple transactions that mutate state on the blockchain without having to constantly re-direct to the user's wallet to prompt for authorization. They can be widely or narrowly scoped depending on the use case.</li>
</ul>
<p>For more information see the <strong><a href="https://docs.near.org/concepts/basics/concepts/basics/accounts/access-keys">access keys section</a></strong>.</p>
<p><a href="https://docs.near.org/concepts/basics/overview">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Contracts?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>For each account, <strong>only one</strong> smart contract can be deployed and active at any given moment. All smart contracts on NEAR must be compiled to <a href="https://webassembly.org/">WebAssemly</a> and currently, <a href="https://www.assemblyscript.org/">AssemblyScript</a> and <a href="https://www.rust-lang.org/">Rust</a> are the supported languages used. Smart contracts that have been deployed can be <a href="https://www.near-sdk.io/upgrading/prototyping">updated</a> at any time but not removed. This is where <a href="https://docs.near.org/concepts/basics/#concepts/basics/accounts/model#subaccounts">sub-accounts</a> can come in handy. NEAR allows users to organize and create a hierarchy for their accounts.
As an example, benji could have the root account <code>benji.near</code>. He then stores all his NFT contracts as sub-accounts of <code>nft.benji.near</code>. For example, he worked on a cool lazy minting contract deployed to <code>lazy.nft.benji.near</code>. This not only allows for better organization but it allows developers to easily delete and re-create accounts in order to clear state.</p>
<p>For more information see a guide on <strong><a href="https://www.near-sdk.io/promises/deploy-contract">deploying contracts</a></strong>.</p>
<p><a href="https://docs.near.org/concepts/basics/overview">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Storage?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Any information that is stored on NEAR is accounted for using a mechanism called <a href="https://docs.near.org/concepts/basics/concepts/storage/storage-staking">storage staking</a>. In short, an account must maintain a certain balance that is locked in order to cover the cost of storage. If that storage is released, the funds become available once again. This is why named account IDs on NEAR cost an initial deposit to create. If you attempt to store state on-chain without having the necessary balance in your account to cover the cost, an error will be thrown which will tell you to add more NEAR to your account.</p>
<p>For more information on storage staking, see the <strong><a href="https://docs.near.org/concepts/basics/concepts/storage/storage-staking">storage staking section</a></strong>.</p>
<p><a href="https://docs.near.org/concepts/basics/overview">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What users can do?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Users can have one or multiple <a href="https://docs.near.org/concepts/basics/./accounts/introduction">NEAR accounts</a>, which they can use to:</p>
<ol>
<li><strong>Transfer</strong> tokens, such as the native <a href="https://docs.near.org/concepts/basics/token">$NEAR token</a> or community-built ones.</li>
<li><strong>Execute</strong> <a href="https://awesomenear.com">decentralized apps</a> stored in the blockchain, known as <a href="https://docs.near.org/concepts/basics/smartcontracts/smartcontracts">smart contracts</a>.</li>
<li><strong>Develop</strong> their own decentralized app and store it in the blockchain.</li>
</ol>
<p><a href="https://docs.near.org/concepts/basics/protocol">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Who are validators?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Validators are people distributed around the world, running the infrastructure that underlies the NEAR network. They serve two main jobs:</p>
<ol>
<li><strong>Execute</strong> the <a href="https://docs.near.org/concepts/basics/transactions/overview">transactions</a> sent by the users, persisting their outcomes in the blockchain.</li>
<li><strong>Secure</strong> the network by overseeing the rest of the validators and the blocks they create.</li>
</ol>
<p><a href="https://docs.near.org/concepts/basics/protocol">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Runtime Overview?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>An in-depth code overview of NEAR Runtime.
&lt;iframe
width=&quot;560&quot;
height=&quot;315&quot;
src=&quot;https://www.youtube-nocookie.com/embed/Xi_8PapFCjo&quot;
frameborder=&quot;0&quot;
allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;
allowfullscreen&gt;
&lt;/iframe&gt;</p>
<p><a href="https://docs.near.org/concepts/basics/runtime#runtime-overview">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Runtime Action and Data Receipts?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>An in-depth code review of how NEAR Runtime implements cross contract calls.
&lt;iframe
width=&quot;560&quot;
height=&quot;315&quot;
src=&quot;https://www.youtube-nocookie.com/embed/RBb3rJGtqOE&quot;
frameborder=&quot;0&quot;
allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;
allowfullscreen&gt;
&lt;/iframe&gt;</p>
<p><a href="https://docs.near.org/concepts/basics/runtime#runtime-action-and-data-receipts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Runtime State?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>An in-depth overview of how NEAR runtime operates with its state.
&lt;iframe
width=&quot;560&quot;
height=&quot;315&quot;
src=&quot;https://www.youtube-nocookie.com/embed/JCkSNL4ie1U&quot;
frameborder=&quot;0&quot;
allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;
allowfullscreen&gt;
&lt;/iframe&gt;</p>
<p><a href="https://docs.near.org/concepts/basics/runtime#runtime-state">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is a Smart Contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Smart Contracts are pieces of logic that are asved on the network of computers that generate and validate the blockchain, and are triggered whenever an RPC API call is performed to the network, either to read or write data. You deploy your application's back-end logic to the blockchain, where it is called a &quot;smart contract&quot; or just &quot;contract&quot; for short.
Whenever a smart contract function is called through the RPC API, this call is routed to a an available node (or machine/computer) that initiates a virtual environment in which the smart contract logic is executed.
The relevant logic from the contract is then executed, reading/writing data and returning a result. If changes were made to the contract these are saved and the changes are propagated to the network. Finally, the virtual environment is torn down and the result is returned to the caller of the RPC API call.</p>
<p><a href="https://docs.near.org/concepts/basics/smartcontracts/smartcontracts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the API requests flow?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>There are different types of <a href="https://docs.near.org/concepts/basics/./validators">Nodes on NEAR</a>: RPC Nodes, Validators, and Archival Nodes.
When calling an endpoint on <code>near.org</code>, it resolves to a server that chooses an available RPC node to handle the request.
Then the RPC node passes the request to an available Validator node. Finally, the validator node spawns a VM environment to execute the contract.
Due to the decentralized nature of a blockchain network, there are many RPC nodes, and a request can reach any one of them, after which it can pass it to any one of the validators.
<img src="https://docs.near.org/docs/assets/JSONNetworkArch.png" alt="JSON Network Arch"></p>
<p><a href="https://docs.near.org/concepts/basics/technical_stuff">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Improper key management?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Improper key management may lead to token loss. Mitigating such scenarios may be done by issuing backup keys
allowing for recovery of accounts whose keys have been lost or deleted.</p>
<p><a href="https://docs.near.org/concepts/basics/token-loss#type-1-key-management">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Loss of <code>FullAccess</code> key?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>A user may lose their private key of a <code>FullAccess</code> key pair for an account with no other keys.
No one will be able to recover the funds. Funds will remain locked in the account forever.</p>
<p><a href="https://docs.near.org/concepts/basics/token-loss#scenario-1a-loss-of-fullaccess-key">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Loss of <code>FunctionCall</code> access key?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>An account may have its one and only <code>FunctionCall</code> access key deleted.
No one will be able to recover the funds. Funds will remain locked in the account forever.</p>
<p><a href="https://docs.near.org/concepts/basics/token-loss#scenario-1b-loss-of-functioncall-access-key">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How deleted accounts are getting refunding?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>When a refund receipt is issued for an account, if that account no longer exists, the funds will be dispersed among
validators proportional to their stake in the current epoch.</p>
<p><a href="https://docs.near.org/concepts/basics/token-loss#type-2-refunds">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Is it possible to delete account with non-existent beneficiary?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>When you delete an account, you must assign a beneficiary.
Once deleted, a transfer receipt is generated and sent to the beneficiary account.
If the beneficiary account does not exist, a refund receipt will be generated and sent back to the original account.
Since the original account has already been deleted, the funds will be dispersed among validators.</p>
<p><a href="https://docs.near.org/concepts/basics/token-loss#scenario-2a-delete-account-with-non-existent-beneficiary">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What if account with zero balance is garbage-collected, just before it receives refund?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If an account <code>A</code> transfers all of its funds to another account <code>B</code> and account <code>B</code> does not exist,
a refund receipt will be generated for account <code>A</code>. During the period of this round trip,
account <code>A</code> is vulnerable to deletion by garbage collection activities on the network.
If account <code>A</code> is deleted before the refund receipt arrives, the funds will be dispersed among validators.</p>
<p><a href="https://docs.near.org/concepts/basics/token-loss#scenario-2b-account-with-zero-balance-receives-refund">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Securing the Network?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR Protocol is a proof-of-stake (PoS) network, which means that resistance from various attacks comes from staking NEAR.
Staked NEAR represents the decentralized infrastructure of servers that maintain the network and process transactions for applications and users on NEAR.
Rewards for providing this service are received in NEAR.</p>
<p><a href="https://docs.near.org/concepts/basics/token">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Providing a Unit of Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR is used to price computation and storage on the NEAR infrastructure.
The network charges transaction fees in NEAR to process changes and transactions.</p>
<p><a href="https://docs.near.org/concepts/basics/token">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is gas?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR has a more-or-less one second block time, accomplished by limiting the amount of gas per block. You can query this value by using the <a href="https://docs.near.org/concepts/basics/transactions/api/rpc/setup#protocol-config"><code>protocol_config</code></a> RPC endpoint and search for <code>max_gas_burnt</code> under <code>limit_config</code>. The gas units have been carefully calculated to work out to some easy-to-think-in numbers:</p>
<ul>
<li>10¹² gas units, or <strong>1 TGas</strong> (<em>[Tera][metric prefixes]Gas</em>)...</li>
<li>≈ <strong>1 millisecond</strong> of &quot;compute&quot; time</li>
<li>...which, at a minimum gas price of 100 million yoctoNEAR, equals a <strong>0.1 milliNEAR</strong> charge
This <code>1ms</code> is a rough but useful approximation, and is the current goal of how gas units are set within NEAR. Gas units encapsulate not only compute/CPU time but also bandwidth/network time and storage/IO time. Via a governance mechanism, system parameters can be tweaked, shifting the mapping between TGas and milliseconds in the future, but the above is still a good starting point for thinking about what gas units mean and where they come from.</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#thinking-in-gas">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are  The cost of common actions?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>To give you a starting point for what to expect for costs on NEAR, the table below lists some common actions and how much TGas they currently require, and what the fee would be, in milliNEAR, at the minimum gas price of 100 million yN.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>TGas</th>
<th>fee (mN)</th>
<th>fee (Ⓝ)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create Account</td>
<td>0.42</td>
<td>0.042</td>
<td>4.2⨉10⁻⁵</td>
</tr>
<tr>
<td>Send Funds</td>
<td>0.45</td>
<td>0.045</td>
<td>4.5⨉10⁻⁵</td>
</tr>
<tr>
<td>Stake</td>
<td>0.50</td>
<td>0.050</td>
<td>5.0⨉10⁻⁵</td>
</tr>
<tr>
<td>Add Full Access Key</td>
<td>0.42</td>
<td>0.042</td>
<td>4.2⨉10⁻⁵</td>
</tr>
<tr>
<td>Delete Key</td>
<td>0.41</td>
<td>0.041</td>
<td>4.1⨉10⁻⁵</td>
</tr>
<tr>
<td>&lt;blockquote class=&quot;info&quot;&gt;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;strong&gt;Dig Deeper&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Where do these numbers come from?</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NEAR is <a href="https://github.com/near/nearcore/blob/master/core/primitives/res/runtime_configs/parameters.txt">configured</a> with base costs. An example:</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>transfer_cost: {
  send_sir:     115123062500,
  send_not_sir: 115123062500,
  execution:    115123062500
}
</code></pre>
<p>The &quot;sir&quot; here stands for &quot;sender is receiver&quot;. Yes, these are all identical, but that could change in the future.
When you make a request to transfer funds, NEAR immediately deducts the appropriate <code>send</code> amount from your account. Then it creates a <em>receipt</em>, an internal book-keeping mechanism to facilitate NEAR's asynchronous, sharded design (if you're coming from Ethereum, forget what you know about Ethereum's receipts, as they're completely different). Creating a receipt has its own associated costs:
action_receipt_creation_config: {
send_sir:     108059500000,
send_not_sir: 108059500000,
execution:    108059500000
}
You can query this value by using the <a href="https://docs.near.org/concepts/basics/transactions/api/rpc/setup#protocol-config"><code>protocol_config</code></a> RPC endpoint and search for <code>action_receipt_creation_config</code>.
The appropriate <code>send</code> amount for creating this receipt is also immediately deducted from your account.
The &quot;transfer&quot; action won't be finalized until the next block. At this point, the <code>execution</code> amount for each of these actions will be deducted from your account (something subtle: the gas units on this next block could be multiplied by a gas price that's up to 1% different, since gas price is recalculated on each block). Adding it all up to find the total transaction fee:
(transfer_cost.send_not_sir  + action_receipt_creation_config.send_not_sir ) * gas_price_at_block_1 +
(transfer_cost.execution + action_receipt_creation_config.execution) * gas_price_at_block_2
&lt;/blockquote&gt;</p>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#the-cost-of-common-actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Costs of complex actions?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The numbers above should give you the sense that transactions on NEAR are cheap! But they don't give you much sense of how much it will cost to use a more complex app or operate a NEAR-based business. Let's cover some more complex gas calculations: deploying contracts and function calls.</p>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#costs-of-complex-actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Deploying Contracts?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The basic action costs include two different values for deploying contracts. Simplified, these are:
deploy_contract_cost: 184765750000,
deploy_contract_cost_per_byte: 64572944,
Again, these values can be queried by using the <a href="https://docs.near.org/concepts/basics/transactions/api/rpc/setup#protocol-config"><code>protocol_config</code></a> RPC endpoint.
The first is a baseline cost, no matter the contract size. Keeping in mind that each need to be multiplied by two, for both <code>send</code> and <code>execute</code> costs, and will also require sending &amp; executing a receipt (see blue box above), the gas units comes to:
2 * 184765750000 +
2 * contract_size_in_bytes * 64572944 +
2 * 108059500000
(Divide the resulting number by 10¹² to get to TGas!)
Note that this covers the cost of uploading and writing bytes to storage, but does <em>not</em> cover the cost of holding these bytes in storage. Long-term storage is compensated via [storage staking], a recoverable cost-per-byte amount that will also be deducted from your account during contract deployment.
The AssemblyScript contract in <a href="https://github.com/near-examples/FT/pull/42">this example Fungible Token</a> compiles to just over 16kb (the Rust contract is much larger, but this <a href="https://github.com/near/near-sdk-rs/issues/167">will be optimized</a>). Using the calculation above, we find that it requires <strong>2.65 TGas</strong> (and thus 0.265mN at minimum gas price) for the transaction fee to deploy the contract, while 1.5N will be locked up for storage staking.</p>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#deploying-contracts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Function calls?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Given the general-purpose nature of NEAR, function calls win the award for most complex gas calculations. A given function call will use a hard-to-predict amount of CPU, network, and IO, and the amount of each can even change based on the amount of data already stored in the contract!
With this level of complexity, it's no longer useful to walk through an example, enumerating each (see <code>ext_costs</code> under <code>wasm_config</code> using the <a href="https://docs.near.org/concepts/basics/transactions/api/rpc/setup#protocol-config"><code>protocol_config</code></a> RPC endpoint) of the gas calculations as we go (you can research this yourself, <a href="https://github.com/near/nearcore/pull/3038">if you want</a>). Instead, let's approach this from two other angles: ballpark comparisons to Ethereum, and getting accurate estimates with automated tests.
&lt;blockquote class=&quot;lesson&quot;&gt;
<strong>How much of the gas fee goes as a 30% reward to the smart contract account?</strong>
The NEAR Whitepaper mentions that <a href="https://near.org/papers/the-official-near-white-paper/">30% of all gas fees</a> go to smart contract accounts on which the fees are expensed.
This amount can be calculated for function calls in two ways:</p>
<ol>
<li>Summing all values in the gas profile</li>
<li>Taking the total gas burnt for the transaction and subtract the static execution gas (which is equal to the amount of gas spent on sending the receipt(s)) from it. Both these numbers are available on the <a href="https://explorer.near.org/">NEAR Explorer</a> overview page for a transaction.
The second approach is shorter, and quite possibly easier to remember. So here's an example:</li>
</ol>
<ul>
<li>An account calls the method <code>submit</code> on <code>aurora</code>
<ul>
<li>Converting the transaction to receipt burned a total of ~0.00024Ⓝ</li>
<li>Executing the receipt burned a total of ~0.00376Ⓝ
The 30% reward for the smart contract owner (in this case aurora) would be: (0.00376Ⓝ - 0.00024Ⓝ) * 0.3 = 0.001056Ⓝ
This transaction can also be found <a href="https://explorer.near.org/transactions/GzRn9yhDaQ8f3ReJguCBGxdi4iJEeBguJ5MWufMcu1JP">here</a> on NEAR Explorer, feel free to have a look around!
For calls involving multiple contracts, calculating the reward for each contract with this method would not be possible with the data shown on NEAR Explorer (June 2022) as the explorer does not show the conversion cost for the second (and other) receipt(s).
&lt;/blockquote&gt;</li>
</ul>
</li>
</ul>
<h4>Ballpark Comparisons to Ethereum {#ballpark-comparisons-to-ethereum}</h4>
<p>Like NEAR, Ethereum uses gas units to model computational complexity of an operation. Unlike NEAR, rather than using a predictable gas price, Ethereum uses a dynamic, auction-based marketplace. This makes a comparison to Ethereum's gas prices a little tricky, but we'll do our best.
Etherscan gives a <a href="https://etherscan.io/chart/gasprice">historic Ethereum gas price chart</a>. These prices are given in &quot;Gwei&quot;, or Gigawei, where a wei is the smallest possible amount of ETH, 10⁻¹⁸. From November 2017 through July 2020, average gas price was 21Gwei. Let's call this the &quot;average&quot; gas price. In July 2020, average gas price went up to 57Gwei. Let's use this as a &quot;high&quot; Ethereum gas fee.
Multiplying Ethereum's gas units by gas price usually results in an amount that's easy to show in milliETH (mE), the same way we've been converting NEAR's TGas to milliNEAR. Let's look at some common operations side-by-side, comparing ETH's gas units to NEAR's, as well as converting to both the above &quot;average&quot; &amp; &quot;high&quot; gas prices.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>ETH gas units</th>
<th>avg mE</th>
<th>high mE</th>
<th>NEAR TGas</th>
<th>mN</th>
</tr>
</thead>
<tbody>
<tr>
<td>Transfer native token (ETH or NEAR)</td>
<td>21k</td>
<td>0.441</td>
<td>1.197</td>
<td>0.45</td>
<td>0.045</td>
</tr>
<tr>
<td>Deploy &amp; initialize a [fungible token] contract</td>
<td>[1.1M]</td>
<td>23.3</td>
<td>63.1</td>
<td>[9]&lt;super&gt;†&lt;/super&gt;</td>
<td>0.9 (plus 1.5Ⓝ in [storage staking])</td>
</tr>
<tr>
<td>Transfer a fungible token</td>
<td>[~45k]</td>
<td>0.945</td>
<td>2.565</td>
<td>[14]</td>
<td>1.4</td>
</tr>
<tr>
<td>Setting an escrow for a fungible token</td>
<td>[44k]</td>
<td>0.926</td>
<td>2.51</td>
<td>[8]</td>
<td>0.8</td>
</tr>
<tr>
<td>Checking a balance for a fungible token</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>&lt;super&gt;†&lt;/super&gt; Function calls require spinning up a VM and loading all compiled Wasm bytes into memory, hence the increased cost over base operations; this is <a href="https://github.com/near/nearcore/issues/3094">being optimized</a>.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>While some of these operations on their surface appear to only be about a 10x improvement over Ethereum, something else to note is that the total supply of NEAR is more than 1 billion, while total supply of Ethereum is more like 100 million. So as fraction of total supply, NEAR's gas fees are approximately another 10x lower than Ethereum's. Additionally, if the price of NEAR goes up significantly, then the minimum gas fee set by the network can be lowered.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>You can expect the network to sit at the minimum gas price most of the time; learn more in the <a href="https://near.org/papers/economics-in-sharded-blockchain/#transaction-and-storage-fees">Economics whitepaper</a>.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[fungible token]: https://github.com/near-examples/FT/pull/42</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[1.1m]: https://github.com/chadoh/erc20-test</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[9]: https://explorer.testnet.near.org/transactions/GsgH2KoxLZoL8eoutM2NkHe5tBPnRfyhcDMZaBEsC7Sm</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[storage staking]: /concepts/storage/storage-staking</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[~45k]: https://ethereum.stackexchange.com/questions/71235/gas-limit-for-erc-20-tokens</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[14]: https://explorer.testnet.near.org/transactions/5joKRvsmpEXzhVShsPDdV8z5EG9bGMWeuM9e9apLJhLe</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[8]: https://explorer.testnet.near.org/transactions/34pW67zsotFsD1DY8GktNhZT9yP5KHHeWAmhKaYvvma6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[44k]: https://github.com/chadoh/erc20-test</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4>Accurate Estimates with Automated Tests {#accurate-estimates-with-automated-tests}</h4>
<p>We will have a demonstration of how to do in-depth gas cost estimation soon; <a href="https://github.com/near/devx/issues/253">subscribe to this issue</a> for updates. Until then, you may want to look at this <a href="https://github.com/near-examples/simulation-testing">example of how to do simulation testing</a>, a powerful way to test your contracts and inspect every aspect of their execution.
If you're using NEAR's AssemblyScript SDK, you can use <a href="https://github.com/near/near-sdk-as/blob/741956d8a9a44e4252f8441dcd0ba3c19743590a/assembly/runtime/contract.ts#L68-L81">two methods</a>, <code>context.prepaidGas</code> and <code>context.usedGas</code>. These can be used with or without tests to report what the virtual machine knows about attached gas and its consumption at the moment your contract method is being executed:</p>
<pre><code class="language-ts">/**
* Get the number of gas units attached to the call
*/
get prepaidGas(): u64 {
 return env.prepaid_gas();
}
/**
* Get the number of gas units that was already burnt during the contract execution and
* attached to promises (cannot exceed prepaid gas).
*/
get usedGas(): u64 {
 return env.used_gas();
}
</code></pre>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#function-calls">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How do I buy gas?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You don't directly buy gas; you attach tokens to transactions.
Calls to NEAR to read data are always free. But when you make a call to add or update data, you have to do so from an account that has some amount of NEAR tokens available in its balance, and these tokens will be attached to pay the gas fee.
If you're coming from Ethereum, you may be used to the idea of paying a higher gas price to get your transaction processed faster. In NEAR, gas costs are deterministic, and you can't pay extra.
For basic operations like &quot;transfer funds,&quot; you can't specify an amount to attach. The gas needed is easy to calculate ahead of time, so it's automatically attached for you. (Check it: <a href="https://github.com/near/near-cli"><code>near-cli</code></a> has a <code>send</code> command, which accepts no <code>gas</code> parameter; <a href="https://github.com/near/near-api-js"><code>near-api-js</code></a> has a <a href="https://near.github.io/near-api-js/classes/near.near-1.html#sendtokens"><code>sendTokens</code></a> function which accepts no <code>gas</code> argument.) As shown in the tables above, these operations are cheap, so you probably won't even notice the slight reduction in your account's balance.
Function calls are more complex and you can attach an explicit amount of gas to these transactions, up to a maximum value of 3⨉10¹⁴ gas units. This maximum value of prepaid gas is subject to change but you can query this value by using the <a href="https://docs.near.org/concepts/basics/transactions/api/rpc/protocol#protocol-config"><code>protocol_config</code></a> RPC endpoint and search for <code>max_total_prepaid_gas</code>.
You can also override the default value of attached gas. Here is an example using <a href="https://github.com/near/near-cli"><code>near-cli</code></a>:
near call myContract.testnet myFunction &quot;{ &quot;arg1&quot;: &quot;val1&quot; }&quot; --gas=300000000000000
And in <a href="https://github.com/near/near-api-js"><code>near-api-js</code></a>, you can also specify an explicit amount of gas units to attach when calling a change method; see <a href="https://github.com/near-examples/guest-book/blob/ceb2a39e53351b4ffc21d01987e2b0b21d633fa7/src/App.js#L29">example here</a>.
The telltale error that calls for this solution looks like this:</p>
<pre><code class="language-text">Error:
  Transaction A9BzFKmgNNUmEx9Ue9ARC2rbWeiMnq6LpcXh53xPhSN6 failed.
  Exceeded the prepaid gas
</code></pre>
<p>&lt;blockquote class=&quot;warning&quot;&gt;
&lt;strong&gt;How many tokens will these units cost?&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
Note that you are greenlighting a maximum number of gas <em>units</em>, not a number of NEAR tokens or yoctoNEAR.
These units will be multiplied by the gas price at the block in which they're processed. If the function call makes cross-contract calls, then separate parts of the function will be processed in different blocks, and could use different gas prices. At a minimum, the function will take two blocks to complete, as explained in <a href="https://docs.near.org/concepts/basics/transactions/#the-cost-of-common-actions">the blue box above</a>.
Assuming the system rests at minimum gas price of 100 million yoctoNEAR during the total operation, a maximum attached gas of 3⨉10¹⁴ would seem to allow a maximum expenditure of 3⨉10²² yN. However, there's also a pessimistic multiplier of about 6.4 to <a href="https://github.com/nearprotocol/NEPs/issues/67">prevent shard congestion</a>.
Multiplying all three of these numbers, we find that maximum attached gas units allow about 0.2Ⓝ to be spent on the operation if gas prices stay at their minimum. If gas prices are above the minimum, this charge could be higher.
What if the gas price is at the minimum during the starting block, but the operation takes several blocks to complete, and subsequent blocks have higher gas prices? Could the charge be more than ~0.2Ⓝ? No. The pessimistic multiplier accounts for this possibility.
&lt;/blockquote&gt;</p>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#how-do-i-buy-gas">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How extra attached gas is getting refunded?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>How can you know the exact right amount to attach when you call a function? You can't!
Gas units are based on computational complexity for a given operation, which can be affected by a smart contract's state. This is hard to predict ahead of time. And gas price is adjusted each block based on how busy the network was during the previous block, which is also hard to predict ahead of time.
But good news!</p>
<ul>
<li>Gas doesn't cost much on NEAR</li>
<li>If you attach more gas than needed, you'll get refunded
This is also true for basic operations. In the previous section we mentioned that these are automatically calculated and attached. In fact, given that the gas price could be adjusted slightly while these operations are being applied (see blue box <a href="https://docs.near.org/concepts/basics/transactions/#the-cost-of-common-actions">above</a>), a slight amount extra is attached, and any beyond what's necessary gets refunded.</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#attach-extra-gas-get-refunded">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Pessimistic gas price inflation?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>A transactions may take several blocks before it completes. Due to dynamic gas price adjustments, later blocks may have a higher gas price than when the transaction was signed. To guarantee that the transaction can still finish, the amount of tokens reserved when starting a transaction is increased by the <em>pessimistic-inflation rule</em>.
The pessimistic inflation rule means that the gas has to be purchased at the highest theoretical gas price that the transaction could reach. The extra spending is only temporary, the difference between the pessimistic and actual price is refunded when the transaction finishes. This is the reason why in the explorer, virtually every transaction that spans more than one block contains a refund, even if all the gas has been spent.
By how much is the price inflated? It depends on how many blocks a transaction may take. A simple transaction that only sends tokens from one account to another can take between 2-3 blocks.</p>
<ul>
<li>One block to subtract the money from the signer's account</li>
<li>One block to add it to the receivers account</li>
<li>Potentially another block if the receiver is on another shard and the receipt application gets delayed.
Therefore, the pessimistically inflated price is increased by 3% or calculated as <code>gas_price</code> ⨉ 1.03. Every additional cross-shard communication adds another factor of 1.03.
For a function call, the maximum block delay is computed as the total gas attached divided by the minimum amount required to call another function. Therefore, the more gas you attach to a transaction, the higher your gas price. But again, the increased price is temporarily and will be refunded unless the network actually becomes that congested. Prices would have to go up by the maximum every block and your receipts would need to be very unlucky to have extra delays every time.</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What about Prepaid Gas?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The NEAR Team understands that developers want to provide their users with the best possible onboarding experience. To realize this vision, developers can design their applications in a way that first-time users can draw funds for purchasing gas directly from an account maintained by the developer. Once onboarded, users can then transition to paying for their own platform use.
In this sense, prepaid gas can be realized using a funded account and related contract(s) for onboarding new users.
<em>So how can a developer pay the gas fee for their users on NEAR?</em></p>
<ul>
<li>A user can use the funds directly from the developer's account suitable only for the gas fees on this dApp. Then the developer has to distinguish users based on the signers' keys instead of the account names.</li>
<li>Using function calls, you can allow a new user without an account to use your dApp and your contract on-chain. The back-end creates a new access key for the user on the contract's account and points it towards the contract itself. Now the user can immediately use the web app without going through any wallet.
NEAR Protocol does not provide any limiting feature on the usage of developer funds. Developers can set allowances on access keys that correspond to specific users -- one <code>FunctionCall</code> access key per new user with a specific allowance.</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#what-about-prepaid-gas">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What's the price of gas right now?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can directly query the NEAR platform for the price of gas on a specific block using the RPC method <code>gas_price</code>. This price may change depending on network load. The price is denominated in yoctoNEAR (10^-24 NEAR)</p>
<ol>
<li>Take any recent block hash from the blockchain using <a href="https://explorer.testnet.near.org/blocks">NEAR Explorer</a>
<em>At time of writing, <code>SqNPYxdgspCT3dXK93uVvYZh18yPmekirUaXpoXshHv</code> was the latest block hash</em></li>
<li>Issue an RPC request for the price of gas on this block using the method <code>gas_price</code> <a href="https://docs.near.org/concepts/basics/transactions/api/rpc/setup">documented here</a><pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 method=gas_price params:='[&quot;SqNPYxdgspCT3dXK93uVvYZh18yPmekirUaXpoXshHv&quot;]' id=dontcare
</code></pre>
</li>
<li>Observe the results<pre><code class="language-json">{
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;gas_price&quot;: &quot;5000&quot;
  }
}
</code></pre>
</li>
</ol>
<p>The price of 1 unit of gas at this block was 5000 yoctoNEAR (10^-24 NEAR).</p>
<p><a href="https://docs.near.org/concepts/basics/transactions/gas#whats-the-price-of-gas-right-now">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Transaction?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>A <code>Transaction</code> is a collection of <code>Actions</code> that describe what should be done at the destination (the <code>receiver</code> account).
Each <code>Transaction</code> is augmented with critical information about its:</p>
<ul>
<li><strong>origin</strong> (cryptographically signed by <code>signer</code>)</li>
<li><strong>destination</strong> or intention (sent or applied to <code>receiver</code>)</li>
<li><strong>recency</strong> (<code>block_hash</code> from recent block within acceptable limits - <a href="https://docs.near.org/concepts/basics/transactions/../epoch">1 epoch</a>)</li>
<li><strong>uniqueness</strong> (<code>nonce</code> must be unique for a given <code>signer</code> <code>AccessKey</code>)</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/transactions/overview#transaction">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Action?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>An <code>Action</code> is a composable unit of operation that, together with zero or more other <code>Actions</code>, defines a sensible <code>Transaction</code>. There are currently 8 supported <code>Action</code> types:</p>
<ul>
<li><code>FunctionCall</code> to invoke a method on a contract (and optionally attach a budget for compute and storage)</li>
<li><code>Transfer</code> to move tokens from between accounts</li>
<li><code>DeployContract</code> to deploy a contract</li>
<li><code>CreateAccount</code> to make a new account (for a person, contract, refrigerator, etc.)</li>
<li><code>DeleteAccount</code> to delete an account (and transfer the balance to a beneficiary account)</li>
<li><code>AddKey</code> to add a key to an account (either <code>FullAccess</code> or <code>FunctionCall</code> access)</li>
<li><code>DeleteKey</code> to delete an existing key from an account</li>
<li><code>Stake</code> to express interest in becoming a validator at the next available opportunity
You can find more about the technical details of <code>Action</code>s in the <a href="https://nomicon.io/RuntimeSpec/Actions">NEAR nomicon</a>.</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/transactions/overview#action">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Receipt?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>A <code>Receipt</code> is the only actionable object in the system. Therefore, when we talk about &quot;processing a transaction&quot; on the NEAR platform, this eventually means &quot;applying receipts&quot; at some point.
A good mental model is to think of a <code>Receipt</code> as a paid message to be executed at the destination (<code>receiver</code>). And a <code>Transaction</code> is an externally issued request to create the <code>Receipt</code> (there is a 1-to-1 relationship).
There are several ways of creating <code>Receipts</code>:</p>
<ul>
<li>issuing a <code>Transaction</code></li>
<li>returning a promise (related to cross-contract calls)</li>
<li>issuing a refund
You can find more about the technical details of <code>Receipts</code> in the <a href="https://nomicon.io/RuntimeSpec/Receipts">NEAR nomicon</a>.</li>
</ul>
<p><a href="https://docs.near.org/concepts/basics/transactions/overview#receipt">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Transaction Atomicity?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Since transactions are converted to receipts before they are applied, it suffices to talk about receipt atomicity.
Receipt execution is atomic, meaning that either all the actions are successfully executed or none are.
However, one caveat is that a function call transaction, unlike other transactions, can spawn an indefinite amount of receipts, and while each receipt is atomic, the success or failure of one receipt doesn't necessarily affect the status of other receipts spawned by the same transaction.
info
When designing a smart contract, you should always consider the asynchronous nature of NEAR Protocol.</p>
<p><a href="https://docs.near.org/concepts/basics/transactions/overview#atomicity">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Transaction Status?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can query the status of a transaction through <a href="https://docs.near.org/concepts/basics/transactions/api/rpc/setup">RPC API</a>. An example of the query result looks like this:</p>
<pre><code class="language-json">{
  &quot;status&quot;: { &quot;SuccessValue&quot;: &quot;&quot; },
  &quot;transaction&quot;: {
    &quot;actions&quot;: [
      { &quot;Transfer&quot;: { &quot;deposit&quot;: &quot;50000000000000000000000000&quot; } }
    ],
    &quot;hash&quot;: &quot;EL9cEcoiF1ThH1HXrdE5LBuJKzSe6dRr7tia61fohPrP&quot;,
    &quot;nonce&quot;: 51,
    &quot;public_key&quot;: &quot;ed25519:5zset1JX4qp4PcR3N9KDSY6ATdgkrbBW5wFBGWC4ZjnU&quot;,
    &quot;receiver_id&quot;: &quot;transfer-vote.near&quot;,
    &quot;signature&quot;: &quot;ed25519:37rcwcjDBWWAaaRYCazHY72sfDbmudYvtmEBHMFmhYEfWD3mbrgrtYs5nVh9gzRUESELRDET9g72LnAD2BWdSgKu&quot;,
    &quot;signer_id&quot;: &quot;near&quot;
  },
  &quot;transaction_outcome&quot;: {
    &quot;block_hash&quot;: &quot;dvwSabiWzRjfQamZCEMeguxxXL4885JGU87xfjoPWR2&quot;,
    &quot;id&quot;: &quot;EL9cEcoiF1ThH1HXrdE5LBuJKzSe6dRr7tia61fohPrP&quot;,
    &quot;outcome&quot;: {
      &quot;executor_id&quot;: &quot;near&quot;,
      &quot;gas_burnt&quot;: 223182562500,
      &quot;logs&quot;: [],
      &quot;metadata&quot;: { &quot;gas_profile&quot;: null, &quot;version&quot;: 1 },
      &quot;receipt_ids&quot;: [
        &quot;6LrHPazG3DTcKkd4TjqbgajqmbcAfyoTG383Cft5SZ5Y&quot;
      ],
      &quot;status&quot;: {
        &quot;SuccessReceiptId&quot;: &quot;6LrHPazG3DTcKkd4TjqbgajqmbcAfyoTG383Cft5SZ5Y&quot;
      },
      &quot;tokens_burnt&quot;: &quot;22318256250000000000&quot;
    },
    &quot;proof&quot;: []
  },
  &quot;receipts_outcome&quot;: [
    {
      &quot;block_hash&quot;: &quot;6evPKFQRw1E3gH9L1d59mz7GahsbnqsdYwcZQo8hpFQB&quot;,
      &quot;id&quot;: &quot;6LrHPazG3DTcKkd4TjqbgajqmbcAfyoTG383Cft5SZ5Y&quot;,
      &quot;outcome&quot;: {
        &quot;executor_id&quot;: &quot;transfer-vote.near&quot;,
        &quot;gas_burnt&quot;: 223182562500,
        &quot;logs&quot;: [],
        &quot;metadata&quot;: { &quot;gas_profile&quot;: null, &quot;version&quot;: 1 },
        &quot;receipt_ids&quot;: [
          &quot;7NMpF9ZGwSj48bpvJK2xVobJkTasEkakazTKi2zotHR4&quot;
        ],
        &quot;status&quot;: { &quot;SuccessValue&quot;: &quot;&quot; },
        &quot;tokens_burnt&quot;: &quot;22318256250000000000&quot;
      },
      &quot;proof&quot;: []
    },
    {
      &quot;block_hash&quot;: &quot;Gm6TFS1ZxmA45itVj8a7vE8yJF8V5hXeNF1EhEVr7GVS&quot;,
      &quot;id&quot;: &quot;7NMpF9ZGwSj48bpvJK2xVobJkTasEkakazTKi2zotHR4&quot;,
      &quot;outcome&quot;: {
        &quot;executor_id&quot;: &quot;near&quot;,
        &quot;gas_burnt&quot;: 0,
        &quot;logs&quot;: [],
        &quot;metadata&quot;: { &quot;gas_profile&quot;: null, &quot;version&quot;: 1 },
        &quot;receipt_ids&quot;: [],
        &quot;status&quot;: { &quot;SuccessValue&quot;: &quot;&quot; },
        &quot;tokens_burnt&quot;: &quot;0&quot;
      },
      &quot;proof&quot;: []
    }
  ]
}
</code></pre>
<p>The query result displays:</p>
<ul>
<li>the overall status of the transaction,</li>
<li>the outcomes of the transaction,</li>
<li>and the outcome of the receipts generated by this transaction.
The <code>status</code> field appears at:</li>
<li>the top-level, where it indicates whether all actions in the transaction have been successfully executed,</li>
<li>under <code>transaction_outcome</code>, where it indicates whether the transaction has been successfully converted to a receipt,</li>
<li>under <code>receipts_outcome</code> for each receipt, where it indicates whether the receipt has been successfully executed.
The <code>status</code> is an object with a single key, one of the following four:</li>
<li><code>status: { SuccessValue: 'val or empty'}</code> - the receipt or transaction has been successfully executed. If it's the result of a function call receipt, the value is the return value of the function, otherwise the value is empty.</li>
<li><code>status: { SuccessReceiptId: 'id_of_generated_receipt' }</code> - either a transaction has been successfully converted to a receipt, or a receipt is successfully processed and generated another receipt. The value of this key is the id of the newly generated receipt.</li>
<li><code>status: { Failure: {} }'</code> - transaction or receipt has failed during execution. The value will include error reason.</li>
<li><code>status: { Unknown: '' }'</code> - the transaction or receipt hasn't been processed yet.
note
For receipts, <code>SuccessValue</code> and <code>SuccessReceiptId</code> come from the last action's execution. The results of other action executions in the same receipt are not returned. However, if any action fails, the receipt's execution stops, and the failure is returned, meaning that <code>status</code> would be <code>Failure</code>. And if the last action is not a function call and it's successfully executed, the result will be an empty <code>SuccessValue</code></li>
</ul>
<p>The top-level <code>status</code> indicates whether all actions in the transaction have been successfully executed. However, one caveat is that the successful execution of the function call does not necessarily mean that the receipts spawned from the function call are all successfully executed.
For example:</p>
<pre><code class="language-rust">pub fn transfer(receiver_id: String) {
    Promise::new(receiver_id).transfer(10);
}
</code></pre>
<p>This function schedules a promise, but its return value is unrelated to that promise. So even if the promise fails, potentially because <code>receiver_id</code> does not exist, a transaction that calls this function will still have <code>SuccessValue</code> in the overall <code>status</code>. You can check the status of each of the receipts generated by going through <code>receipt_outcomes</code> in the same query result.</p>
<p><a href="https://docs.near.org/concepts/basics/transactions/overview#transaction-status">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Validator's Economy?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In exchange for servicing the network, validators are rewarded with a target number of NEAR every epoch. The target value is computed in such a way that, on an annualized basis, it will be 4.5% of the total supply.
All transaction fees (minus the part which is allocated as the rebate for contracts) which are collected within each epoch are burned by the system. The inflationary reward is paid out to validators at the same rate regardless of the number of fees collected or burned.</p>
<p><a href="https://docs.near.org/concepts/basics/validators">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Intro to Validators?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><a href="https://near.org/papers/the-official-near-white-paper/#economics">Validators</a> are responsible for producing blocks and the security of the network.
Since Validators validate all shards, high requirements are set for running them (an 8-Core CPU with 16GB of RAM and 1 TB SSD of storage). The cost of running a block-producing validator node is estimated to be $330 per month for hosting. Please see our <a href="https://near-nodes.io/validator/hardware">hardware and cost estimates page</a> for more info.
The current active Validators are available on the Explorer. The minimum seat price to become a block-producing validator is based on the 100th proposal. (If more than 100 proposals are submitted, the threshold will simply be the stake of the 100th proposal, provided that it’s larger than the minimum threshold of 67,000 $NEAR.) The current seat price to become a block-producing validator is updated live on the Explorer. Any validator nodes with stakes higher than the seat price can join the active set of Validators.
&lt;blockquote class=&quot;lesson&quot;&gt;
&lt;strong&gt;Is there a plan to support GPU compute if certain validator nodes can offer that or is it just CPU?&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;</p>
<p>We don't need GPU support as we are a POS chain and we require very little compute power.
You can read more about our consensus strategy on our &lt;a href=&quot;https://github.com/near/wiki/blob/master/Archive/validators/about.md&quot;&gt;Validator Quickstart&lt;/a&gt; and &lt;a href=&quot;https://github.com/near/wiki/blob/master/Archive/validators/faq.md&quot;&gt;Staking FA&lt;/a&gt;.
&lt;/blockquote&gt;</p>
<p><a href="https://docs.near.org/concepts/basics/validators">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Chunk-Only Validators?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The Chunk-Only Producer is a more accessible role with lower hardware and token requirements. This new role will allow the network's validator number to grow, creating more opportunities to earn rewards and secure the NEAR Ecosystem.
<a href="https://near.org/papers/the-official-near-white-paper/#economics">Chunk-Only Producers</a> are solely responsible for <a href="https://near.org/papers/nightshade/#nightshade">producing chunks</a> (parts of the block from a shard, see <a href="https://near.ai/nightshade">Nightshade</a> for more detail) in one shard (a partition on the network). Because Chunk-Only Producers only need to validate one shard, they can run the validator node on a 4-Core CPU, with 8GB of RAM, and 200 GB SSD of storage.
Like Validators, Chunk-Only Producers will receive, at minimum, 4.5% annual rewards. If less than 100% of the tokens on the network is staked, Chunk-Only Producers stand to earn even more annual rewards. For more details about the Validator’s economics, please check out <a href="https://near.org/blog/near-protocol-economics/">NEAR’s Economics Explained</a>.</p>
<p><a href="https://docs.near.org/concepts/basics/validators">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Dedicated Validator Documentation Site?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If you'd like to further explore Validators and Nodes in general, you can visit the <a href="https://near-nodes.io/">Dedicated Validator Documentation Site</a>.
&lt;blockquote class=&quot;lesson&quot;&gt;
&lt;strong&gt;If a developer writes a vulnerable or malicious dApp, is a validator implicitly taking on risk?&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;</p>
<p>No. We have handled the potential damages to the network on the protocol level. For example, we have a lot of limiters that constrain how much data you can pass into a function call or how much compute you can do in one function call, etc.
That said, smart contract developers will need to be responsible for their own dApps, as there is no stage gate or approval process. All vulnerability can only damage the smart contract itself. Luckily, updating smart contracts is very smooth on NEAR, so vulnerabilities can be updated/patched to an account in ways that cannot be done on other blockchains.
&lt;/blockquote&gt;</p>
<p><a href="https://docs.near.org/concepts/basics/validators">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Arweave?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><a href="https://www.arweave.org/">Arweave</a> is a new type of storage that backs data with sustainable and perpetual endowments
(tokens held within the protocol that benefit from inflation and the decrease in the cost of storage over long periods of time). This allows users and developers to store data forever.
Arweave acts as a collectively owned hard drive, and allows their users to preserve valuable information, apps, and history indefinitely.
The Arweave protocol matches a torrent-like swarm of incentivised miners with massive collective hard drive space with those individuals and organizations that need to store data or host content permanently. This is achieved in a decentralized network, and all data stored is backed by block mining rewards and a <a href="https://arwiki.wiki/#/en/storage-endowment">sustainable endowment</a> ensuring it is available in perpetuity.
info
To learn more about Arweave, check its <a href="https://arwiki.wiki/#/en/arweave-mining">mining mechanism</a> and its <a href="https://arwiki.wiki/#/en/karma">bandwidth-sharing system</a>.</p>
<p><a href="https://docs.near.org/concepts/storage/decentralized-storage">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How does NEAR's design align incentives?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Storage-staked tokens are unavailable for other uses, such as validation staking. This increases the yield that validators will receive. Learn more in <a href="https://near.org/papers/economics-in-sharded-blockchain/">the economics whitepaper</a>.</p>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#how-does-nears-design-align-incentives">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>When do tokens get staked?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>On each incoming transaction that adds data.
Let's walk through an example:</p>
<ol>
<li>You launch <a href="https://examples.near.org/guest-book">a guest book app</a>, deploying your app's smart contract to the account <code>example.near</code></li>
<li>Visitors to your app can add messages to the guest book. This means your users will, <a href="https://docs.near.org/concepts/storage/concepts/basics/transactions/gas#what-about-prepaid-gas">by default</a>, pay a small gas fee to send their message to your contract.</li>
<li>When such a call comes in, NEAR will check that <code>example.near</code> has a large enough balance that it can stake an amount to cover the new storage needs. If it does not, the transaction will fail.</li>
</ol>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#when-do-tokens-get-staked">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is  The &quot;million cheap data additions&quot; attack?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Note that this can create an attack surface. To continue the example above, if sending data to your guest book costs users close to nothing while costing the contract owner significantly more, then a malicious user can exploit the imbalance to make maintaining the contract prohibitively expensive.
Take care, then, when designing your smart contracts to ensure that such attacks cost potential attackers more than it would be worth.</p>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#the-million-cheap-data-additions-attack">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to remove data to unstake some tokens?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>People familiar with the &quot;immutable data&quot; narrative about blockchains find this surprising. While it's true that an <em>indexing node</em> will keep all data forever, <em>validating nodes</em> (that is, the nodes run by most validators in the network) do not. Smart contracts can provide ways to delete data, and this data will be purged from most nodes in the network within a few <a href="https://docs.near.org/concepts/storage/../basics/epoch">epochs</a>.
Note that a call to your smart contract to remove data has an associated gas fee. Given NEAR's gas limit, this creates an upper limit on how much data can be deleted in a single transaction.</p>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#btw-you-can-remove-data-to-unstake-some-tokens">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How much does it cost?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Storage staking is priced in an amount set by the network, which is set to <strong>1E19 yoctoNEAR per byte</strong>, or <strong>100kb per NEAR token (Ⓝ)</strong>. [^1] [^2]
NEAR's JSON RPC API provides <a href="https://docs.near.org/concepts/storage/api/rpc/setup#genesis-config">a way to query this initial setting</a> as well as a <a href="https://docs.near.org/concepts/storage/api/rpc/setup#protocol-config">a way to query the live config / recent blocks</a>.</p>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#how-much-does-it-cost">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Example cost breakdown?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Let's walk through an example.
A <a href="https://github.com/nearprotocol/NEPs/pull/4">non-fungible token</a> is unique, which means each token has its own ID. The contract must store a mapping from token IDs to owners' account ID.
If such an NFT is used to track <strong>1 million</strong> tokens, how much storage will be required for the token-ID-to-owner mapping? And how many tokens will need to be staked for that storage?
Using <a href="https://github.com/near-examples/NFT/releases/tag/nep4-example">this basic AssemblyScript implementation</a> as inspiration, let's calculate the storage needs when using a <a href="https://near.github.io/near-sdk-as/classes/_sdk_core_assembly_collections_persistentmap_.persistentmap.html"><code>PersistentMap</code></a> from <code>near-sdk-as</code>. While its specific implementation may change in the future, at the time of writing <code>near-sdk-as</code> stored data as UTF-8 strings. We'll assume this below.
Here's our <code>PersistentMap</code>:</p>
<pre><code class="language-ts">type AccountId = string;
type TokenId = u64;
const tokenToOwner = new PersistentMap&lt;TokenId, AccountId&gt;(&quot;t2o&quot;);
</code></pre>
<p>Behind the scenes, all data stored on the NEAR blockchain is saved in a key-value database. That <code>'t2o'</code> variable that's passed to <code>PersistentMap</code> helps it keep track of all its values. If your account <code>example.near</code> owns token with ID <code>0</code>, then at the time of writing, here's the data that would get saved to the key-value database:</p>
<ul>
<li>key: <code>t2o::0</code></li>
<li>value: <code>example.near</code>
So for 1 million tokens, here are all the things we need to add up and multiply by 1 million:</li>
</ul>
<ol>
<li>The prefix, <code>t2o</code>, will be serialized as three bytes in UTF-8, and the two colons will add another two. That's 5 bytes.</li>
<li>For an implementation where <code>TokenId</code> auto-increments, the values will be between <code>0</code> and <code>999999</code>, which makes the average length 5 bytes.</li>
<li>Let's assume well-formed NEAR <code>AccountId</code>s, and let's guess that NEAR Account IDs follow the approximate pattern of domain names, which <a href="https://www.gaebler.com/Domain-Length-Research.htm">average about 10 characters</a>, plus a top-level name like <code>.near</code>. So a reasonable average to expect might be about 15 characters; let's keep our estimate pessimistic and say 25. This will equal 25 bytes, since NEAR account IDs must use characters from the ASCII set.
So:
1_000_000 * (5 + 5 + 25)
35 million bytes. 350 times 100Kib, meaning Ⓝ350. To do the exact math: Multiplying by 1e19 yoctoNEAR per byte, we find that the <code>tokenToOwner</code> mapping with 35m bytes will require staking 3.5e26 yoctoNEAR, or Ⓝ350
Note that you can get this down to Ⓝ330 just by changing the prefix from <code>t2o</code> to a single character. Or get rid of it entirely! You can have a zero-length prefix on one <code>PersistentVector</code> in your smart contract. If you did that with this one, you could get it down to Ⓝ250.</li>
</ol>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#example-cost-breakdown">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Calculate costs for your own contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Doing manual byte math as shown above is difficult and error-prone. Good news: you don't have to!
You can test storage used right in your unit tests:</p>
<ul>
<li>Using <a href="https://near.github.io/near-sdk-as"><code>near-sdk-as</code></a>, import <code>env</code> and check <code>env.storage_usage()</code> – <a href="https://github.com/near/near-sdk-as/blob/b308aa48e0bc8336b458f05a231409be4dee6c69/sdk/assembly/__tests__/runtime.spec.ts#L156-L200">example</a>
You can also test storage in simulation tests; check out <a href="https://github.com/near-examples/simulation-testing">this simulation test example</a> to get started.</li>
</ul>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#calculate-costs-for-your-own-contract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Other ways to keep costs down?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Storing data on-chain isn't cheap for the people running the network, and NEAR passes on this cost to developers. So, how do you, as a developer, keep your costs down? There are two popular approaches:</p>
<ol>
<li>Use a binary serialization format, rather than JSON</li>
<li>Store data off-chain</li>
</ol>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#other-ways-to-keep-costs-down">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Use a binary serialization format, rather than JSON?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The core NEAR team maintains a library called <a href="https://borsh.io/">borsh</a>,
which is used automatically when you use <code>near-sdk-rs</code>. Someday, it will probably also be used by <code>near-sdk-as</code>.
Imagine that you want to store an array like <code>[0, 1, 2, 3]</code>. You could serialize it as a string and store it as UTF-8 bytes. This is what <code>near-sdk-as</code> does today. Cutting out spaces, you end up using 9 bytes.
Using borsh, this same array gets saved as 8 bytes:
\u0004\u0000\u0000\u0000\u0000\u0001\u0002\u0003
At first glance, saving 1 byte might not seem significant. But let's look closer.
The first four bytes here, <code>\u0004\u0000\u0000\u0000</code>, tell the serializer that this is a <code>u32</code> array of length <code>4</code> using little-endian encoding. The rest of the bytes are the literal numbers of the array – <code>\u0000\u0001\u0002\u0003</code>. As you serialize more elements, each will add one byte to the data structure. With JSON, each new element requires adding two bytes, to represent both another comma and the number.
In general, Borsh is faster, uses less storage, and costs less gas. Use it if you can.</p>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#use-a-binary-serialization-format-rather-than-json">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Store data off-chain?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>This is especially important if you are storing user-generated data!
Let's use this <a href="https://github.com/near-examples/guest-book">Guest Book</a> as an example. As implemented today, visitors to the app can sign in with NEAR and leave a message. Their message is stored on-chain.
Imagine this app got very popular, and that visitors started leaving unexpectedly long messages. The contract owner might run out of funding for storage very quickly!
A better strategy could be to store data off-chain. If you want to keep the app decentralized, a popular off-chain data storage solution is <a href="https://ipfs.io/">IPFS</a>. With this, you can represent any set of data with a predictable content address such as:
QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG
Such a content address could represent a JSON structure or an image or any other type of data. Where does this data get physically stored? You could use <a href="https://filecoin.io/">Filecoin</a> or run your own IPFS server to pin your app's data.
With this approach, each record you add to your contract will be a predictable size.</p>
<p><a href="https://docs.near.org/concepts/storage/storage-staking#store-data-off-chain">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Building blocks of Web decentralization?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>As we already briefly discussed, the current Web is highly centralized, and mostly built using <a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">client-server architecture</a> on centralized servers hosted on one of the clouds (AWS, Azure, GCP, etc). According to one <a href="https://www.statista.com/statistics/292840/distribution-global-cloud-and-non-cloud-traffic/">report</a>, 90% of mobile traffic goes to the clouds, which means a significant portion of the Internet is basically controlled by a handful of companies. This consolidation of power has a number of downsides and this article on &quot;<a href="https://onezero.medium.com/why-decentralization-matters-5e3f79f7638e">Why Decentralization Matters</a>&quot; does a good job explaining some of those problems.
The first decentralization revolution happened in file sharing, with the arrival of the (in)famous BitTorrent protocol. By being a p2p protocol, it’s truly decentralized, and allows data to be stored distributedly without any central authority (and sometimes without consent of a central authority, which caused a lot of drama, but that’s a story for another time). Ideas behind this protocol have been used in modern decentralized file storages like IPFS and FileCoin, we’ll come back to this later and explore it in more details.
The next revolution happened in the world of finance. For a long time transferring money required a central authority (banks), which would monitor, approve and execute these transfers. This has changed when the first cryptocurrency - Bitcoin - appeared. As already mentioned BitTorrent protocol, it also uses p2p communication, but instead of files it operates a transaction ledger, which is stored as a blockchain. Blockchain structure is needed to ensure that stored ledger cannot be altered, and at the same time to incentivize storage of this data. Unlike BitTorrent, Bitcoin network participants are rewarded for their services using a process called “mining”. This created a foundation for a new form of currency - digital currency (or cryptocurrency), with a unique property that it doesn’t need a central authority to function. Instead, users themselves maintain and operate it. And as with the previous decentralized system, BitTorrent, central authorities have issues with this.
Following the success of Bitcoin, other cryptocurrencies started to appear. The most important one is Ethereum, which took the concept of blockchain one step further and adapted it to store not just a transactions leger, but any kind of data, and, most importantly code (which is just another form of data). Basically, it turned out we can use it as a decentralized database transaction log. And if we have data and code living in the decentralized database, the only thing we lack to build a decentralized application is an ability to execute this code. So Ethereum did just that, and a Smart Contract was born. Now, let's dive deeper into the world of blockchains, smart contracts, and explore how we can build decentralized applications with them.</p>
<p><a href="https://docs.near.org/concepts/web3/blockchain">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Blockchain basics?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Let's start with a brief overview of what blockchain and smart contracts are.
In classical Web 2.0 applications, you need 2 things to build an application backend: a database to store data and a server to execute your code. The same is true for the Web 3.0, but instead of a database we have a blockchain, and instead of a server we have smart contracts.
Blockchain itself is just a linked list (chain) of transactions. As a performance optimization, instead of linking individual transactions, they are grouped into blocks. Linking happens using hashes - each block contains the cryptographic hash of a previous block. Such a structure grants us an important property - we cannot modify an individual transaction inside a chain, since it would change its hash and invalidate all transactions after it. This makes it an ideal structure to store in a decentralized fashion, since everyone can quickly verify the integrity of a transaction on a chain (and of the entire chain).
<img src="https://docs.near.org/docs/assets/web3/web3-1.png" alt="image">
Since we can only add new transactions to the chain, it serves as a decentralized transaction log. And if we have a <a href="https://en.wikipedia.org/wiki/Transaction_log">transaction log</a>, we basically have our database. Another good mental model is to think about this as a decentralized <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing">event sourcing pattern</a>, where each transaction represents a separate event.
Due to the distributed nature of a blockchain, that has no single server which would manage a blockchain, a <a href="https://www.investopedia.com/terms/c/consensus-mechanism-cryptocurrency.asp">consensus mechanism</a> is used to add new blocks, synchronize data between machines, and incentivize network participation. Several consensus mechanisms exist, we’ll discuss them in more detail later.
It’s important to remember that every transaction on blockchain is publicly visible, so sensitive data should be encrypted beforehand.
But how do we put transactions into a blockchain? That’s the purpose of a Blockchain Node. Everyone can set up their own node, connect to the p2p blockchain network, and post new transactions. Also, this node provides access to the current blockchain data.
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/web3--2.png&quot; alt=&quot;image&quot; width=&quot;440&quot; /&gt;
&lt;/div&gt;
Blockchain transactions themselves can be of a different type; exact supported types depend on a specific blockchain network. In the first Blockchain network, the Bitcoin, which stored only a financial ledger, transactions were quite simple - mostly just transfers of funds between accounts. This works very well for decentralized financing (Bitcoin is still the most popular cryptocurrency), but if we want to build general-purpose decentralized applications (or dApps for short), we need something better. That's where smart contracts come into the stage.
For Web 2.0 developers, a good way to think about a smart contract is as a serverless function which runs on blockchain nodes, instead of a traditional cloud. However, It has a few important properties:</p>
<ul>
<li>It is a pure function, which accepts the current state (which is stored on the blockchain) and caller-supplied arguments, and returns a modified state: <em>F(state, args)</em> -&gt; <em>state</em>. In practical terms, it means that we can’t do any external (off-blockchain) calls from it - no API or DB server calls are allowed. The reason behind this is decentralization - different nodes on the network should be able to execute it and get the same result.</li>
<li>It’s fully open-source. Everyone is able to view your code and check what it’s doing.</li>
<li>It cannot be changed. Once deployed, code remains on the chain forever and cannot be altered. Different upgrade mechanisms are possible, but are chain-specific.
Such properties allow us to make analogies with real-world legal contracts - they cannot be changed (usually), they're predictable and they're publicly accessible for participants. Smart contracts are basically such contracts, or agreements, but instead of a human performing actions, they are represented as code.
But how do we deploy and execute them, if everything we can do is to create a transaction?  All we need are 2 specific types of transactions:</li>
<li>Deploy smart contract code, so it will be persisted in the blockchain, together with other data.</li>
<li>Call a smart contract with given arguments. As an outcome, a modified state will be returned.
When a call transaction arrives on a node, it will read the contract's code and state from the blockchain, execute it, and put a modified state back on a chain (as a transaction).
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/web3-2.png&quot; alt=&quot;image&quot; width=&quot;440&quot; /&gt;
&lt;/div&gt;
So far we’ve explored how the backend layer of a dApp looks like, but what about the client side? Since we are using an API to communicate, we can use any kind of a client we use in the Web 2.0 - web, mobile, desktop, and even other servers. However, an important distinction lies with users.
In a traditional Web 2.0 application, each server owns the identities of its users, and fully in control over who can and can’t use its services. In blockchain, however, there are no such restrictions, and anyone can interact with it (there are <a href="https://www.investopedia.com/terms/p/permissioned-blockchains.asp">private blockchains</a>, but we’ll leave them out of scope).
But how do we perform authentication if there is no standard login/registration process? Instead, we use public key cryptography, where a public key serves as a username, and a private key is a loose equivalent of a password. The major distinction is that instead of a login procedure, in which the server verifies the credentials and grants some form of an access token, here the users sign transactions with a private key. This means there's no classical Web 2 identity (like username, email, or an ID) available. This should be considered if you are building applications that require <a href="https://en.wikipedia.org/wiki/Know_your_customer">KYC</a>.
Another important implication of using private/public key pairs for auth, is that they cannot be easily memorized, like username/password pair. For this purpose, special applications called wallets are used. They store user’s key pairs and can sign transactions or provide them for other applications.
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/web3-3.png&quot; alt=&quot;image&quot; width=&quot;440&quot; /&gt;
&lt;/div&gt;
The one aspect we haven’t considered yet is infrastructure cost. In WEB 2.0, users pay for the provided service (directly with money or indirectly with their data, or both), and service providers pay for the infrastructure.</li>
</ul>
<p><img src="/docs/assets/web3/web3-4.png" alt="image"></p>
<p>In a Web 3.0 model, users pay directly to the infrastructure provider (nodes running in the blockchain), bypassing the service provider.
<img src="/docs/assets/web3/web3-5.png" alt="image"></p>
<p>This has huge implications:</p>
<ul>
<li>Service providers can’t shut down services or restrict their usage, since they are deployed on blockchain and can’t be removed. This means the application will live forever (or at least while the blockchain network is alive).</li>
<li>A new monetization model should be used for such services, since users don’t pay directly to service providers. For example, a fee can be coded into a smart contract for performing certain actions.</li>
<li>Since users should pay for the infrastructure, there’s no free lunch (this is usually true for Web 2.0 as well, but it’s often not obvious for ordinary users). Service providers can cover some cost or provide a credit to simplify onboarding, but ultimately users would have to pay.
But how do users pay? Since it’s a blockchain, they can’t pay directly with a credit card - in this way it will be tied to a central authority and not really decentralized. A solution is to use a decentralized currency - cryptocurrency. Each blockchain has its own currency, which is used for payments inside of it.</li>
</ul>
<p>Whenever a user wants to perform an action on a blockchain by calling a smart contract, it should always pay an infrastructure cost, and optionally a service cost to the service provider.
<img src="/docs/assets/web3/web3-6.png" alt="image"></p>
<p>This infrastructure cost, often called “gas”, usually consists of 2 parts:</p>
<ul>
<li>Computational cost - to cover computational power needed to add a transaction into a blockchain.</li>
<li>Storage cost  - to cover additional storage requirements necessary for each transaction.
However, the question still remains how users can obtain cryptocurrency tokens in the first place. One option is to buy it from other users who already own it by using traditional money or another cryptocurrency. There are exchanges which provide such kind of functionality, e.g. <a href="https://www.binance.com/en">Binance</a>. But this will work only if there is already an existing supply of tokens already in circulation.
In order to create and grow this supply the blockchain consensus mechanism is used. Earlier, we mentioned that it is used to incentivize blockchain network participation, but how exactly does it happen? Each node that processes transactions receives a reward for its work:</li>
</ul>
<pre><code>reward = infrastructureCostReward + coinbaseReward
</code></pre>
<p>where:</p>
<ul>
<li><code>infrastructureCostReward</code> - share of infrastructure cost paid for the transactions by the users</li>
<li><code>coinbaseReward</code> - new cryptocurrency token created specifically to reward processing nodes
This means each time a transaction is processed a small amount of cryptocurrency is created, so the amount of cryptocurrency in circulation grows over time (of course some amount of tokens should be created to bootstrap the network, e. g. by using <a href="https://www.investopedia.com/terms/i/initial-coin-offering-ico.asp">ICO</a>).
At a present day, two consensus mechanisms are commonly used:</li>
<li><a href="https://www.investopedia.com/terms/p/proof-work.asp">Proof-of-work</a> - original consensus mechanism, which is used by Bitcoin and Ethereum. It’s highly criticized for its inefficiency -  processing of new transactions requires “mining”, which is a highly computationally intensive process. Because of this, graphic cards became an endangered species. Another disadvantage - cost of transactions is very high and processing speed is also quite slow.</li>
<li><a href="https://www.investopedia.com/terms/p/proof-stake-pos.asp">Proof-of-stake</a> - newer consensus mechanism, which doesn’t require significant processing power (and graphic cards). Processing of transactions is usually called “validation”. Newer chains, like NEAR, use it. Ethereum is also currently in a process of switching to this model. Transactions are usually much cheaper and processing speed is faster.
At this point, we should have enough knowledge to proceed to the next chapter - choosing the best blockchain to build dApps.</li>
</ul>
<p><a href="https://docs.near.org/concepts/web3/blockchain">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Non-Fungible Tokens?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>At the heart of the new Web 3 economy lies <a href="https://en.wikipedia.org/wiki/Non-fungible_token">Non-Fungible token</a> (NFT). In a nutshell, it’s a way to  represent digital ownership in a decentralized way. From a technical perspective, it’s just a piece of data on a blockchain. The simplest case of such data is just a <code>(token_id, accoount_id)</code> tuple, where <code>token_id</code> uniquely identifies an asset, and <code>account_id</code> identifies an owner. A smart contract that owns this data defines a set of allowed operations - like creation of a new token (minting) or transfer of a token to another account. An exact set of allowed operations is defined in an NFT standard. Different blockchains have different standards, NEAR NFT Standard is available <a href="https://nomicon.io/Standards/NonFungibleToken/">here</a>.
Because NFTs are tied to a specific contract, they mostly make sense only in scope of this contract, and subsequently they are tied to a specific dApp. It’s possible to implement transfer of NFTs between contracts, but there’s no standard way to do this.
What digital asset is hiding behind a <code>token_id</code> is up to the smart contract to decide. There are few common ways how to handle this:</p>
<ul>
<li>Store an asset itself in a smart contract alongside the ownership information. This is the most straightforward way, but often is not feasible since storage cost is quite high and many types of digital assets, especially media, are quite big.
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/web3-20.png&quot; alt=&quot;image&quot; width=&quot;400&quot; /&gt;
&lt;/div&gt;</li>
<li>Store token data off-chain. Such an approach solves storage cost problems, but requires some level of trust to guarantee that data in the off-chain storage won’t be changed or removed.
<img src="https://docs.near.org/docs/assets/web3/web3-21.png" alt="image"></li>
<li>Store asset’s metadata and hash on chain, and an asset itself on some off-chain storage. Storing an asset’s hash on a chain guarantees data integrity and immutability. On-chain metadata usually includes basic token information, like title, description and media url. It’s required to quickly identify an asset without downloading it from the storage. This is the most popular approach to handle NFT’s since it combines the best of 2 previous approaches - token is immutable and storage cost is cheap (exact cost depends on the storage solution, but it usually several orders of magnitude cheaper than an on-chain storage)
<img src="/docs/assets/web3/web3-22.png" alt="image">
Choosing the right off-chain storage also can be a challenge, in general they can be divided into 2 buckets:</li>
<li>Centralized storages - traditional Web 2 storage solutions, like relational databases or blob storages. While suitable for some applications, this means NFTs can be destroyed if a central server goes offline, so they aren’t the most popular in the Web 3 world.</li>
<li>Decentralized storages. As we already mentioned, BitTorrent protocol is one of the first examples of such decentralized storage solutions, but in recent years more advanced solutions have appeared - like <a href="https://ipfs.io/">IPFS</a>, <a href="https://filecoin.io/">FileCoin</a> and <a href="https://www.arweave.org/">Arweawe</a>. Such solutions are a preferred method to store digital assets, since they are cheap and decentralized, so no-one can destroy or alter NFT assets.
In addition to the NFT standard, NEAR also provides <a href="https://docs.rs/near-contract-standards/latest/near_contract_standards/non_fungible_token/index.html">its implementation</a>, which can be used by Smart Contract developers to implement NFTs in their smart contract. Implementation itself doesn’t dictate assets storage model, so it’s up to a developer to decide how and where it will be stored.</li>
</ul>
<p><a href="https://docs.near.org/concepts/web3/economics">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Accounts &amp; Transactions?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR's account system is very powerful and differs substantially from other blockchains, like Bitcoin or Ethereum. Instead of identifying users by their public/private key pairs, it defines accounts as first-class entities. This has a few important implications:</p>
<ul>
<li>Instead of public keys, users can use readable account names.</li>
<li>Multiple key pairs with <a href="https://docs.near.org/concepts/web3/../basics/accounts/access-keys">different permissions</a> can be used. This provides a better security model for users, since loss of one key pair doesn’t compromise an entire account and has a quite limited impact.</li>
<li>Hierarchical accounts structure is supported. This is useful if we want to manage multiple smart contracts under one parent account.</li>
<li>Accounts/public keys are created using transactions, since they are stored on the blockchain.
More information on NEAR accounts can be <a href="https://docs.near.org/concepts/web3/../basics/accounts/introduction">found in the docs</a>.
But an account by itself won’t get us anywhere, its <a href="https://docs.near.org/concepts/web3/../basics/transactions/overview">transactions</a> that make things happen. In NEAR, we have only one transaction type, but the transaction itself may have different actions included. For most practical purposes, transactions will have a single action included, so for simplicity we’ll use “action” and “transaction” terms interchangeably further down the road. Each transaction always has sender and receiver accounts (and it is cryptographically signed by the sender’s key). The following transaction (action) types are supported:</li>
<li>CreateAccount/DeleteAccount, AddKey/DeleteKey - accounts and key management transactions.</li>
<li>Transfer - send NEAR tokens from one account to another. The basic command of any blockchain.</li>
<li>Stake - needed to become a validator in a Proof-of-Stake blockchain network. We won’t touch this topic in this guideline, more information <a href="https://docs.near.org/docs/develop/node/validator/staking-and-delegation">can be found here</a>.</li>
<li>DeployContract - deploy a smart contract to a given account. An important thing to remember - one account can hold only one contract, so the contract is uniquely identified by the account name. If we issue this transaction to an account which already has a deployed contract, a contract update will be triggered.</li>
<li>FunctionCall - the most important action on the blockchain, it allows us to call a function of a smart contract.
Smart Contracts on NEAR are written in Rust, and compiled into <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">WebAssembly</a> (technically, <a href="https://www.assemblyscript.org/">AssemblyScript</a> is also supported, but it’s not yet production ready). Each contract has one or more methods that can be called via a FunctionCall transaction. Methods may have arguments provided, so each smart contract call includes the following payload: account id, method name, and arguments.
There are 2 ways to call a method on a smart contract:</li>
</ul>
<ol>
<li>Issue a FunctionCall transaction. This will create a new transaction on a blockchain which may modify a contract state.</li>
<li>Make a smart contract view call. NEAR blockchain <a href="https://near-nodes.io/intro/node-types#rpc-node">RPC nodes</a> provide a special API that allow execution of methods that do not modify contract state (readonly methods).
The second method should always be used whenever possible since it doesn’t incur any transaction cost (of course, there is some cost of running a node, but it’s still much cheaper than a transaction; public nodes are available which can be used free of charge). Also, since there’s no transactions, we don’t need an account to make a view call, which is quite useful for building client-side applications</li>
</ol>
<p><a href="https://docs.near.org/concepts/web3/near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Gas and Storage?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>As we already discussed, users should pay computational costs for each transaction. This cost is called “gas” and is measured in <a href="https://docs.near.org/concepts/web3/../basics/transactions/gas">gas units</a> (this is an established term in the blockchain world). Each time a transaction is posted, an amount of gas is attached to it to cover the cost. For simple transactions, gas can be calculated ahead of time to attach an exact amount. For FunctionCall transactions, however, exact cost is impossible to automatically calculate beforehand, so the usual approach is to attach a large enough amount of gas to cover the cost, and any excess will get automatically refunded.
<img src="https://docs.near.org/docs/assets/web3/web3-7.png" alt="image"></p>
<p>But why do we need separate gas units, why not just pay directly with NEAR tokens? It’s necessary to accommodate for changing infrastructure costs - as the network evolves over time, cost of gas units may change, but the amount of gas required for a transaction will remain constant.
However, computational cost is not everything - most smart contracts also need storage. The storage cost in NEAR is quite different from gas.
First of all, it’s not cheap - while gas is very cheap and its cost will be almost unnoticeable by the users, storage is very expensive. As a consequence, the storage budget should be carefully calculated and only necessary data stored on the blockchain. Any auxiliary data (that is not necessary to the contract operations) should be stored off-chain (possible solutions will be covered in later chapters).
The second important difference - storage is not bought, but leased (in NEAR, it’s called staking). When a smart contract wants to store some data, storage cost is computed and the appropriate amount of NEAR tokens is “locked” on the account. When data is removed, tokens are unlocked. And unlike gas, these tokens are locked on the smart contract’s account, so the user doesn’t directly pay for it.
But what if we want users to pay for the storage (or just pay some fee for using a smart contract)? So far, the only way we’ve seen to transfer a token is a Transfer transaction. It turns out, a FunctionCall transaction also allows us to transfer tokens alongside the call (this is called a deposit). Smart Contracts can verify that an appropriate amount of tokens has been attached, and refuse to perform any actions if there’s not enough (and refund any excess of tokens attached).
In combination, gas fee and deposit attachments enable creation of contracts that need zero cost from developers to support and can live on blockchain forever. Even more, 30% of gas fees spent on the contract execution will go to a contract’s account iself (read more <a href="https://near.org/blog/near-protocol-economics/#:~:text=a%20new%20entity.-,Contract%20rewards,-As%20one%20of">here</a>), so just by being used it will bring some income. To be fair, due to the cheap gas cost this will make a significant impact only for most popular and often-called contracts, but it’s nice to have such an option nonetheless.
One last gotcha about storage - remember that smart contracts themselves are also just a code stored on a blockchain, so a DeployContract transaction will also incur storage fees. Since smart contracts code can be quite big, it’s important to optimize their size. A few tips on this:</p>
<ul>
<li>Don’t build Rust code on Windows, it produces quite big output. Use WSL or build on other OSes.</li>
<li>Optimize smart contracts code for size - <a href="https://www.near-sdk.io/reducing-contract-size/examples">more info here</a>.
More details on the storage model can be <a href="https://docs.near.org/concepts/web3/../storage/storage-staking">found in the docs</a>.</li>
</ul>
<p><a href="https://docs.near.org/concepts/web3/near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Clients Integration?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>So far, we’ve discussed how to call smart contracts in a client-agnostic way. However, in the real world, calls we’ll be performed from a client side - like web, mobile or a desktop application.
As we’ve learned from previous chapters, each transaction should be signed using a key. And since keys are managed by a wallet, each application should integrate with it. At the time of this writing, there’s only one officially supported <a href="https://wallet.near.org/">NEAR Wallet</a>. It is a web application, so integration happens using HTTP redirects. This is relatively straightforward to do in web applications (JavaScript SDK is available), but for mobile or desktop applications it may require deep linking or other more advanced approaches.
The general flow for transactions signing looks like this:
<img src="https://docs.near.org/docs/assets/web3/web3-9.png" alt="image"></p>
<p>Each time we want to post a transaction, the client redirects the user to a wallet, where the transaction is approved and wallet returns a signed transaction back to the client (via redirect). This is a quite secure way of signing, since the private key is not exposed to the client, but constant redirects might quickly get annoying for users, especially if we just want to call smart contract functions that incur only small gas fees. That’s why NEAR introduced <a href="https://docs.near.org/concepts/basics/accounts/access-keys">two types of access keys</a> - full keys and functional call keys. Full access keys, as the name implies, can be used to sign any types of transactions. Functional call keys, on the other hand, aim to solve this UX problem. They are tied to a specific contract, and have a budget for gas fees. Such a key can’t be used to sign transactions that transfers NEAR tokens (payable transactions), and can only be used to cover gas fees, that’s why it’s not so security-critical and can be stored on the client. Because of this, we can create a simplified signing flow for non-payable transactions. First of all, a login flow to obtain a Functional Call key is used.
<img src="/docs/assets/web3/web3-10.png" alt="image">
The client generates a new key pair and asks a wallet to add it as a functional call key for a given contract. After this, a login session is established and considered alive until the client has the generated key pair.
To provide the best user experience usage of both keys is combined - type of signing is determined based on a transaction type (payable or non-payable). In case of a payable transaction, flow with wallet redirection is used, otherwise simplified local signing flow (using a stored function call key) is applied:
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/web3-11.png&quot; alt=&quot;image&quot; width=&quot;300&quot; /&gt;
&lt;/div&gt;
It’s important to note that it’s possible to generate a Full Access key using the same key addition flow as for the Functional Call key, but this is very dangerous since compromise of such key will give full control over an account. Applications that want to work with Full Key directly should be designed with extreme care, especially in the matters of security.</p>
<p><a href="https://docs.near.org/concepts/web3/near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Cross-contracts calls?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Throughout this section, we’ve discussed how to call a smart contract from a client. But a single smart contract can only take us so far. The true power is achieved when smart contracts are working in concert and communicating with each other. To achieve this, NEAR provides cross-contract calls functionality, which allows one contract to call methods from another contract. The general flow looks like this:
<img src="https://docs.near.org/docs/assets/web3/web3-12.png" alt="image"></p>
<p>Looks simple enough, but there are few gotchas:</p>
<ul>
<li>In order to provide a call status (success or failure) and a return value to the calling contract, a callback method should be called, so there’s no single activation of ContractA. Instead, an entry method is called first by the user, and then a callback is invoked in response to cross-contract call completion.</li>
<li>Transaction status is determined by the success or failure of a first method call. For example, if a ContractB.methodB or ContractA.methodACb call fails, the transaction will still be considered successful. This means that to ensure proper rollbacks in case of expected failures, custom rollback code must be written in the ContractA.methodACb, and the callback method itself must not fail at all. Otherwise, smart contract state might be left inconsistent.</li>
<li>Cross-contract calls must have gas attached by the calling contract. Total available gas is attached to a transaction by a calling user, and distributed inside the call chain by contracts. For example, if 15TGas are attached by the user, ContractA may reserve 5TGas for itself and pass the rest to ContractB. All unspent gas will be refunded back to the user.
<img src="/docs/assets/web3/web3-13.png" alt="image"></li>
<li>NEAR tokens can also be attached to cross contract calls, but they work differently from the gas. Attached deposit is taken directly from the predecessor account. It means even if a user hasn’t attached any deposit, a contract still can attach tokens, which will be taken from its account. Also, since cross-contract call failure doesn’t mean transaction failure, there are no automatic refunds. All refunds should be done explicitly in the rollback code.
<img src="/docs/assets/web3/web3-14.png" alt="image"></li>
</ul>
<p>A few notes on failure modes - since smart contracts run on a decentralized environment, which means they are executed on multiple machines and there is no single point of failure, they won’t fail because of environmental issues (e.g. because a machine suddenly lost power or network connectivity). The only possible failures come from the code itself, so they can be predicted and proper failover code added.
In general, cross-contract call graphs can be quite complex (one contract may call multiple contracts and even perform some conditional calls selection). The only limiting factor is the amount of gas attached, and there is a hard cap defined by the network of how many gas transactions may have (this is necessary to prevent any kind of DoS attacks on the Network and keep contracts complexity within reasonable bounds).</p>
<p><a href="https://docs.near.org/concepts/web3/near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Data Structures, Indexers and Events?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>We’ve already discussed the storage model on NEAR, but only in abstract terms, without bringing the exact structure, so it’s time to dive a bit deeper.
Natively, NEAR smart contracts store data as key-value pairs. This is quite limiting, since even simplest applications usually need more advanced data structures. To help in development, NEAR provides <a href="https://github.com/near/near-sdk-rs">SDK for smart contracts</a>, which includes data structures <a href="https://docs.near.org/concepts/storage/data-collections#rust-collection-types-rust-collection-types">like vectors, sets and maps</a>. While they are very useful, it’s important to remember a few things about them:</p>
<ul>
<li>Ultimately, they are stored as binary values, which means it takes some gas to serialize and deserialize them. Also, different operations cost different amounts of gas (<a href="https://docs.near.org/concepts/storage/data-collections#big-o-notation-big-o-notation-1">complexity table</a>). Because of this, careful choice of data structures is very important. Moving to a different data structure later will not be easy and would probably require data migration.</li>
<li>While very useful, vectors, maps and sets won’t match the flexibility and power of classical relational databases. Even implementations of simple filtering and searching might be quite complex and require a lot of gas to execute, especially if multiple entities with relations between them are involved.</li>
<li>They are limited to a single contract. If data from multiple contracts is required, aggregation should be performed using cross-contract calls or on a client side, which is quite expensive in terms of gas and time.
To support more complex data retrieval scenarios, smart contract data should be put in a more appropriate store, like a relational database. <a href="https://docs.near.org/tools/indexer4explorer">Indexers</a> are used to achieve this. In a nutshell, indexer is just a special kind of blockchain node that processes incoming transactions and puts relevant data into a database. Collected data can be exposed to a client using a simple API server (e.g. REST or GraphQL).
<img src="https://docs.near.org/docs/assets/web3/web3-15.png" alt="image"></li>
</ul>
<p>In order to simplify creation of indexers, <a href="https://near-indexers.io/docs/projects/near-indexer-framework">NEAR Indexer Framework</a> has been created. However, even with a framework available, extracting data from a transaction may not be an easy task, since each smart contract has its unique structure and data storage model. To simplify this process, smart contracts can write structured information about outcome into the logs  (e.g. in the JSON format). Each smart contract can use its own format for such logs, but the general format has been standardized as <a href="https://nomicon.io/Standards/EventsFormat">Events</a>.
Such architecture is very similar to Event Sourcing, where blockchain stores events (transactions), and they are materialized to a relational database using an indexer. This means the same drawbacks also apply. For instance, a client should be designed to accommodate indexing delay, which may take a few seconds.
As an alternative to building your own indexer with a database and an API server, <a href="https://thegraph.com/en/">The Graph</a> can be used instead, which currently has <a href="https://thegraph.com/docs/en/supported-networks/near/">NEAR support in beta</a>. It works using the Indexer-as-a-Service model, and even has decentralized indexing implementation.</p>
<p><a href="https://docs.near.org/concepts/web3/near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Development tools?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>By now, we should be familiar with necessary concepts to start developing WEB 3.0 applications, so let’s explore the development tools available.
First of all, we need a development and testing environment. Of course, we could theoraticaly perform development and testing on the main blockchain network, but this would not be cheap. For this reason, NEAR provides <a href="https://docs.near.org/concepts/basics/networks">several networks</a> that can be used during development:</p>
<ul>
<li>testnet - public NEAR network which is identical to mainnet and can be used for free.</li>
<li>localnet - you can deploy your personal NEAR network on your own environment. Because it’s owned by you, data and code can be kept private during development. More info on how you can run your own node can be <a href="https://docs.near.org/docs/develop/node/validator/running-a-node">found here</a>. Alternatively, you can bootstrap an entire testing infrastructure in Docker on your local machine using Kurtosis - <a href="https://docs.near.org/concepts/web3/develop/testing/kurtosis-localnet">guide is here</a>.</li>
<li>workspaces - you can start your own local network to perform e2e testing. More info <a href="https://docs.near.org/develop/testing/integration">here</a>.
Once we’ve chosen a network to use, we need a way to interact with it. Of course, transactions can be constructed manually and posted into <a href="https://docs.near.org/api/rpc/setup">node’s API</a>. But <a href="https://github.com/near-examples/transaction-examples">this is tedious</a> and isn’t fun at all. That’s why, NEAR <a href="https://docs.near.org/tools/near-cli">provides a CLI</a> which automates all of the necessary actions. It can be used locally for development purposes or on build machines for CI/CD scenarios.
In order to manage accounts on the NEAR network, <a href="https://wiki.near.org/getting-started/creating-a-near-wallet">Wallet</a> can be used. It can show an effective account balance and active keys.
<img src="https://docs.near.org/docs/assets/web3/web3-16.png" alt="image">
On the image above, “Reserved for storage” are tokens locked by a smart contract to cover current storage requirements, and “Reserved for transactions” represents the amount of tokens locked to cover gas cost by Functional Call keys.
Currently, there’s no UI to connect sub-accounts into a wallet. Instead, they should be imported via a specially constructed direct link:</li>
</ul>
<pre><code>https://wallet.testnet.near.org/auto-import-secret-key#YOUR_ACCOUNT_ID/YOUR_PRIVATE_KEY
</code></pre>
<p>(you should provide a private key of a full access key for the account in question, so make sure this link is used securely).
Last, but not least, blockchain transactions can be viewed using NEAR Explorer. It provides insights into transaction execution and outcome. Let’s look at <a href="https://explorer.testnet.near.org/transactions/ABh4zQ5aZ3CGhpQzstL16TAB8TvqPbiirJG1uTPJVxTt">one example</a>.
First of all, we can see general transaction information - sender, receiver, status. After this, we can see gas usage information:</p>
<ul>
<li>Attached gas - total gas provided for the transaction.</li>
<li>Gas used - actual gas spend.</li>
<li>Transaction fee - gas used multiplied to current gas price, shows an actual cost of a transaction in NEAR tokens.
Also, Deposit Value shows the amount of NEAR tokens transferred from sender to receiver.
<img src="/docs/assets/web3/web3-17.png" alt="image">
Below this, we can inspect transaction actions (recall, that transactions may have multiple actions). In this case, we have a single FunctionCall action with arguments:
<img src="/docs/assets/web3/web3-18.png" alt="image">
At the end, transaction execution details, including token transfers, logs, cross-contract calls and gas refunds are provided. One thing that we haven’t covered yet is shown here - <a href="https://docs.near.org/concepts/web3/../basics/transactions/overview#receipt-receipt">receipts</a>. For most practical purposes they are just a transaction implementation detail. They are quite useful in a transaction explorer to understand how a transaction was executed, but aren’t really relevant outside of it.
<img src="/docs/assets/web3/web3-19.png" alt="image"></li>
</ul>
<p><a href="https://docs.near.org/concepts/web3/near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Contract upgrades?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>During the development, and sometimes even in production, updates to a contract’s code (or even data) are needed. That’s why different contract upgrades mechanisms have been created.
During the local development, we can just recreate a smart contract’s account each time we deploy a contract (<a href="https://docs.near.org/tools/near-cli#near-dev-deploy-near-dev-deploy">dev-deploy</a> command in NEAR CLI exists for this). With such an approach, contract data will be purged each time a contract is redeployed. More info <a href="https://www.near-sdk.io/upgrading/prototyping">here</a>.</p>
<p>However, once we move to a more stable environment, like testing or production, more sophisticated methods are needed. Redeployment of code is quite simple - we just issue another DeployContract transaction, and NEAR will handle the rest. The biggest challenge is to migrate contract state - <a href="https://www.near-sdk.io/upgrading/production-basics">several approaches are possible</a>, but all of them involve some kind of migration code.
But we can take our upgrade strategy one step further. In described strategies, developers are fully in control of code upgrades. This is fine for many applications, but it requires some level of trust between users and developers, since malicious changes could be made at any moment and without user’s consent (as it <a href="https://www.bleepingcomputer.com/news/security/dev-corrupts-npm-libs-colors-and-faker-breaking-thousands-of-apps/">sometimes happens</a> in npm world). To solve this, a contract update process itself can also be decentralized - this is called <a href="https://www.near-sdk.io/upgrading/via-dao-vote">DAO-Governed Updates</a>. Exact strategy may vary, but the basic idea is that contract update code is implemented in a smart contract itself, and a Full Access key to the contract account is removed from a blockchain (via DeleteKey transaction). In this way, an update strategy is transparent to everyone and cannot be changed by developers at will.</p>
<p><a href="https://docs.near.org/concepts/web3/near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Blockchain-Enabled Application Architecture?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>First of all, let’s outline a typical architecture of a Web 2 application. In most cases, a classic client-server model is used:
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-1.png&quot; alt=&quot;image&quot; width=&quot;150&quot; /&gt;
&lt;/div&gt;
In such architecture, we usually have 3 layers:</p>
<ul>
<li>Database - stores application’s data. This can be a single database, or several databases of different types, but this is mostly an implementation detail - for our purposes we can view it as a single logical database.</li>
<li>Server - a centralized web-server. It may be implemented using different architecture patterns (monolithic, microservices, serverless) and technologies, but again, we can consider it as a single logical server.</li>
<li>Client - client side application user directly interacts with. Different client types are possible: web, mobile or desktop. There is a difference between these clients in regards to blockchain integration, which we’ll discuss later.
Now, let’s compare it to a dApp architecture:
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-2.png&quot; alt=&quot;image&quot; width=&quot;400&quot; /&gt;
&lt;/div&gt;
We can notice that there is a common component in these architectures - the client application. This means we can use it as a junction point to connect them together.
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-3.png&quot; alt=&quot;image&quot; width=&quot;400&quot; /&gt;
&lt;/div&gt;
A keen reader may notice an additional connection between the Server and RPC Node. This is required because in a client-server architecture clients cannot be trusted. That’s why every action performed from the client should be validated by a backend server. But in our case everything is complicated by the fact that we essentially have two backends: Web 2 server and a smart contract, so two possible validation flows are possible:</li>
<li>Client performs an action on a server, which involves blockchain data. In this case the server should talk to the blockchain and verify that valid data is provided.</li>
<li>Client performs an action on a smart contract, which involves server-owned data. Since the smart contract can’t talk to the server directly to verify it, we should use a different way to verify the authenticity of the data. In blockchain terminology, such a server is called an <a href="https://en.wikipedia.org/wiki/Blockchain_oracle">Oracle</a>.
We’ll explore how to implement both of these approaches later.
By now, we've reached the point where the type of our client begins to matter. Specifically, problems arise from the dApps payment model - user’s pay for the blockchain infrastructure using gas, so money goes directly to infrastructure providers. Also, users make payments directly on the blockchain, without using any intermediaries, like banks or payment services. This approach is at odds with mobile app stores (Google Play Store and Apple App Store) - they don’t allow any payments on their respective mobile platforms without their cut. Although some shifts in policy are starting to happen (e.g. <a href="https://en.wikipedia.org/wiki/Epic_Games_v._Apple">Apple vs Epic Games duel</a>), at the time of this writing getting blockchain-enabled applications into the stores will probably get vetoed by reviewers. There are some ways to bypass these limitations, e.g. by not using Play Store on Android, but all of these ways are either sub-par in terms of usability or involve some risk of getting banned by stores. That’s why for mobile applications an alternative approach is needed.
Sometimes, to move forward we need to take a step back. In our case, to solve a problem with mobile clients we can return to our initial concept of having two clients - one for blockchain integration, and another one for Web 2 server. Blockchain client can be a usual web application, which isn’t subject to any constraints from stores. It can also serve as a connection point between blockchain and our existing application.
<img src="https://docs.near.org/docs/assets/web3/nfts-4.png" alt="image">
In this architecture the mobile client is still allowed to talk to the blockchain, but only in a read-only way, which doesn’t require wallet connection or any payments. All actions on the blockchain happen on the Web Client instead.
Further in this guide we’ll use such dual-client architecture, since simpler architecture with a single client can be directly derived from it by merging two clients together.
At this point, our architecture covers almost everything we need to start building our application. However, since we want to build a user-owned economy, we need a marketplace where it’ll happen. An obvious choice is to put this marketplace into the web client, but there’s one gotcha. If we recall the smart contract’s storage model, it’s not suitable to serve complex data queries, so an indexer should be used to aggregate data from blockchain into a proper database.
<img src="/docs/assets/web3/nfts-5.png" alt="image">
By now, every building-block is in place and we can start exploring how to implement this architecture in practice.</li>
</ul>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the NFTs in Web 2 Applications?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order to implement a fully functional application using a hybrid Web 2 - Web 3 architecture, a lot of technological challenges have to be addressed, like authentication and authorization, seamless NFTs usage in client and server, and proper NFT storage model. In the following sections we’ll take a closer look at this and describe common patterns and approaches.</p>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Authentication and Authorization?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Since our digital assets are represented as NFTs on blockchain, in order to use them in our Web 2 application, a server needs a way to authorize their usage. The basic idea is pretty simple - it can just read data from blockchain by calling a smart contract method and check an owner’s account id. For such flow, we have 3 actors:</p>
<ul>
<li>Client that wants to use some digital asset (NFT).</li>
<li>Smart Contract for NFTs. Should be implemented according to <a href="https://nomicon.io/Standards/NonFungibleToken/">NEAR NFT standards</a>.</li>
<li>Server that verifies ownership of NFT and uses it in its internal logic.
A general flow looks like this:
<img src="https://docs.near.org/docs/assets/web3/nfts-6.png" alt="image">
However, such an authorization process cannot be performed without authentication, so the server also needs a way to authenticate a user.
Recall that the user's identity on a blockchain is represented by a key pair. However, since in NEAR a user may have multiple key pairs and an account is a separate entity, the authentication procedure is a bit more complicated.
To authenticate our requests, we can use public-key cryptography - a client can sign a request using a user’s private key, and then a server can verify the signature and key ownership. A typical request with authentication may look like this:</li>
</ul>
<pre><code class="language-javascript">{
	&quot;payload&quot;: { /* request-specific payload */ },
	&quot;accountId&quot;: &quot;account.near&quot;,
	&quot;publicKey&quot;: &quot;...&quot;,
	&quot;timestamp&quot;: 1647091283342,
	&quot;signature&quot;: &quot;...&quot;
}
</code></pre>
<p>where:</p>
<ul>
<li><code>accountId</code> – user’s account id on NEAR.</li>
<li><code>publicKey</code> - public key of the key pair used for signature, must be either Functional or Full access key for the provided account.</li>
<li><code>timestamp</code> - current datetime, must be verified on server. It’s needed to prevent <a href="https://en.wikipedia.org/wiki/Replay_attack">replay attacks</a>. Alternative to timestamps is usage of <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a>, but it’s more complicated.</li>
<li><code>signature</code> - signature of the request payload and other fields. Usually, a payload is hashed beforehand.
Depending on the implementation, request body, headers, or other side channels can be used to transfer authentication data - exact implementation depends on used technologies and protocols.
Server can use this data to authenticate a request using the following approach:
<img src="/docs/assets/web3/nfts-7.png" alt="image">
3 authentication steps are performed on the server:</li>
</ul>
<ol>
<li>Signature verification - if the signature is correct, we are sure that the client really has the private key for the provided public key. Also, this proves that request data hasn't been modified in transit.</li>
<li>Timestamp verification - prevents replay attacks. Server can verify that the request’s timestamp is not too old (e.g. has been created no more than 10 seconds ago).</li>
<li>Public key ownership verification - by calling <a href="https://docs.near.org/api/rpc/access-keys">view_access_key method</a>, we can make sure that the provided public key is really associated with the provided account.
Such authentication approach is the simplest one, but has a few major drawbacks:</li>
</ol>
<ul>
<li>Performing a REST API call to RPC Node is quite expensive to do each time from the performance perspective.</li>
<li>We can’t sign requests from the mobile client, since it usually should be disconnected from the blockchain due to store policies, and hence doesn’t have a key pair.</li>
<li>A NEAR account is required in order to start using the application, which complicates the onboarding process.
To solve the first problem, we can simply issue a JWT token or authenticate connection in some other way after a successful NEAR account authentication, so the it will serve as “login” of sorts:
<img src="/docs/assets/web3/nfts-8.png" alt="image">
While this may be enough for some applications, it doesn’t address the last 2 problems. In order to solve all of them, we can use a hybrid authentication approach with 2 accounts:</li>
</ul>
<ol>
<li>“Classic” Web 2 account - all clients can use this account to call a server. For example, this can be a simple username/password or OAuth 2 login with a JWT token.</li>
<li>NEAR account - can be used from non-mobile clients only. Instead of performing NEAR account auth each time we need to use it, we can do it a single time in order to “connect” this account to our primary Web 2 account and store Classic-NEAR account connection in our server database. In this way we solve all problems - server doesn’t need to authenticate NEAR account each time it wants to perform an authorization, instead it can read an associated NEAR account from its own database.
With such hybrid approach, different authentication methods are used for blockchain and server:
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-9.png&quot; alt=&quot;image&quot; width=&quot;400&quot; /&gt;
&lt;/div&gt;
NEAR account connection sequence can be implemented in a very similar way to the already described NEAR authentication method, where at the end we store an authenticated account in our database:
<img src="/docs/assets/web3/nfts-10.png" alt="image">
There’s one more improvement we can make to this flow. Since a Web Client uses both accounts, a user is forced to login using both Web 2 login method (e.g. login/password) and NEAR Wallet. This is not ideal from the UX perspective, so we can simplify it by introducing a “Login with Wallet” method to our server, which would work when a user already has a wallet connected. We can do this in a similar way to the account connection flow:
<img src="/docs/assets/web3/nfts-11.png" alt="image">
Now, as we’ve discussed possible approaches for authentication, let’s summarize it as an overall login flow for our clients:
<img src="/docs/assets/web3/nfts-12.png" alt="image">
Of course, this is just one possible flow, and a different solution can be assembled from described building blocks. The most important considerations for choosing right authentication flow are following:</li>
</ol>
<ul>
<li>Type of your client - for web/desktop clients, or sideloaded Android clients, it’s possible to use Wallet as a single authentication method. For mobile clients installed from a store, a hybrid approach with multiple auth methods should be used.</li>
<li>Target audience - if you target regular users that are not familiar with blockchain technologies, having a hybrid auth method to simplify onboarding might be better than forcing users to learn blockchain before trying your application.</li>
</ul>
<h4>Blockchain Auth &amp; Auth</h4>
<p>So far, we’ve discussed authentication and authorization on the Web 2 server’s side. But what about Web 3 smart contracts? Everything is much more straightforward in this case.
Since everything is public data on the blockchain, we don’t need any authentication for read calls. For transactions, each is signed by an account’s private key, and authentication is performed by the network. More details on transaction signing can be found <a href="https://docs.near.org/concepts/web3/../basics/transactions/overview">in the docs</a>.
Authorization, on the other hand, must be performed on a smart contract itself, the simplest way is just to check whether caller is allowed to perform an action:</p>
<pre><code class="language-rust">assert_eq!(
            env::predecessor_account_id(),
            self.tokens.owner_id,
            &quot;Unauthorized&quot;
        );
</code></pre>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the NFT usage?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>After we’ve learned how to authenticate users and how to authorize NFTs usage, let’s find out how we can actually use them in our application.
Since we essentially have two backends in our application - server and smart contract(s), they both can use NFTs for different purposes:</p>
<ul>
<li>Server usually uses NFTs for actual functional purposes, e.g. by treating NFT as an in-game character, it can read its properties and stats and apply them using some logic.</li>
<li>Smart contract is responsible for NFTs ownership, as well as NFTs creation, modification and burning (destruction).
This is the point where the NFT data storage model comes into place. Let’s recall, that there are 3 possible options:</li>
</ul>
<ol>
<li>Store data in a smart-contract (on-chain).</li>
<li>Store data in an <a href="https://docs.near.org/concepts/storage/decentralized-storage">off-chain decentralized storage</a>, like IPFS (off-chain).</li>
<li>Store data in an application itself (in-application).
First 2 approaches provide good decentralization, but make NFT harder to work with, especially if we need to modify its properties. Let’s consider usage options depending on a storage model used:</li>
<li>On-chain storage:
<ul>
<li>Server can read data from the blockchain by making an API call. Server can’t directly modify data, it should make a smart contract call instead (by issuing a transaction).</li>
<li>Smart contract can directly read/modify NFT data.</li>
<li>Clients can read all data directly from the blockchain.</li>
</ul>
</li>
<li>Off-chain storage:
<ul>
<li>Server can read data from storage by making an API call. Data on the off-chain storage is usually immutable, so no modifications are possible.</li>
<li>Smart contract cannot read data directly, an Oracle should be used. Data cannot be modified from it.</li>
<li>Clients should read data from both blockchain and off-chain storage.</li>
</ul>
</li>
<li>In-application storage:
<ul>
<li>Server can read/modify data from its own database.</li>
<li>Smart contract cannot read data directly, an Oracle should be used. Data cannot be modified from it.</li>
<li>Clients should read data from both blockchain and server.
Depending on a particular use case, any approach, or combination of them, can be used. The simplest case is when we don’t have any dynamic NFT data, and we can easily divide data by domains:</li>
</ul>
</li>
</ol>
<ul>
<li>Data that is used by smart contracts is stored on-chain.</li>
<li>Other data is stored either off-chain or in-application.
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-13.png&quot; alt=&quot;image&quot; width=&quot;400&quot; /&gt;
&lt;/div&gt;
In this approach the server needs to read data from the smart contract, and, optionally, from an off-chain storage (like IPFS or Database).
This will work well for simple use cases, but everything becomes more complicated if we need to have some dynamic data associated with NFTs. E.g we may want to have experience points associated with our game character. Such data can be stored either on-chain or in-application (off-chain storage is also possible, but it’s more involved, so we won’t discuss it here).
In case of in-application storage, data can be modified by a server without any problems, but there are few drawbacks:</li>
<li>In order to read this data, clients should make an API call to the server. This adds a centralized point for our NFT, and may not be suitable for all applications.</li>
<li>If a smart contract requires this data, a server should serve as a <a href="https://en.wikipedia.org/wiki/Blockchain_oracle">Blockchain Oracle</a>, which complicates things.
If we want our server to serve as an oracle for our smart contract, the easiest way is to cryptographically sign server’s data and verify it on the contract’s side (server’s public key that was used for signing should be stored in a contract in this case).
In order to prevent replay attacks, signed data should include a timestamp, which should also be verified. However, there’s on trick to this - smart contracts can’t access current time, since it would make them non-deterministic. Instead, transaction signature time can be used - it can be accessed using <code>env::block_timestamp()</code> function.
<img src="https://docs.near.org/docs/assets/web3/nfts-14.png" alt="image">
In order to avoid all these complications, we can instead store dynamic data on-chain, and use smart contract calls to update it.
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-15.png&quot; alt=&quot;image&quot; width=&quot;500&quot; /&gt;
&lt;/div&gt;
Such an approach has one drawback - in order to call a smart contract’s method, a transaction should be created by the server, and in order to create a transaction it must be signed using an account’s key. That’s why a separate NEAR account should be created to be used by the server. Actions on the smart contract can be configured to authorize only this account, so regular users will be disallowed from modifying such data.
Yet another option is to store data on the server-side, but a smart contract can authorize only a server account for calls that rely on this data. As with the previous scenario, the server must have its own NEAR account.
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-16.png&quot; alt=&quot;image&quot; width=&quot;500&quot; /&gt;
&lt;/div&gt;
In general, the approach of storing dynamic data on the Smart Contract side is much easier, but an important constraint should be considered - storing data on the blockchain is not cheap, so an appropriate method can be chosen depending on a scenario.
By now, we’ve covered methods to store and interact with NFTs from our application, an exact strategy should be chosen depending on use cases and constraints. A few things to remember:</li>
<li>Storing NFTs data in a centralized storage (like an application's database) goes against Web 3 philosophy, and should be used sparingly and with care.</li>
<li>Storage on the blockchain is not cheap, so decentralized off-chain storages can be used to store large data.</li>
<li>Storing and using dynamic NFT data is quite tricky, and should be carefully designed. If such dynamic data is needed by smart contracts, it’s better to store it inside this contract if possible.</li>
</ul>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the NFT minting?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>So far, we’ve discussed only how to use NFTs in the application, but how do they get created?
In the blockchain world, creation of new NFTs is usually called minting. And as with traditional digital assets, there are few ways how to create them:</p>
<ul>
<li>Users can mint them directly. This can be done by either allowing creation of NFTs from scratch, or by using more complex processes, like breeding or upgrading. The most famous example of such process is breeding in <a href="https://www.cryptokitties.co/">CrytoKitties</a> game - new NFTs are created by combining existing ones. With this approach users usually have to pay to cover the storage and gas cost of NFTs creation.</li>
<li>NFTs can be distributed by the developer to a set of users - it is usually called <a href="https://www.investopedia.com/terms/a/airdrop-cryptocurrency.asp">NFTs airdrop</a>. Most often this is used as a marketing strategy to kickstart NFTs usage in applications. Storage and gas costs in this case are covered by developers.</li>
<li>NFTs can be bought on a market or obtained from the lootbox. Depending on an exact strategy, costs can either be paid by a user or by developer. Also, in this case NFTs sometimes can be minted on-demand, to avoid paying upfront costs.
An exact strategy used for NFTs minting depends on application use cases. However, almost always there’ll be an <code>nft_mint _function</code> defined in a smart contract, which will handle creation of new tokens. This function itself isn't defined <a href="https://nomicon.io/Standards/NonFungibleToken/">in the standard</a> and is up to the application to implement, but the standard library provides a core implementation for it - <a href="https://docs.rs/near-contract-standards/latest/near_contract_standards/non_fungible_token/core/struct.NonFungibleToken.html#method.internal_mint">mint_internal</a>. On top of this function an additional logic, e.g. for authorization, can be added:</li>
</ul>
<pre><code class="language-rust">#[payable]
pub fn nft_mint(
    &amp;mut self,
    token_id: TokenId,
    receiver_id: AccountId,
    token_metadata: TokenMetadata,
) -&gt; Token {
    assert_eq!(
        env::predecessor_account_id(),
        self.tokens.owner_id,
        &quot;Unauthorized&quot;
    );
    let token = self
        .tokens
        .internal_mint(token_id, receiver_id, Some(token_metadata));
    return token;
}
</code></pre>
<p>This approach is quite simple, but everything becomes a bit complicated if we want to provide some on-demand minting functionality to avoid paying upfront costs. For example, we may want to create a lootbox with a set of predefined items appearing with some probability.
One approach is to handle this logic on a server side, in this case the server will call <code>nft_mint</code> function with computed parameters. However, in this case developers will have to pay the cost of minting. If we want to avoid this, loot box logic can be moved into the smart contract itself. If users want to open a loot box, he can call a smart contract function and pay for this action (e.g. by using NEAR or Fungible Tokens). Developers would only need to pay for a lootbox configuration costs, like possible items and their probabilities.</p>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Blockchain Onboarding?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Before designing an onboarding strategy, the target audience should be carefully analyzed. As we briefly mentioned before, users can be divided into two broad buckets:</p>
<ol>
<li>Users that are already familiar with blockchain, have their own wallets and understand cryptocurrency basics.</li>
<li>“Casual” users that aren’t familiar with blockchain and don’t know much about it.
If only the first category is targeted, then everything is quite simple - users are already familiar with main concepts, and will have no problem connecting their own wallet or creating a new one. However, if we want to target the second category of users as well, a strategy has to be developed to make onboarding into the blockchain world as smooth as possible. While a lot relies on proper UX and is very application-specific, a few architectural patterns and technologies exist to simplify this process: custodial wallets, NEAR drops, Prepaid Gas and Implicit Accounts.
<a href="https://www.coindesk.com/learn/custodial-wallets-vs-non-custodial-crypto-wallets/">Custodial Wallet</a> is a wallet which is managed by a third party. In our case, a wallet can be created and stored on a server side, and all blockchain operations could be done using the server as a proxy.
<img src="https://docs.near.org/docs/assets/web3/nfts-17.png" alt="image">
In this way, users can remain unaware about the intricacies of blockchain until they are comfortable enough to claim ownership of this account. Once they are ready, the server can transfer the account's ownership and remove it from the server. However, despite simplifying UX for the users, such approach has a few significant drawbacks:</li>
</ol>
<ul>
<li>Users should trust our application to manage their accounts.</li>
<li>Accounts creation is not free, so unless developers want to pay for it, funds should be transferred from a user to cover this cost. Traditional payment methods can be used, like PayPal or Apple/Google Pay. However, such an approach should be used with care for mobile applications due to app stores policies. Alternatively, NEAR Implicit Accounts can be used to avoid paying for account creation.</li>
<li>Unless we want to leave a custodial wallet as the only supported wallet type, we need to support both types of wallets (custodial and non-custodial) in our application. This will increase implementations complexity, since we need to support 2 transaction types:
<ul>
<li>Server-signed transactions in case of custodial wallet.</li>
<li>Client-signed transactions in case of non-custodial wallet.
As we mentioned above, <a href="https://docs.near.org/concepts/web3/../basics/accounts/account-id#implicit-accounts-implicit-accounts">Implicit Accounts</a> can be used to avoid paying account creation costs. This is especially useful for custodial wallets, since it allows us to create a NEAR Account free of charge. Basically, they work like an Ethereum/Bitcoin-style account by using a public key as an account id, and later can be converted to a full NEAR account. However, they have drawbacks as well. First of all, human-readable account names cannot be used. Also, if we want to convert it to a proper NEAR account, which can support Functional Call keys, the account creation fee still has to be paid.
While being very powerful, custodial accounts are quite complex and tricky to implement. An alternative approach to ease users onboarding is to simplify creation of a wallet itself. In NEAR, we can do this using <a href="https://near.org/blog/send-near-to-anyone-with-near-drops/">NEAR Drops</a>. It allows us to generate a link that guides users through a quick wallet creation process. However, the same problem as for the custodial accounts applies - creation of an account is not free. That’s why, such a link has NEAR tokens attached to it to cover account creation cost and to serve as an initial balance for a newly created wallet. And as with custodial accounts, funds should be transferred from a user to cover this cost using traditional payment channels.
Another option to simplify onboarding is usage of the <a href="https://docs.near.org/concepts/web3/../basics/transactions/gas#what-about-prepaid-gas-what-about-prepaid-gas">Prepaid Gas</a> concept. For example, we can issue a Functional Call key that allows users to interact with blockchain without having an account created. In this case funds will be drawn from the developer's account. This can be used for demo purposes, or to allow users without a NEAR account to perform some smart contract actions.</li>
</ul>
</li>
</ul>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the NFT Marketplace?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>At this point, we’ve covered in detail how to integrate NFTs into our Web 2 application, but we’ve stayed away from the economy part. The essential part for having a functioning economy is a marketplace where users can freely trade and exchange their NFTs. Such a marketplace usually consists of a smart contract and a client application. This smart contract is closely integrated with a NFT’s smart contract using the cross-contract calls. The reason for having a separate smart contract is two-fold:</p>
<ul>
<li>This provides a better separation of concerns - we can modify and upgrade our marketplace independently from the NFT contract.</li>
<li>Multiple marketplaces can be used - e.g. we can have an internal marketplace, and in addition to it users can list their NFTs on external marketplaces. This is possible because a common NFT standard exists that all marketplaces can rely on.
General flow of a simple marketplace integration can look like this:
<img src="https://docs.near.org/docs/assets/web3/nfts-18.png" alt="image"></li>
</ul>
<ol>
<li>Client calls the <a href="https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement#2-approval-with-cross-contract-call">nft_approve</a> method on the NFT smart contract. This will approve Marketplace Smart Contract to sell this NFT.</li>
<li>After approving an account, NFT smart contract issues a cross-contract call to the Marketplace to create a sale object. Arguments for this call are provided as part of the <code>nft_approve</code> call.</li>
<li>Another user wants to buy the NFT on sale, so he issues a call to the marketplace contract offering to buy it. An exact call signature for such action is not standardized and depends on marketplace implementation.</li>
<li>If an offer to buy a NFT is valid, Marketplace issues an <a href="https://nomicon.io/Standards/NonFungibleToken/Payout">nft_transfer_payout</a> call to transfer the NFT and return payout information. This information is used by the Marketplace to distribute profits from the sale between recipients. In the simplest case, all profits go to a seller.
Such flow looks relatively simple, but a few important details are missing.
First of all, in order to create a sale, storage needs to be paid for. Usually, the seller is the one who needs to pay for it, but other models are possible - e.g. marketplace or application developers could cover the cost. If we want users to pay for a sale, an approach with storage reservation can be used:</li>
</ol>
<ul>
<li>Before approving NFT for sale, a user should reserve storage on the Marketplace contract to cover sale storage requirements.</li>
<li>After the NFT is bought or delisted, the user can withdraw storage reservation (remember, that in NEAR storage staking model is used, so data can be deleted and locked tokens refunded).
While this model is relatively straightforward, it’s not ideal from the UX perspective - users must make a separate action to reserve storage if they want to sell their NFTs. To improve this, we can combine <code>nft_approve</code> call with storage reservation, and automatically refund back the storage cost after the sale is removed.
<img src="/docs/assets/web3/nfts-19.png" alt="image">
Another missing thing is how a client can read data about available sales. Of course, sales information can be read directly from a smart contract, but available data structures are not optimized for searching or filtering. Also, we would have to join data from the NFT and Marketplace contracts on the client side, which isn’t efficient. In order to solve these problems, an indexer can be used to aggregate data into a suitable database, where data can be stored in a way optimal for retrieval (e.g. a relational database or an ElasticSearch index can be used).
<img src="/docs/assets/web3/nfts-20.png" alt="image">
This is just one example of how a marketplace can be designed, but with it we’ve covered all basic concepts and problems. Most important points to remember:</li>
<li>It’s better to implement a marketplace as a separate contract.</li>
<li>Storage management should be carefully designed, with UX in mind.</li>
<li>In order to implement a proper searching/filtering functionality, a separate indexing service is needed.
An example of a simple marketplace <a href="https://docs.near.org/tutorials/nfts/8-marketplace">can be found here</a>. A more sophisticated marketplace may allow purchases with Fungible Tokens as payment.</li>
</ul>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Implementing Components?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Now, let’s explore our choice of libraries, frameworks and third-party solutions that can be used to implement our architecture.</p>
<h4>Client &amp; Server</h4>
<p>First of all, how can we interact with blockchain from our clients?
If we need read-level access only, we can simply use the <a href="https://docs.near.org/api/rpc/setup">REST API</a>, so it can be integrated into any language and technology without any problems. But everything becomes more complicated if we need to post transactions from a client. Remember, that transaction should be signed with a private key which is stored in a wallet:</p>
<ul>
<li>In case of a Functional Call key, it can be obtained from the wallet and used directly by the client.</li>
<li>In case of a Full Access key, the user should be redirected to the wallet to approve a transaction.
A <a href="https://docs.near.org/tools/near-api-js/quick-reference">JavaScript SDK</a> exists to cover all of these scenarios. It has all of the necessary functionality to integrate Web/Node.JS applications with blockchain. This SDK is a perfect choice for the Web-based clients, but it’s not suitable for desktop or mobile based clients. Other libraries can be used for them:</li>
<li><a href="https://github.com/good1101/NearClientApi/tree/master/NearClient">.NET Client</a> - suitable for Unity or Xamarin.</li>
<li><a href="https://github.com/near/near-api-swift">Swift</a></li>
<li><a href="https://github.com/near/near-api-py">Python</a></li>
<li><a href="https://github.com/near/near-api-unity">Unity</a>
Same SDKs and libraries can be used for servers. The only difference is that a server cannot interact with a Wallet, so it must have access to a Full Access key, which should be stored and accessed in a secure way.
Also, another solution is available if a server uses a technology that doesn’t have NEAR SDK available for - we can create a separate (micro)service using the Node.js, which would handle all blockchain interactions:
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-21.png&quot; alt=&quot;image&quot; width=&quot;450&quot; /&gt;
&lt;/div&gt;
An example of such a proxy server <a href="https://github.com/near-examples/near-api-rest-server">can be found here</a>.</li>
</ul>
<h4>Contracts</h4>
<p>As we discovered in a previous section, for our application we need two smart contracts: for NFT and for Marketplace. There are two options on how to get them - use in-house implementation or some third-party/SAAS solution. Both options are viable and have different pros/cons.
If we want to create our own contract, we are fully in control and can implement anything we want. An obvious drawback, of course, is that it will take time and money to build it. Third-party solutions, on the other hand, are limited in their functionality and often cannot be easily extended. Also, they usually have some upfront costs and/or usage fees.
For an in-house NFT contract implementation a few resources can be used as a starting point. First of all, a <a href="https://docs.rs/near-contract-standards/latest/near_contract_standards/index.html">Rust library</a> is available which implements most of the standard. Another option is to build an entire contract from scratch, a good guide on how to do this is available by <a href="https://docs.near.org/tutorials/nfts/0-intro">this link</a>.
Implementing an own Marketplace contract is more involved since there is no standard implementation. A few examples:</p>
<ul>
<li><a href="https://docs.near.org/tutorials/nfts/8-marketplace">Basic marketplace example</a></li>
<li><a href="https://paras.id/">Paras </a>marketplace contract - <a href="https://github.com/ParasHQ/paras-marketplace-contract/tree/master/paras-marketplace-contract/src">source</a>.
As for third-party solutions, the most complete one is <a href="https://www.mintbase.io/">Mintibase</a>, which provides a full suite of components for NFTs integration - including contracts, indexer, API and a web client:
<img src="https://docs.near.org/docs/assets/web3/nfts-22.png" alt="image">
Another option is to roll-out an own NFT contract and integrate with one of the third-party marketplaces, e.g. with <a href="https://paras.id/">Paras</a> (<a href="https://docs.paras.id/nft-smart-contract-integration">integration docs</a>).
<img src="/docs/assets/web3/nfts-23.png" alt="image">
The major advantage of an external marketplace is the fact that they usually run their own indexer and expose collected data via an API, so we don’t have to implement these components. However, they usually have their fee for providing them, so a cost-benefit analysis should be conducted before using them.</li>
</ul>
<h4>Off-chain storages</h4>
<p>Previously, we’ve discussed that storage on the blockchain is not cheap, so in most cases some decentralized storage solution should be used. A few options are available:</p>
<ul>
<li><a href="https://ipfs.io/">IPFS </a>- one of the first decentralized storage solutions, which is widely used in the blockchain world. However, in order to make sure that data is preserved on the network, an IPFS node(s) should be maintained.</li>
<li><a href="https://www.arweave.org/">Arweawe</a> - blockchain-based decentralized storage.</li>
<li><a href="https://filecoin.io/">Filecoin</a> - another blockchain-based storage.</li>
<li><a href="https://nft.storage/">nft.storage</a> - a free service built on top of the IPFS and Filecoin.
A more in-depth overview of such solutions is available <a href="https://docs.near.org/concepts/web3/../storage/decentralized-storage">in the docs</a>. In general, there's no “silver bullet”, so different solutions should be evaluated and the most suitable chosen. The main concerns while choosing a solution are availability guarantees, and cost.</li>
</ul>
<h4>Indexer</h4>
<p>As we already determined, an indexing service is needed in order to support marketplace functionality. It usually consists of 3 components:</p>
<ul>
<li>Indexer - processes transactions from a NEAR network and puts extracted data into a database.</li>
<li>Database - database of choice to store extracted data.</li>
<li>Indexer API - an API layer on top of the database.</li>
</ul>
<p>&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-24.png&quot; alt=&quot;image&quot; width=&quot;150&quot; /&gt;
&lt;/div&gt;
While any technology of choice can be used to implement Database and API, an indexer itself is usually implemented using Rust, since a <a href="https://github.com/near/nearcore/tree/master/chain/indexer">framework is available</a> for this language. Guide how to implement your own indexer can be found <a href="https://docs.near.org/tools/indexer4explorer">here</a>.
Usually, an indexer works by extracting data from <a href="https://nomicon.io/Standards/EventsFormat">Events</a>, which are basically just structured log messages written during contract execution.
<a href="https://thegraph.com/en/">The Graph</a> is an alternative to building an indexer from scratch. This is an Indexer-as-a-Service solution, which simplifies their creation and deployment. Guide on how to create a NEAR indexer is available <a href="https://thegraph.com/docs/en/supported-networks/near/">by this link</a>.</p>
<h4>Automated Testing</h4>
<p>Automated testing of the code is one of the pillars of modern software development. But how do we test our dApp?
Recall that a smart contract is a pure function, which can be easily tested using Unit Tests. Guide on how to write them is available <a href="https://docs.near.org/develop/testing/unit.md">here</a>, and some examples can be found here. Another important kind of tests that is supported by NEAR are E2E tests, they can be executed either deploying contract code to either the local network environment (more info <a href="https://docs.near.org/develop/testing/introduction.md">here</a>), or directly to <code>testnet</code>, more info <a href="https://docs.near.org/develop/testing/integration">here</a>).
Having both types of tests is equally important to ensure continuous quality of smart contracts, especially since contract upgrades usually aren’t easy to perform (remember, that in DAOs upgrade itself might be governed by a community vote).</p>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Non-Functional Concerns?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Last, but not least, let’s cover important non-functional concerns for our architecture.</p>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Security?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The most important thing to remember during the entire development is security, and especially the security of smart contracts. Since their code is public and an upgrade procedure is not trivial, it should be carefully audited for security issues and logical exploits.
Another important thing that should be kept secure is a user's private key. In most cases, only Functional Call keys should be directly accessed from a client, and Full Access keys should be kept in a wallet. However, in some cases a Full Access key might have to be used directly (e.g. in case of server transaction signing scenarios). In such a case, it must be kept in a secure location and treated as a most sensitive secret, since its compromise might lead to a full account takeover.
In general, before deploying an application to the NEAR mainnet, it’s a good idea to conduct a full security audit.</p>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Scalability and Availability?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Another concern is scalability and availability of a solution. There are a lot of ways to scale traditional servers, but how do we scale our blockchain and make sure it’s always available?
Since blockchain is decentralized, it provides us with high-availability by design, and NEAR provides a great scalability by employing Proof-of-Stake consensus and sharding. However, in order to interact with a network, we need an RPC Node. NEAR maintains publicly available nodes for its networks (listed <a href="https://rpc.mainnet.near.org/status">here</a>), but it doesn't provide any performance or availability guarantees for them. So, in order to make sure our architecture is scalable and fault tolerant, we need to maintain our own cluster of RPC nodes, typically behind a load balancer.
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/docs/assets/web3/nfts-25.png&quot; alt=&quot;image&quot; width=&quot;150&quot; /&gt;
&lt;/div&gt;
Information on how to set up an RPC node is available <a href="https://near-nodes.io/rpc">here</a>.
Also, to guarantee availability and scalability of a whole system, all used third-party services should be reviewed as well. For example, if IPFS is used as a storage for NFTs, pinning nodes and IPFS gateway should be scalable and fault tolerant.</p>
<p><a href="https://docs.near.org/concepts/web3/nfts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Why Choosing NEAR?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR has been developed with a focus on performance and usability, both for developers and users.</p>
<p><a href="https://docs.near.org/concepts/what-is-near#why-build-on-near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Simple to Use?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ol>
<li>Uses <a href="https://docs.near.org/concepts/./basics/accounts/introduction.md#human-readable-accountsaccount-i"><strong>human-readable</strong> accounts</a> <em>(e.g. <code>alice.near</code>)</em>.</li>
<li>Leverages a <strong>web-based wallet</strong>, no need for uses to install programs or browser extensions.</li>
<li>Possess a simple yet rich system of <strong>Access Keys</strong> to handle account permissions.</li>
</ol>
<p><a href="https://docs.near.org/concepts/what-is-near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Fast and Environmentally Friendly?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ol>
<li>Transactions are <strong>incredibly fast</strong> <em>(~1s transactions)</em> and <strong>cheap</strong> _(&lt;1¢ in fees).</li>
<li>The network is <strong><a href="https://near.org/blog/the-near-blockchain-is-climate-neutral/">certified carbon-neutral</a></strong>.</li>
<li>NEAR <strong>consumes in a year</strong> the same energy <a href="https://medium.com/nearprotocol/how-near-went-carbon-neutral-e656db96da47#:~:text=The%20firm%20found%20that%20NEAR,PoS%20technology%20instead%20of%20PoW"><strong>bitcoin consumes in 3 minutes</strong></a>.</li>
</ol>
<p><a href="https://docs.near.org/concepts/what-is-near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Great Developer Experience?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ol>
<li>Enables making smart contracts using <strong>Javascript</strong> or <strong>Rust</strong>.</li>
<li><strong>Simple onboarding</strong>, thanks to its complete documentation and a multitude of examples.</li>
<li>NEAR DevRel holds <strong>office hours every weekday</strong>, where anybody can participate.</li>
<li>30% of gas fees goes to the developers.</li>
<li><strong>Project funding</strong> available through our <a href="http://near.org/grants">Grants Program</a>.</li>
</ol>
<p><a href="https://docs.near.org/concepts/what-is-near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Transfer NEAR Ⓝ?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can send NEAR from the your contract to any other account on the network in the form of a promise. The Gas cost for transferring $NEAR is fixed and is based on the protocol's genesis config. Currently, it costs <code>~0.45 TGas</code>.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 - Rust&quot;&gt;</p>
<pre><code class="language-rust">use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, AccountId, Promise, Balance};
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract { }
#[near_bindgen]
impl Contract {
  pub fn transfer(&amp;self, to: AccountId, amount: Balance){
    Promise::new(to).transfer(amount);
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p>The only case where the transfer will fail is if the receiver account does <strong>not</strong> exist.</p>
<p>caution
Remember that your balance is used to cover for the contract's storage. When sending money, make sure you always leave enough to cover for future storage needs.</p>
<p><a href="https://docs.near.org/develop/contracts/actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Function Call?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Your smart contract can call methods in another contract. In the snippet bellow we call a method
in a deployed <a href="https://docs.near.org/develop/contracts/../quickstart">Hello NEAR</a> contract, and check if everything went
right in the callback.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 - Rust&quot;&gt;</p>
<pre><code class="language-rust">use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, env, log, Promise, Gas, PromiseError};
use serde_json::json;
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract { }
const HELLO_NEAR: &amp;str = &quot;hello-nearverse.testnet&quot;;
const NO_DEPOSIT: u128 = 0;
const CALL_GAS: Gas = Gas(5_000_000_000_000);
#[near_bindgen]
impl Contract {
  pub fn call_method(&amp;self){
    let args = json!({ &quot;message&quot;: &quot;howdy&quot;.to_string() })
              .to_string().into_bytes().to_vec();
    Promise::new(HELLO_NEAR.parse().unwrap())
    .function_call(&quot;set_greeting&quot;.to_string(), args, NO_DEPOSIT, CALL_GAS)
    .then(
      Promise::new(env::current_account_id())
      .function_call(&quot;callback&quot;.to_string(), Vec::new(), NO_DEPOSIT, CALL_GAS)
    );
  }
  pub fn callback(&amp;self, #[callback_result] result: Result&lt;(), PromiseError&gt;){
    if result.is_err(){
        log!(&quot;Something went wrong&quot;)
    }else{
        log!(&quot;Message changed&quot;)
    }
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
warning
The snippet showed above is a low level way of calling other methods. We recommend make calls to other contracts as explained in the <a href="https://docs.near.org/develop/contracts/crosscontract">Cross-contract Calls section</a>.</p>
<p><a href="https://docs.near.org/develop/contracts/actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Create a Sub Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Your contract can create sub accounts of itself, i.e. <code>&lt;prefix&gt;.&lt;account-id&gt;.near</code>.
Something important to remark is that an account does <strong>NOT</strong> have control over
its sub-accounts, since they have their own keys. A sub-account is exactly the same as a regular account but it just has a different name. They are useful for organizing your accounts
(e.g. <code>dao.project.near</code>, <code>token.project.near</code>).
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 - Rust&quot;&gt;</p>
<pre><code class="language-rust">use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, env, Promise, Balance};
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract { }
                          
const MIN_STORAGE: Balance = 1_000_000_000_000_000_000_000; //0.001Ⓝ
#[near_bindgen]
impl Contract {
  pub fn create(&amp;self, prefix: String){
    let account_id = prefix + &quot;.&quot; + &amp;env::current_account_id().to_string();
    Promise::new(account_id.parse().unwrap())
    .create_account()
    .transfer(MIN_STORAGE);
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p>Notice that in the snippet we are transferring some money to the new account for storage</p>
<p>caution
When you create an account from within a contract, it has no keys by default. This means it cannot sign transactions and is essentially useless since it has no contract deployed to it. See the following section <a href="https://docs.near.org/develop/contracts/#add-keys">adding keys</a> for more information.</p>
<h4>Creating Other Accounts</h4>
<p>If your contract wants to create another <code>mainnet</code> or <code>testnet</code> account, then it needs to <a href="https://docs.near.org/develop/contracts/#function-call">call</a>
the <code>create_account</code> method of <code>near</code> or <code>testnet</code>.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 - Rust&quot;&gt;</p>
<pre><code class="language-rust">use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, Promise, Gas, Balance };
use serde_json::json;
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract { }
const CALL_GAS: Gas = Gas(28_000_000_000_000);
const MIN_STORAGE: Balance = 1_820_000_000_000_000_000_000; //0.00182Ⓝ
#[near_bindgen]
impl Contract {
  pub fn create_account(&amp;self, account_id: String, public_key: String){
    let args = json!({
                &quot;new_account_id&quot;: account_id,
                &quot;new_public_key&quot;: public_key,
              }).to_string().into_bytes().to_vec();
    // Use &quot;near&quot; to create mainnet accounts
    Promise::new(&quot;testnet&quot;.parse().unwrap())
    .function_call(&quot;create_account&quot;.to_string(), args, MIN_STORAGE, CALL_GAS);
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Deploy a Contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If you just created an account using the previous action, then you can deploy a contract to it using a batch action. For this, you will need to pre-load the byte-code you want to deploy in your contract.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 - Rust&quot;&gt;</p>
<pre><code class="language-rust">use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, env, Promise, Balance};
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract { }
const MIN_STORAGE: Balance = 1_100_000_000_000_000_000_000_000; //1.1Ⓝ
const HELLO_CODE: &amp;[u8] = include_bytes!(&quot;./hello.wasm&quot;);
#[near_bindgen]
impl Contract {
  pub fn create_hello(&amp;self, prefix: String){
    let account_id = prefix + &quot;.&quot; + &amp;env::current_account_id().to_string();
    Promise::new(account_id.parse().unwrap())
    .create_account()
    .transfer(MIN_STORAGE)
    .deploy_contract(HELLO_CODE.to_vec());
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p>If an account with a contract deployed does <strong>not</strong> have any access keys, this is known as a locked contract. When the account is locked, it cannot sign transactions therefore, actions can <strong>only</strong> be performed from <strong>within</strong> the contract code.</p>
<p><a href="https://docs.near.org/develop/contracts/actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Add Keys?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>When you use actions to create a new account, the created account does not have any access keys, meaning that it <strong>cannot sign transactions</strong> (e.g. to update its contract, delete itself, transfer money).
There are two options for adding keys to the account:</p>
<ol>
<li><code>add_access_key</code>: adds a key that can only call specific methods on a specified contract.</li>
<li><code>add_full_access_key</code>: adds a key that has full access to the account.
&lt;br/&gt;
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 - Rust&quot;&gt;</li>
</ol>
<pre><code class="language-rust">use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, env, Promise, Balance, PublicKey};
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract { }
const MIN_STORAGE: Balance = 1_100_000_000_000_000_000_000_000; //1.1Ⓝ
const HELLO_CODE: &amp;[u8] = include_bytes!(&quot;./hello.wasm&quot;);
#[near_bindgen]
impl Contract {
  pub fn create_hello(&amp;self, prefix: String, public_key: PublicKey){
    let account_id = prefix + &quot;.&quot; + &amp;env::current_account_id().to_string();
    Promise::new(account_id.parse().unwrap())
    .create_account()
    .transfer(MIN_STORAGE)
    .deploy_contract(HELLO_CODE.to_vec())
    .add_full_access_key(public_key);
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
Notice that what you actually add is a &quot;public key&quot;. Whoever holds its private counterpart, i.e. the private-key, will be able to use the newly access key.</p>
<p>If an account with a contract deployed does <strong>not</strong> have any access keys, this is known as a locked contract. When the account is locked, it cannot sign transactions therefore, actions can <strong>only</strong> be performed from <strong>within</strong> the contract code.</p>
<p><a href="https://docs.near.org/develop/contracts/actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Delete Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>There are two scenarios in which you can use the <code>delete_account</code> action:</p>
<ol>
<li>As the <strong>last</strong> action in a chain of actions.</li>
<li>To make your smart contract delete its own account.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 - Rust&quot;&gt;</li>
</ol>
<pre><code class="language-rust">use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, env, Promise, Balance, AccountId};
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract { }
                          
const MIN_STORAGE: Balance = 1_000_000_000_000_000_000_000; //0.001Ⓝ
#[near_bindgen]
impl Contract {
  pub fn create_delete(&amp;self, prefix: String, beneficiary: AccountId){
    let account_id = prefix + &quot;.&quot; + &amp;env::current_account_id().to_string();
    Promise::new(account_id.parse().unwrap())
    .create_account()
    .transfer(MIN_STORAGE)
    .delete_account(beneficiary);
  }
  pub fn self_delete(beneficiary: AccountId){
    Promise::new(env::current_account_id())
    .delete_account(beneficiary);
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
warning Token Loss
If the beneficiary account does not exist a the funds will be <a href="https://docs.near.org/concepts/basics/token-loss"><strong>dispersed among validators</strong></a>.</p>
<p>warning Token Loss
Do <strong>not</strong> use <code>delete</code> to try fund a new account. Since the account doesn't exist the tokens will be lost.</p>
<p><a href="https://docs.near.org/develop/contracts/actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Anatomy of a Donation?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Let's look at a simple contract whose main purpose is to allow users to donate $NEAR to a specific account. Particularly, the contract keeps track of a <code>beneficiary</code> account and exposes a <code>donation</code> function that forwards the money and keeps track of the donation info. Take a quick peek at the snippet bellow and then continue to the <a href="https://docs.near.org/develop/contracts/#modules">modules</a> section.</p>
<p>This contract is written for educational purposes only.</p>
<p>&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/contract/src/lib.rs&quot;
start=&quot;1&quot; end=&quot;74&quot; /&gt;
&lt;Github fname=&quot;views.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/contract/src/views.rs&quot; /&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-as/contract/assembly/index.ts&quot;
start=&quot;1&quot; end=&quot;29&quot; /&gt;
&lt;Github fname=&quot;model.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-as/contract/assembly/model.ts&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/anatomy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Modules?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>When writing smart contracts you will leverage imports to organize your code, and reuse third-party libraries.
The main library you will use while writing smart contracts is the NEAR SDK. This can be seen at the top of the donation smart contract.
&lt;Tabs className=&quot;language-tabs&quot; groupId=&quot;code-tabs&quot;&gt;
&lt;TabItem value={0} label=&quot;🦀 - Rust&quot;&gt;</p>
<pre><code class="language-rust">  use near_sdk::collections::Vector;
  use near_sdk::{env, log, near_bindgen, AccountId, Promise, Balance};
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value={1} label=&quot;🚀 - AssemblyScript&quot;&gt;</p>
<pre><code class="language-ts">  import { u128, context, logging, ContractPromiseBatch } from &quot;near-sdk-as&quot;;
  import { STORAGE_COST, Donation, add_donation, get_donation,
          set_beneficiary, get_beneficiary, get_number_of_donation } from &quot;./model&quot;;
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
The NEAR SDK defines methods to, among other things:</p>
<ol>
<li>Understand the context of a transaction (e.g. who started it, how much money they sent, etc...).</li>
<li>Handle the state (storage) of the smart contract.</li>
<li>Transfer money to other users/contracts.</li>
<li>Interact with other smart contracts.</li>
</ol>
<p><a href="https://docs.near.org/develop/contracts/anatomy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Contract's Interface?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Smart contracts expose an interface so users in the blockchain can interact with them. A contract's interface is made of all the callable functions that live in the codebase.</p>
<p><a href="https://docs.near.org/develop/contracts/anatomy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Initialization Functions?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>When smart contracts are deployed to the blockchain, the variables must be initialized with a starting value. This is done automatically by default but it's very common to overload this behavior by creating a custom initialization function.
For example, in the donation contract, a <code>beneficiary</code> account is stored on the contract as a string. When the contract is deployed, we wouldn't want that account to be defaulted to an empty string <code>&quot;&quot;</code>. This is why we created the <code>new</code> method, which takes in an account ID as a parameter and sets the <code>beneficiary</code> variable.
&lt;Tabs className=&quot;language-tabs&quot; groupId=&quot;code-tabs&quot;&gt;
&lt;TabItem value={0} label=&quot;🦀 - Rust&quot;&gt;
&lt;Github fname=&quot;lib.rs&quot; language=&quot;rust&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/contract/src/lib.rs&quot;
start=&quot;28&quot; end=&quot;36&quot; /&gt;
Notice that the <code>new</code> method has two macros at the top: <code>#[init]</code> and <code>#[private]</code>. <code>#[init]</code> limits the method to be callable only once, meanwhile <code>#[private]</code> makes the method only callable by the contract's account.
&lt;/TabItem&gt;
&lt;TabItem value={1} label=&quot;🚀 - AssemblyScript&quot;&gt;</p>
<pre><code class="language-ts">  const initialized: bool = storage.getPrimitive&lt;bool&gt;('init', false)
  assert(!initialized, &quot;Already initialized&quot;)
  storage.set&lt;bool&gt;('init', true)
</code></pre>
<p>In AssemblyScript there is no <code>#[init]</code> macro. You can create one yourself, as in the example above, but be mindful that, as any other method, it could be called multiple times. You can force the function to work only once by adding the following code:
&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/anatomy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Public and Private methods?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>All public methods that are exposed will be <strong>callable by all users</strong> in the blockchain. In the donation contract above, such methods are:</p>
<ol>
<li><code>donate</code>: A method in which the users attaches NEAR in to donate.</li>
<li><code>get_donation_by_number</code>: Returns a recorded donation, stating how much a user donated.</li>
<li><code>new</code>: Enables to initialize the contract with a specific <code>beneficiary</code>. This function is made private by enforcing that the caller is the contract account itself.
All the other private functions can only be called from within the contract itself.</li>
</ol>
<p><a href="https://docs.near.org/develop/contracts/anatomy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Typed Variables?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Smart contracts store typed values within them. The data types available are: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, and their signed counterparts. Furthermore, the SDKs expose collections such as <code>Vector</code> and <code>Map</code> to simplify handling data. We cover this topic in depth on the <a href="https://docs.near.org/develop/contracts/storage">Storage</a> section.
There are two things to be aware of at a high level when dealing with storage. First, underflow and overflow errors can occur and often it's a good idea to check when doing operations. Second, in Rust, the contract's attributes are stored in <code>Self</code>. With AssemblyScript, you need to explicitly rely on the <code>storage</code> object to store attributes.</p>
<p>In Rust, we are also relying on the <code>env::storage</code> object to store the contract's state. This, however, gets abstracted away by the SDK.</p>
<p>warning
Remember to check for possible underflow and overflows! In rust, you can do this by simply adding the <code>overflow-checks = true</code> flag in your <code>Cargo.toml</code>.</p>
<p><a href="https://docs.near.org/develop/contracts/anatomy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Classes, NEAR Bindgen and Serialization?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You might have notice in the examples that some structs have the <code>#[near_bindgen]</code> macro and in Rust, derive Borsch or serde serialization.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/contract/src/lib.rs&quot; start=&quot;10&quot; end=&quot;15&quot; /&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-as/contract/assembly/model.ts&quot; start=&quot;4&quot; end=&quot;10&quot;/&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;
The <code>#[near_bindgen]</code> macro is used on a struct and the function implementations to generate the necessary code to be a valid NEAR contract and expose the intended functions to be able to be called externally.
Borsch serialization is needed for optimal internal state serialization and <code>serde</code> for external JSON serialization.</p>
<p>Did you know that contracts communicate with each other using values encoded in JSON?</p>
<p>info Using external libraries
As a general rule of thumb for Rust, anything that supports <code>wasm32-unknown-unknown</code> will be compatible with your smart contract.
However, we do have a size limit for a compiled binary of a contract which is ~4.19 MB so it is possible that certain large libraries will not be compatible.</p>
<p><a href="https://docs.near.org/develop/contracts/anatomy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Snippet: Querying Information?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>While making your contract, it is likely that you will want to query information from another contract. Below, you can see a basic example in which we query the greeting message from our <a href="https://docs.near.org/develop/contracts/../quickstart">Hello NEAR</a> example.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-rs/contract/src/lib.rs&quot;
start=&quot;24&quot; end=&quot;55&quot; /&gt;
&lt;Github fname=&quot;external.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-rs/contract/src/external.rs&quot; /&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-as/contract/assembly/index.ts&quot;
start=&quot;10&quot; end=&quot;45&quot; /&gt;
&lt;Github fname=&quot;external.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-as/contract/assembly/external.ts&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/crosscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Snippet: Sending Information?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Calling another contract passing information is also a common scenario. Bellow you can see a method that interacts with the <a href="https://docs.near.org/develop/contracts/../quickstart">Hello NEAR</a> example to change its greeting message.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-rs/contract/src/lib.rs&quot;
start=&quot;56&quot; end=&quot;81&quot; /&gt;
&lt;Github fname=&quot;external.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-rs/contract/src/external.rs&quot; /&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-as/contract/assembly/index.ts&quot;
start=&quot;47&quot; end=&quot;79&quot; /&gt;
&lt;Github fname=&quot;external.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-as/contract/assembly/external.ts&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/crosscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Promises?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order for your contract to interact with a different one, you need to create two <a href="https://docs.near.org/tutorials/examples/xcc">Promises</a>:</p>
<ol>
<li>A promise to execute code in the external contract (<code>ContractPromise.create</code>).</li>
<li>A promise to call back a <strong>different</strong> method in your contract with the result (<code>ContractPromise.then</code>). This is often referred to as the callback.
Both promises take the same arguments:
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;CodeBlock&gt;
external_trait::ext(&quot;external_address&quot;)
.with_attached_deposit(DEPOSIT)
.with_static_gas(GAS)
.method(arguments);
&lt;/CodeBlock&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;CodeBlock&gt;
ContractPromise.create(
&quot;external_address&quot;, &quot;method&quot;, &quot;encoded_arguments&quot;, GAS, DEPOSIT
)
&lt;/CodeBlock&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;
<ul>
<li>The address of the contract you want to interact with</li>
<li>The method that you want to execute</li>
<li>The (<strong>encoded</strong>) arguments to pass to the method</li>
<li>The amount of GAS to use (deducted from the <strong>attached Gas</strong>)</li>
<li>The amount of NEAR to attach (deducted from <strong>your contract’s balance</strong>)</li>
</ul>
</li>
</ol>
<p>Notice that the callback could be made to <strong>any</strong> contract. This means that, if you want, the result could be potentially handled by another contract.</p>
<p>caution
The fact that you are creating a Promise means that both the cross-contract call and callback will <strong>not execute immediately</strong>. In fact:</p>
<ul>
<li>The cross-contract call will execute 1 or 2 blocks after your method finishes <strong>correctly</strong>.</li>
<li>The callback will then execute 1 or 2 blocks after the <strong>external</strong> method finishes (<strong>correctly or not</strong>)</li>
</ul>
<p><a href="https://docs.near.org/develop/contracts/crosscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Callback Method?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If your method finishes correctly, then eventually your callback method will execute. This will happen whether the external contract finishes <strong>successfully or not</strong>. We repeat, if your original method finishes correctly, then your callback will <strong>always execute</strong>.
In the callback method you will have access to the result, which contains two important arguments:</p>
<ul>
<li><code>status</code>: Telling if the external method finished successfully or not</li>
<li><code>buffer</code>: Having the value returned by the external method (if any)</li>
</ul>
<p>The callback methods in your contract must be public, so it can be called when the second promise executes. However, they should be only callable by <strong>your contract</strong>. Always make sure to make it private by asserting that the <code>predecessor</code> is <code>current_account_id</code>. In rust this can be achieved using the <code>#[private]</code> decorator.</p>
<p><a href="https://docs.near.org/develop/contracts/crosscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Checking Execution Status?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-rs/contract/src/lib.rs&quot;
start=&quot;72&quot; end=&quot;80&quot; /&gt;
&lt;Github fname=&quot;external.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-rs/contract/src/external.rs&quot;
start=&quot;23&quot; end=&quot;33&quot;/&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-as/contract/assembly/index.ts&quot;
start=&quot;70&quot; end=&quot;78&quot; /&gt;
&lt;Github fname=&quot;external.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-as/contract/assembly/external.ts&quot;
start=&quot;9&quot; end=&quot;19&quot;/&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/crosscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Successful Execution?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In case the call finishes successfully, the resulting object will have a <code>status</code> of 1, and the <code>buffer</code> will have the encoded result (if any). In order to recover the result you need to decode it from the resulting <code>buffer</code>:
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;lib.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-rs/contract/src/lib.rs&quot;
start=&quot;47&quot; end=&quot;50&quot; /&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-as/contract/assembly/index.ts&quot;
start=&quot;37&quot; end=&quot;39&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/crosscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Failed Execution?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If the external method fails (i.e. it panics), then your callback will be <strong>executed anyway</strong>. Here you need to <strong>manually rollback</strong> any changes made in your
contract during the original call. Particularly:</p>
<ol>
<li>If the contract attached NEAR to the call, the funds are sent back to <strong>the contract's account</strong>.</li>
<li>If the original method made any state changes (i.e. changed or stored data), they <strong>won't be automatically reverted</strong>.
warning
If your original method finishes correctly then the callback executes <strong>even if the external method panics</strong>. Your state will <strong>not</strong> rollback automatically,
and $NEAR will <strong>not</strong> be returned to the signer automatically. Always make sure to check in the callback if the external method failed, and manually rollback any
operation if necessary.</li>
</ol>
<p><a href="https://docs.near.org/develop/contracts/crosscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Security Concerns?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>While writing cross-contract calls there is a significant aspect to keep in mind: all the calls are <strong>independent</strong> and <strong>asynchronous</strong>. In other words:</p>
<ul>
<li>The method in which you make the call and method for the callback are <strong>independent</strong>.</li>
<li>There is a <strong>delay between the call and the callback</strong>, in which people can still interact with the contract
This has important implications on how you should handle the callbacks. Particularly:</li>
</ul>
<ol>
<li>Make sure you don't leave the contract in a exploitable state between the call and the callback.</li>
<li>Manually rollback any changes to the state in the callback if the external call failed.
We have a whole <a href="https://docs.near.org/develop/contracts/./security/callbacks">security section</a> dedicated to these specific errors, so please go and check it.
warning
Not following these basic security guidelines could expose your contract to exploits. Please check the <a href="https://docs.near.org/develop/contracts/./security/callbacks">security section</a>, and if still in doubt, <a href="https://near.chat">join us in Discord</a>.</li>
</ol>
<p><a href="https://docs.near.org/develop/contracts/crosscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Environment Variables?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 Rust&quot;&gt;
&lt;TableRs&gt;&lt;/TableRs&gt;
&lt;/TabItem&gt;
&lt;TabItem value=&quot;as&quot; label=&quot;🚀 Assemblyscript&quot;&gt;
&lt;TableAs&gt;&lt;/TableAs&gt;
&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Who is Calling? Who am I?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The environment has information about 3 important users: the <code>current_account</code>, <code>predecessor</code>, and the <code>signer</code>.</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Current Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The <code>current_account</code> contains the address in which your contract is deployed. This is very useful to implement ownership, e.g. making a public method only callable by the contract itself.</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Predecessor and Signer?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The <code>predecessor</code> is the account that called the method in the contract. Meanwhile, the <code>signer</code> is the account that <em>signed</em> the initial transaction.
During a simple transaction (no <a href="https://docs.near.org/develop/contracts/environment/../crosscontract.md">cross-contract calls</a>) the <code>predecessor</code> is the same as the <code>signer</code>. For example, if <strong>alice.near</strong> calls <strong>contract.near</strong>, from the contract's perspective, <strong>alice.near</strong> is both the <code>signer</code> and the <code>predecessor</code>. However, if <strong>contract.near</strong> creates a <a href="https://docs.near.org/develop/contracts/environment/../crosscontract">cross-contract call</a>, then the <code>predecessor</code> changes down the line. In the example bellow, when <strong>pool.near</strong> executes, it would see <strong>contract.near</strong> as the <code>predecessor</code> and <strong>alice.near</strong> as the <code>signer</code>.
<img src="https://miro.medium.com/max/1400/1*LquSNOoRyXpITQF9ugsDpQ.png" alt="img">
<em>You can access information about the users interacting with your smart contract</em></p>
<p>In most scenarios you will <strong>only need the predecessor</strong>. However, there are situations in which the signer is very useful. For example, when adding <a href="https://docs.near.org/develop/contracts/environment/../../relevant-contracts/nft">NFTs</a> into <a href="https://github.com/near-examples/nft-tutorial/blob/7fb267b83899d1f65f1bceb71804430fab62c7a7/market-contract/src/nft_callbacks.rs#L42">this marketplace</a>, the contract checks that the <code>signer</code>, i.e. the person who generated the transaction chain, is the NFT owner.</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Balances and Attached NEAR?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>During a method execution, the environment gives you access to three token-related parameters, all expressed in yoctoNEAR (1 Ⓝ = 10&lt;sup&gt;24&lt;/sup&gt;yⓃ):</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Attached Deposit?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>attached_deposit</code> represents the amount of yoctoNEAR the predecessor attached to the call. This amount gets deposited immediately in your contract's account,
and <strong>is automatically returned</strong> to the <code>predecessor</code> <strong>if your method panics</strong>.
warning
If you make a cross-contract call](../crosscontract.md) and it panics, the funds are sent back to <strong>your contract</strong>. See how to handle this situation in the <a href="https://docs.near.org/develop/contracts/environment/../crosscontract#failed-execution">callback section</a></p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Account Balance?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>account_balance</code> represents the balance of your contract (<code>current_account</code>). It includes the <code>attached_deposit</code>, since it was deposited when the method execution started.
If the contract has any locked $NEAR, it will appear in <code>account_locked_balance</code>.</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Storage Used?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>storage_used</code> represents the amount of <a href="https://docs.near.org/develop/contracts/environment/../storage">storage</a> that is currently being used by your contract.</p>
<p>If you want to know how much storage a structure uses, print the storage before and after storing it.</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Telling the Time?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The environment exposes three different ways to tell the pass of time, each representing a different dimension of the underlying blockchain:</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Timestamp?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The <code>timestamp</code> attribute represents the approximated UNIX timestamp at which this call was executed. It quantifies time passing in a human way, enabling to check if a specific date has passed or not.</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Current Epoch?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The NEAR blockchain groups blocks in <a href="https://docs.near.org/concepts/basics/epoch.md">Epochs</a>. The <code>current_epoch</code> attribute measures how many epochs have passed so far. It is very useful to coordinate with other contracts that measure time in epochs, such as the <a href="https://docs.near.org/concepts/basics/validators">validators</a></p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Block Index?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The <code>block_index</code> represents the index of the block in which this transaction will be added to the blockchain</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Gas?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Your smart contract has a limited number of computational resources to use on each call. Such resources are measured in <a href="https://docs.near.org/develop/contracts/environment/concepts/basics/transactions/gas">Gas</a>. Gas can be thought of as wall time, where 1 PetaGas (1_000 TGas) is ~1 second of compute time. Each code instruction costs a certain amount of Gas, and if you run out of it, the execution halts with the error message <code>Exceeded the prepaid gas</code>.
Through the environment you get access to two gas-related arguments.</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Prepaid Gas?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>prepaid_gas</code> represents the amount of Gas the <code>predecessor</code> attached to this call. It cannot exceed the limit 300TGas (300 * 10&lt;sup&gt;12&lt;/sup&gt; Gas).</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Used Gas?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>used_gas</code> contains the amount of Gas that has been used so far. It is useful to estimate the Gas cost of running a method.</p>
<p>If you already <a href="https://docs.near.org/develop/contracts/environment/concepts/basics/transactions/gas#accurate-estimates-with-automated-tests">estimated the Gas</a> a method needs, you can ensure it never runs out of Gas by using <code>assert</code>
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;rs&quot; label=&quot;🦀 Rust&quot;&gt;</p>
<pre><code class="language-rust">const REQUIRED_GAS: Gas = Gas(20_000_000_000_000); // 20 TGas
assert!(env::prepaid_gas() &gt;= REQUIRED_GAS, &quot;Please attach at least 20 TGas&quot;);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;as&quot; label=&quot;🚀 Assemblyscript&quot;&gt;</p>
<pre><code class="language-ts">const TGas: u64 = 1000000000000;
assert(context.prepaidGas &gt;= 20*TGas, &quot;Please attach at least 20 TGas&quot;);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p>warning
When doing <a href="https://docs.near.org/develop/contracts/environment/develop/contracts/crosscontract">cross-contract calls</a> always make sure that the callback has enough Gas to fully execute any error handling.</p>
<p><a href="https://docs.near.org/develop/contracts/environment/environment">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Private Callbacks?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order for your contract to call itself when a cross-contract call is done, you need to make the callback method public. However, most of the times you would want it to be private. You can make it private while keeping it public by asserting that the <code>predecessor</code> is <code>current_account</code>. In rust this is done automatically by adding the <code>#[private]</code> decorator.</p>
<p><a href="https://docs.near.org/develop/contracts/security/callbacks">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the User's Money?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>When a method panics, the money attached to that transaction returns to the <code>predecessor</code>. This means that, if you make a cross-contract call and it fails, then the money <strong>returns to your contract</strong>. If the money came from a user calling your contract, then you should transfer it back during the callback.
<img src="https://miro.medium.com/max/1400/1*Hp4TOcaBqm9LS0wkgWw3nA.png" alt="img">
<em>If the user attached money, we need to manually return it in the callback</em>
caution
Make sure you pass have enough GAS in the callback to make the transfer</p>
<p><a href="https://docs.near.org/develop/contracts/security/callbacks">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Async Callbacks?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Between a cross-contract call and its callback <strong>any method of your contract can be executed</strong>. Not taking this into account is one of the main sources of exploits. It is so common that it has its own name: <a href="https://docs.near.org/develop/contracts/security/./reentrancyattacks">reentrancy attacks</a>.
Imagine that we develop a <code>deposit_and_stake</code> with the following <strong>wrong logic</strong>: (1) The user sends us money, (2) we add it to its balance, (3) we try to stake it in a validator, (4) if the staking fails, we remove the balance in the callback. Then, a user could schedule a call to withdraw between (2) and (4), and, if the staking failed, we would send money twice to the user.
<img src="https://miro.medium.com/max/1400/1*VweWHQYGLBa70uceiWHLQA.png" alt="img">
<em>Between a cross-contract call and the callback anything could happen</em>
Luckily for us the solution is rather simple. Instead of immediately adding the money to our user’s balance, we wait until the callback. There we check, and if the staking went well, then we add it to their balance.
<img src="https://miro.medium.com/max/1400/1*o0YVDCp_7l-L3njJMGhU4w.png" alt="img">
<em>Correct way to handle deposits in a cross-contract call</em></p>
<p><a href="https://docs.near.org/develop/contracts/security/callbacks">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Anatomy?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ol>
<li>There are no <code>private</code> methods marked as public by mistake</li>
</ol>
<p><a href="https://docs.near.org/develop/contracts/security/checklist">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Environment?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ol start="2">
<li><code>predecessor</code> and <code>signer</code> are used correctly through the entire contract</li>
</ol>
<p><a href="https://docs.near.org/develop/contracts/security/checklist">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Actions?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ol start="6">
<li>When sending money, you left enough in the contract to cover the storage cost</li>
</ol>
<p><a href="https://docs.near.org/develop/contracts/security/checklist">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Callbacks?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ol start="7">
<li>All private callbacks are marked as <code>[#private]</code> in Rust, or <code>assert</code> the caller (<code>predecessor</code>) is the contract (<code>current_account</code>)</li>
<li>All cross-contract calls have a callback that checks for errors and rolls back the state if necessary</li>
<li>All cross-contract calls have a callback that checks for errors and returns money to the <code>predecessor</code> if necessary</li>
<li>All the callbacks are given enough GAS to finish without errors</li>
<li>The contract is not left in a exploitable state between a cross-contract call and its callback</li>
</ol>
<p><a href="https://docs.near.org/develop/contracts/security/checklist">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Attributes and Constants?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can store constants and define contract's attributes.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs&quot; start=&quot;11&quot; end=&quot;24&quot;/&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/index.ts&quot;
start=&quot;10&quot; end=&quot;29&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/storage">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Data Structures?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Both <a href="https://github.com/near/near-sdk-rs/">Rust SDK</a> and <a href="https://github.com/near/near-sdk-as/">AssemblyScript SDK</a> expose a series of data structures to simplify handling and storing data. In this page we showcase how to use the most common ones: Vectors, Sets, Maps and Trees. For the complete documentation please refer to the SDK pages.
caution
When initializing a data structure make sure to give it a <strong>unique ID</strong>, otherwise, it could point to other structure's key-value references.</p>
<p><a href="https://docs.near.org/develop/contracts/storage">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Vector?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Implements a <a href="https://en.wikipedia.org/wiki/Array_data_structure">vector/array</a> which persists in the contract's storage. Please refer to the Rust and AS SDK's for a full reference on their interfaces.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;vector.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/vector.rs&quot; start=&quot;12&quot; end=&quot;30&quot;/&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs&quot; start=&quot;7&quot; end=&quot;24&quot;/&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;vector.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/<strong>tests</strong>/vector.spec.ts&quot; start=&quot;4&quot; end=&quot;16&quot;/&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/index.ts&quot;
start=&quot;1&quot; end=&quot;11&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;
&lt;blockquote class=&quot;lesson&quot;&gt;
&lt;strong&gt;How do you update a property of an object within a PersistentVector?&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;</p>
<p>This question is specific to Assemblyscript.
You have to replace the whole object. Persistent collections are ultimately just wrappers around storage.get and storage.set operating on JSON-serialized objects.
&lt;/blockquote&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/storage">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Map?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Implements a <a href="https://en.wikipedia.org/wiki/Associative_array">map/dictionary</a> which persists in the contract's storage. Please refer to the Rust and AS SDK's for a full reference on their interfaces.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;map.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/map.rs&quot; start=&quot;9&quot; end=&quot;24&quot;/&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs&quot; start=&quot;7&quot; end=&quot;24&quot;/&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;map.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/<strong>tests</strong>/map.spec.ts&quot; start=&quot;5&quot; end=&quot;15&quot;/&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/index.ts&quot;
start=&quot;1&quot; end=&quot;11&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;
&lt;blockquote class=&quot;lesson&quot;&gt;
&lt;strong&gt;How is PersistentMap used?&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;</p>
<p>This question is specific to Assemblyscript.
PersitentMap stores a key value pair, whereby the key is either a string or number and the value is usually an object. If you want to retrieve a particular value, you have to include the key to the value.
The biggest advantage of an unordered map to a vector is, it prevents duplicate keys and saves searching time. As a result, if I have two more elements linked to the key and I want one of them to be unique, one of the solutions is to set the value type to another map.
&lt;/blockquote&gt;
&lt;blockquote class=&quot;lesson&quot;&gt;
&lt;strong&gt;Why is my call to <code>get</code> a value with default not passing type checks?&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;</p>
<p>You may need to use the TypeScript non-null assertion operator if you're trying to get a value, supplying a default and still failing type checks:</p>
<pre><code class="language-ts">storage.get(&quot;my-var&quot;, &quot;hello, default&quot;)!; // notice the ! at the end
</code></pre>
<p>&lt;/blockquote&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/storage">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Set?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Implements a <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">set</a> which persists in the contract's storage. Please refer to the Rust and AS SDK's for a full reference on their interfaces.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;set.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/set.rs&quot; start=&quot;9&quot; end=&quot;16&quot;/&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs&quot; start=&quot;7&quot; end=&quot;24&quot;/&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;map.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/<strong>tests</strong>/set.spec.ts&quot; start=&quot;5&quot; end=&quot;11&quot;/&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/index.ts&quot;
start=&quot;1&quot; end=&quot;11&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/storage">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Tree?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>An ordered equivalent of Map. The underlying implementation is based on an <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL</a>. You should use this structure when you need to: have a consistent order, or access the min/max keys.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;tree.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/tree.rs&quot; start=&quot;9&quot; end=&quot;16&quot;/&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs&quot; start=&quot;7&quot; end=&quot;24&quot;/&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;tree.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/<strong>tests</strong>/tree.spec.ts&quot; start=&quot;5&quot; end=&quot;11&quot;/&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/storage-as/contract/assembly/index.ts&quot;
start=&quot;1&quot; end=&quot;11&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/contracts/storage">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to deploy a contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Thanks to the <code>NEAR CLI</code> deploying a contract is as simple as:</p>
<ol>
<li>Compiling the contract to wasm (done automatically through <code>yarn build</code> in our templates).</li>
<li>Deploy it into the desired account using the <a href="https://docs.near.org/develop/develop/integrate/cli">NEAR Command Line Interface (CLI)</a>:</li>
</ol>
<pre><code class="language-bash"># Login to NEAR
near login
# Deploy wasm to the &lt;accountId&gt; account
near deploy &lt;accountId&gt; &lt;route_to_wasm&gt;
</code></pre>
<p>By default the contract will be deployed to the testnet. To deploy into <code>mainnet</code> you can set the <code>NEAR_ENV</code> variable to mainnet (<code>export NEAR_ENV=mainnet</code>).</p>
<p>You can use <code>near dev_deploy</code> to deploy the contract into a newly created account!</p>
<p><a href="https://docs.near.org/develop/deploy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to upgrade a contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If the contract's account has a <a href="https://docs.near.org/concepts/basics/accounts/access-keys#full-access-keys-full-access-keys">Full Access Key</a>, then
you will be able to re-deploy another contract on top of it later. On doing so, take into account that re-deploying a contract
does not wipe the state. This means that while the code will change <strong>the state will persist</strong>.
Since the state is persisted, adding/modifying methods that <strong>read</strong> the storage and returns a value will yield no problem. However,
deploying a contract with a different state will raise a <code>Cannot deserialize the contract state</code> error.</p>
<p><a href="https://docs.near.org/develop/deploy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to migrate a contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If the new contract has a different state but you need anyway to deploy it, you have the option to implement a new method to <code>migrate</code>
the contract's state. Please check our <a href="https://www.near-sdk.io/upgrading/production-basics">migration page</a>.</p>
<p><a href="https://docs.near.org/develop/deploy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to lock a contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If you remove the <a href="https://docs.near.org/tools/near-cli#near-delete-key-near-delete-key">full access key</a> from the account, then the account will become
<code>locked</code>. When the account is locked nobody can perform a transaction in the contract account's name (e.g. update the code or transfer money).
This tends to bring more reassurance to the users, knowing that no external actor will be able to manipulate the contract's state or
balance.
Upgrading Locked Contracts
Please do note that, while no external actor can update the contract, the contract <strong>can still upgrade itself!</strong>. For example, our reference
DAO implementation includes an <a href="https://github.com/near-daos/sputnik-dao-contract/blob/main/sputnikdao2/src/upgrade.rs">upgrading mechanism</a>
governed by the community.</p>
<p><a href="https://docs.near.org/develop/deploy">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the View methods?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>View methods are those that perform <strong>read-only</strong> operations. Calling these methods is free, and do not require to specify which account is being used to make the call:</p>
<pre><code class="language-bash">near view &lt;accountId&gt; &lt;methodName&gt;
</code></pre>
<p><a href="https://docs.near.org/develop/integrate/cli">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Change methods?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Change methods are those that perform both read and write operations. For these methods we do need to specify the account being used to make the call,
since that account will expend GAS in the call.</p>
<pre><code class="language-bash">near call &lt;contractId&gt; &lt;methodName&gt; &lt;jsonArgs&gt; --accountId &lt;yourAccount&gt; [--attachDeposit &lt;amount&gt;] [--gas &lt;GAS&gt;]
</code></pre>
<p><a href="https://docs.near.org/develop/integrate/cli">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Adding NEAR API JS?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order to use near-api-js you will need to first add it to your project.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;node&quot; label=&quot;node&quot;&gt;</p>
<pre><code class="language-bash">npm i near-api-js
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;html&quot; label=&quot;HTML&quot;&gt;</p>
<pre><code class="language-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/near-api-js@0.44.2/dist/near-api-js.min.js&quot; integrity=&quot;sha256-W5o4c5DRZZXMKjuL41jsaoBpE/UHMkrGvIxN9HcjNSY=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/develop/integrate/frontend">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Connecting to a Contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The first step on using a smart contract from a web-frontend is connecting to it. Connecting to the smart contract is actually composed by 3 simple steps:</p>
<ol>
<li>Connecting to the NEAR network (<code>testnet</code> or <code>mainnet</code>)</li>
<li>Initializing a Wallet, representing the user's wallet</li>
<li>Initializing a Contract, representing the contract itself</li>
</ol>
<p>In our examples we always do this within the <code>initContract</code> method:
&lt;CodeTabs&gt;
&lt;Language value=&quot;🌐 - Javascript&quot; language=&quot;js&quot;&gt;
&lt;Github fname=&quot;utils.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/near/utils.js&quot; start=&quot;1&quot; end=&quot;23&quot; /&gt;
&lt;Github fname=&quot;config.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/near/config.js&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;
Then, we use <code>initContract</code> in the web-app logic to set up a &quot;flow&quot;, i.e. a simple <code>if</code> where we decide what to do if the user is logged in or not.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🌐 - Javascript&quot; language=&quot;js&quot;&gt;
&lt;Github fname=&quot;utils.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/index.js&quot; start=&quot;44&quot; end=&quot;54&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;
info
When initializing the <code>Contract</code> object in the snippet above we are passing a dictionary: <code>nearConfig</code>. In that dictionary we set: the network to which we want to connect (<code>testnet</code> in our snippet), and where to store the user's login information (we store the user's keys in the website's local storage).</p>
<p><a href="https://docs.near.org/develop/integrate/frontend">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Calling View Methods?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Once we have setup the connection to the NEAR network and defined the <code>Contract</code> object we can readily call view methods.
View methods are those that perform read-only operations, and do not change the contract's state.
Because of their read-only nature, view methods are <strong>free</strong> to call, and do not require the user to be logged in.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🌐 - Javascript&quot; language=&quot;js&quot;&gt;
&lt;Github fname=&quot;utils.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/near/utils.js&quot;
start=&quot;48&quot; end=&quot;56&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;
The snippet above if part of our <code>donation example</code>. On it, we are calling <code>total_donations</code> and <code>get_donation_list</code> to retrieve the last 10 recorded donations. These methods only read from the contract, so they can be used readily without the user needing to log in.</p>
<p><a href="https://docs.near.org/develop/integrate/frontend">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the User Sign-in?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order to interact with non-view methods it is necessary to first sign in using a NEAR wallet. Signing in is as simple as requesting the <code>walletConnection</code> object to for signing in. Once we want to logout the user, we simply need to request the <code>walletConnection</code> to sign out.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🌐 - Javascript&quot; language=&quot;js&quot;&gt;
&lt;Github fname=&quot;utils.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/near/utils.js&quot;
start=&quot;35&quot; end=&quot;35&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;
Signing in <strong>actually means</strong> that the user's wallet creates and stores an <code>access key</code> in the web's local storage. By default, such key enables to expend a maximum of <code>0.25Ⓝ</code> on GAS for calling our contract without asking the user to sign them.
However, if you attach money to any call, the user will be redirected to the wallet to confirm the transaction.</p>
<p>You can use <code>walletConnection.account().function_call</code> to call <strong>any</strong> method in <strong>any</strong> contract. However, the user will be redirected to the wallet and asked to accept the call.</p>
<p><a href="https://docs.near.org/develop/integrate/frontend">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Calling Change Methods?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Only after the user logs-in they can start calling change methods. Programmatically, calling change methods is similar to calling view methods, only that now you can attach money to the call, and specify how much GAS you want to use. It is important to notice that, if you ask for money to be attached in the call, then the user will be redirected to the NEAR wallet to accept the transaction.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🌐 - Javascript&quot; language=&quot;js&quot;&gt;
&lt;Github fname=&quot;utils.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/near/utils.js&quot;
start=&quot;60&quot; end=&quot;63&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p>Remember that you can use <code>walletConnection.account().function_call</code> to call methods in <strong>any</strong> contract. However, the user will be redirected to the wallet and asked to accept the call.</p>
<p><a href="https://docs.near.org/develop/integrate/frontend">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Wallet Redirection?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If you attach money to a change call, then the user will be redirected to their wallet to accept the transaction. After accepting, the user will be brought back to your website, with the resulting transaction hash being pass as part of the url (i.e. <code>your-website.com/?transactionHashes=...</code>).
If the method invoked returned a result, you can use the transaction hash to retrieve the result from the network. Assuming you created the <code>near</code> object as in the <a href="https://docs.near.org/develop/integrate/#connecting-to-a-contract">example above</a>, then you query the result by doing:
&lt;CodeTabs&gt;
&lt;Language value=&quot;🌐 - Javascript&quot; language=&quot;js&quot;&gt;
&lt;Github fname=&quot;index.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/index.js&quot;
start=&quot;69&quot; end=&quot;75&quot; /&gt;
&lt;Github fname=&quot;utils.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/near/utils.js&quot;
start=&quot;38&quot; end=&quot;42&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/develop/integrate/frontend">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Handling Data Types?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>When calling methods in a contract, or receiving results from them, you will need to correctly encode/decode parameters. For this, it is important to know how the contracts encode timestamps (u64) and money amounts (u128).</p>
<h5>Time</h5>
<p>The block timestamp in a smart contract is encoded using nanoseconds (i.e. 19 digits: <code>1655373910837593990</code>). In contrast, <code>Date.now()</code> from javascript returns a timestamp in milliseconds (i.e 13 digits: <code>1655373910837</code>). Make sure to convert between milliseconds and nanoseconds to properly handle time variables.</p>
<h5>Money</h5>
<p>Smart contracts speak in yocto NEAR, where 1Ⓝ = 10^24yocto, and the values are always encoded as <code>strings</code>.</p>
<ul>
<li>Convert from NEAR to yocto before sending it to the contract using <code>near-api-js.utils.format.parseNearAmount(amount.toString())</code>.</li>
<li>Convert a response in yoctoNEAR to NEAR using <code>near-api-js.utils.format.formatNearAmount(amount)</code></li>
</ul>
<p>If the contract returns a <code>Balance</code> instead of a <code>U128</code>, you will get a &quot;scientific notation&quot; <code>number</code> instead of a <code>string</code> (e.g. <code>10^6</code> instead of <code>&quot;1000000&quot;</code>). In this case, you can convert the value to NEAR by doing:</p>
<pre><code class="language-js">function formatAmount(amount) {
  let formatted = amount.toLocaleString('fullwide', { useGrouping: false })
  formatted = utils.format.formatNearAmount(formatted)
  return Math.floor(formatted * 100) / 100
}
</code></pre>
<p><a href="https://docs.near.org/develop/integrate/frontend">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the View Methods?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>View methods are those that perform <strong>read-only</strong> operations. Calling these methods is free, and do not require to specify which account is being used to make the call:</p>
<ul>
<li>method: <code>query</code></li>
<li>params:
<ul>
<li><code>request_type</code>: <code>call_function</code></li>
<li><a href="https://docs.near.org/develop/integrate/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/develop/integrate/api/rpc/setup#using-block_id-param"><code>block_id</code></a></li>
<li><code>account_id</code>: <em><code>&quot;example.testnet&quot;</code></em></li>
<li><code>method_name</code>: <code>name_of_a_example.testnet_method</code></li>
<li><code>args_base64</code>: <code>method_arguments_base_64_encoded</code>
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;query&quot;,
  &quot;params&quot;: {
    &quot;request_type&quot;: &quot;call_function&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;dev-1588039999690&quot;,
    &quot;method_name&quot;: &quot;get_num&quot;,
    &quot;args_base64&quot;: &quot;e30=&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.query({
  request_type: &quot;call_function&quot;,
  finality: &quot;final&quot;,
  account_id: &quot;dev-1588039999690&quot;,
  method_name: &quot;get_num&quot;,
  args_base64: &quot;e30=&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    &quot;request_type&quot;: &quot;call_function&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;dev-1588039999690&quot;,
    &quot;method_name&quot;: &quot;get_num&quot;,
    &quot;args_base64&quot;: &quot;e30=&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;result&quot;: [48],
    &quot;logs&quot;: [],
    &quot;block_height&quot;: 17817336,
    &quot;block_hash&quot;: &quot;4qkA4sUUG8opjH5Q9bL5mWJTnfR4ech879Db1BZXbx6P&quot;
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p><strong>Note</strong>: <code>[48]</code> is an array of bytes, to be specific it is an ASCII code of <code>0</code>.<code>near-sdk-rs</code> and <code>near-sdk-as</code> return JSON-serialized results.
&lt;/p&gt;
&lt;/details&gt;
info What could go wrong?
If you encounter a error please check <a href="https://docs.near.org/api/rpc/contracts#what-could-go-wrong">the RPC docs</a></p>
<p><a href="https://docs.near.org/develop/integrate/rpc">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Change Methods?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Change methods are those that perform both read and write operations. For these methods we do need to specify the account being used to make the call, since that account will expend GAS in the call.
Since calls to change methods need to be signed by an account, you will first need to create and sign the transaction that you want to send to the RPC.
For this, you currently need to make heavy use of <code>near-api-js</code>. Particularly, you need to:</p>
<ol>
<li>Create a transaction using the <code>near-api-js.transactions</code> module.</li>
<li>Sign the transaction using the <code>near-api-js.KeyStore.KeyPair</code></li>
<li>Send the signed transaction to the RPC.</li>
</ol>
<p><a href="https://docs.near.org/develop/integrate/rpc">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Create Transaction?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order yo create a transaction you will use <code>near-api-js.transactions.createTransaction</code> which takes as input:</p>
<ol>
<li><code>signerId</code>: the account ID of the transaction originator.</li>
<li><code>signerPublicKey</code>: the signer public key, see bellow.</li>
<li><code>receiverId</code>: the account ID of the transaction recipient.</li>
<li><code>nonceForPublicKey</code>: a unique number, see bellow</li>
<li><code>actions</code>: An <a href="https://docs.near.org/develop/integrate/../contracts/actions">action</a>, built from <code>near-api-js.transactions</code>.</li>
<li><a href="https://docs.near.org/develop/integrate/integrator/create-transactions#6-blockhash"><code>blockHash</code></a></li>
</ol>
<h4><code>signerPublicKey</code></h4>
<p>The public key of the signer must be encoded as an object with two key value pairs: keyType and data.
Here is one possible way to get it:</p>
<pre><code class="language-js">const privateKey = &quot;private-key-here&quot;;
const keyPair = nearAPI.utils.key_pair.KeyPairEd25519.fromString(privateKey);
const publicKey = keyPair.getPublicKey()
</code></pre>
<h4><code>nonceForPublicKey</code></h4>
<p>A unique number or <code>nonce</code> is required for each transaction signed with an access key. To ensure a unique number is created for each transaction, the current <code>nonce</code> should be queried and then incremented by 1.</p>
<pre><code class="language-js">const provider = new near-api-js.providers.JsonRpcProvider(
  `https://rpc.testnet.near.org`
);
const accessKey = await provider.query(
  `access_key/influencer.testnet/${publicKey.getPublicKey().toString()}`,
  &quot;&quot;
);
const nonce = accessKey.nonce + 1;
</code></pre>
<h4><code>blockHash</code></h4>
<p>Each transaction requires a current block hash (within 24hrs) to prove that the transaction was created recently. The hash must be converted to an array of bytes using the <code>base_decode</code> method found in <code>near-api-js</code>.</p>
<pre><code class="language-js">const recentBlockHash = near-api-js.utils.serialize.base_decode(
  accessKey.block_hash
);
</code></pre>
<p><a href="https://docs.near.org/develop/integrate/rpc">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Sign Transaction?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Now that the transaction is created, we sign it before sending it to the NEAR blockchain. At the lowest level, there are four steps to this process.</p>
<ol>
<li>Using <a href="https://docs.near.org/develop/integrate/integrator/create-transactions#imports"><code>nearAPI</code></a>, we call on <code>serialize()</code> to serialize the transaction in <a href="https://borsh.io/">Borsh</a>.</li>
</ol>
<pre><code class="language-js">const serializedTx = near-api-js.utils.serialize.serialize(
  nearAPI.transactions.SCHEMA,
  transaction
);
</code></pre>
<ol start="2">
<li>Hash the serialized transaction using a <code>sha256</code> cryptographic hashing algorithm.</li>
</ol>
<pre><code class="language-js">const serializedTxHash = new Uint8Array(sha256.sha256.array(serializedTx));
</code></pre>
<ol start="3">
<li>Create a signature with the <code>keyPair</code>.</li>
</ol>
<pre><code class="language-js">const signature = keyPair.sign(serializedTxHash);
</code></pre>
<ol start="4">
<li>Construct the signed transaction using <code>near-api-js</code> <a href="https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L112-L123">SignedTransaction class</a>.</li>
</ol>
<pre><code class="language-js">const signedTransaction = new nearAPI.transactions.SignedTransaction({
  transaction,
  signature: new nearAPI.transactions.Signature({
    keyType: transaction.publicKey.keyType,
    data: signature.signature,
  }),
});
</code></pre>
<p><a href="https://docs.near.org/develop/integrate/rpc#sign-transaction">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Node.js?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Download and install <a href="https://nodejs.org/en/download/">Node.js</a>. Then, install <code>yarn</code>: <code>npm install --global yarn</code>.</p>
<p><a href="https://docs.near.org/develop/prerequisites">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Rust and Wasm?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Follow <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">these instructions</a> for setting up Rust. Then, add the <code>wasm32-unknown-unknown</code> toolchain which enables compiling Rust to <a href="https://webassembly.org/">Web Assembly (wasm)</a>, the low-level language used by the NEAR platform.</p>
<h4>Linux and MacOS:</h4>
<pre><code class="language-bash"># Get rust
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
source $HOME/.cargo/env
# Add the wasm toolchain
rustup target add wasm32-unknown-unknown
</code></pre>
<p><a href="https://docs.near.org/develop/prerequisites">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Using Apple M1 Machine (arm64)?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The architecture of Apple M1 machines (<code>arm64</code>) has been released recently, and many of the libraries on which we rely are
still not supporting it. Because of this, you might find some error while trying to develop smart contract on such a platform.
Here we list some of the workarounds you will need in order to successfully build NEAR contracts.</p>
<h4>near-sdk-rs {#near-sdk-rs}</h4>
<p>If you're trying to build a Rust smart contract on an Apple M1 (<code>arm64</code>), you'll get an <code>unsupported platform</code> error such as:</p>
<pre><code class="language-text">npm ERR! code 1
npm ERR! path /Users/near/smart-contract/node_modules/near-vm
npm ERR! command failed
npm ERR! command sh -c node ./install.js
npm ERR! /Users/near/smart-contract/node_modules/near-vm/getBinary.js:17
npm ERR!     throw new Error(`Unsupported platform: ${type} ${arch}`);
npm ERR!     ^
npm ERR!
npm ERR! Error: Unsupported platform: Darwin arm64
</code></pre>
<p>You can solve it with <a href="https://t.me/neardev/13310">this workaround</a>:</p>
<pre><code class="language-sh">rustup target add x86_64-apple-darwin
rustup default stable-x86_64-apple-darwin
</code></pre>
<p>This will force Rust to compile to <code>x86</code>, and your Mac will execute the binary using Rosetta 2.</p>
<h4>near-sdk-as {#near-sdk-as}</h4>
<p>If you cannot install <code>near-sdk-as</code> and you get an <code>Unsupported platform: Darwin arm64</code> error while trying to build an AssemblyScript smart contract on an Apple M1 (<code>arm64</code>):</p>
<pre><code class="language-text">error /Users/near/guest-book/node_modules/near-vm: Command failed.
Exit code: 1
Command: node ./install.js
Arguments:
Directory: /Users/near/guest-book/node_modules/near-vm
Output:
/Users/near/guest-book/node_modules/near-vm/getBinary.js:17
    throw new Error(`Unsupported platform: ${type} ${arch}`);
    ^
Error: Unsupported platform: Darwin arm64
</code></pre>
<p>Use this command to install the dependencies without downloading the VM:</p>
<pre><code class="language-sh">npm install --save-dev --ignore-scripts near-sdk-as
</code></pre>
<p>info
If everything else installs correctly, you can disregard this error. You should still be able to build, deploy, and run the AS smart contract.</p>
<p><a href="https://docs.near.org/develop/prerequisites#building-smart-contracts-on-apple-m1-arm64">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to start building on NEAR?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You have two options to start Hello NEAR. The first and recommended is to use the app through Gitpod (a web-based interactive environment). The second option is to start the project locally by using <code>create-near-app</code>, our node-based utility.</p>
<p><a href="https://docs.near.org/develop/quickstart">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Gitpod?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><table>
<thead>
<tr>
<th>🦀 - Rust</th>
<th>🚀 - AssemblyScript</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;a href=&quot;https://gitpod.io/#https://github.com/near-examples/hello-near-rs.git&quot;&gt;&lt;img src=&quot;https://gitpod.io/button/open-in-gitpod.svg&quot; alt=&quot;Open in Gitpod&quot; /&gt;&lt;/a&gt;</td>
<td>&lt;a href=&quot;https://gitpod.io/#https://github.com/near-examples/hello-near-as.git&quot;&gt;&lt;img src=&quot;https://gitpod.io/button/open-in-gitpod.svg&quot; alt=&quot;Open in Gitpod&quot; /&gt;&lt;/a&gt;</td>
</tr>
<tr>
<td>A new browser window will open automatically with the code, give it a minute and the frontend will pop-up (make sure the pop-up window is not blocked).</td>
<td></td>
</tr>
</tbody>
</table>
<p><a href="https://docs.near.org/develop/quickstart">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Create Near App (node)?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>&lt;Tabs className=&quot;language-tabs&quot; groupId=&quot;code-tabs&quot;&gt;
&lt;TabItem value={0} label=&quot;🦀 - Rust&quot;&gt;</p>
<pre><code class="language-js">  npx create-near-app hello-near
  cd hello-near
  yarn &amp;&amp; yarn start
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value={1} label=&quot;🚀 - AssemblyScript&quot;&gt;</p>
<pre><code class="language-js">  npx create-near-app hello-near --contract=assemblyscript
  cd hello-near
  yarn &amp;&amp; yarn start
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
Your contract will be <strong>compiled</strong> and <strong>deployed</strong> to an <strong>account</strong> in the <code>testnet</code> network. When done, a browser window should open.</p>
<p><a href="https://docs.near.org/develop/quickstart">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Creating a DAO?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>To create a DAO you first need to deploy the <a href="https://github.com/near-daos/sputnik-dao-contract#setup">DAO contract factory</a>, and initialize it.
Once deployed and initialized, you can ask the factory to <code>create</code> a new DAO for you. On creation, you will define parameters such as the DAO's name, its purpose, and its council. Defining the right council is important since its members are the <strong>only</strong> accounts allowed to vote on proposals.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash"># 1. Deploy the contract in a testnet account
near dev-deploy &lt;factory-account&gt; --wasmFile=&lt;sputnikdao-factory&gt; --accountId &lt;your-account&gt;
# 2. Initialize factory contract
near call &lt;factory-account&gt; new --accountId  &lt;your-account&gt; --gas 100000000000000
# 3. Define a council and create DAO
export COUNCIL='[&quot;&lt;council-member-1&gt;&quot;, &quot;&lt;council-member-2&gt;&quot;]'
export ARGS=`echo '{&quot;config&quot;: {&quot;name&quot;: &quot;&lt;name&gt;&quot;, &quot;purpose&quot;: &quot;&lt;purpose&gt;&quot;, &quot;metadata&quot;:&quot;&lt;metadata&gt;&quot;}, &quot;policy&quot;: '$COUNCIL'}' | base64`
near call  &lt;factory-account&gt; create &quot;{\&quot;name\&quot;: \&quot;&lt;name&gt;\&quot;, \&quot;args\&quot;: \&quot;$ARGS\&quot;}&quot; --accountId &lt;your-account&gt; --amount 10 --gas 150000000000000
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/dao">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Voting policy?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Currently, the DAO supports two different types of <a href="https://github.com/near-daos/sputnik-dao-contract#voting-policy">voting policies</a>: <code>TokenWeight</code>, and <code>RoleWeight</code>.
When the vote policy is <code>TokenWeight</code>, the council votes using <a href="https://docs.near.org/develop/relevant-contracts/ft">tokens</a>. The weigh of a vote is the proportion of tokens used for voting over the token's total supply.
When the vote policy is <code>RoleWeight(role)</code>, the vote weigh is computed as &quot;one over the total number of people with the role&quot;.
Both voting policies further include a &quot;threshold&quot; for passing a proposal, which can be a ratio or a fixed number. The ratio indicates that you need a proportion of people/tokens to approve the proposal (e.g. half the people need to vote, and to vote positively). A fixed number indicated that you need a specific number of votes/tokens to pass the proposal (e.g. 3 people/tokens are enough to approve the proposal).</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/dao">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Adding a Proposal?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>By default, anyone can add a proposal to the DAO, but a minimum of 1Ⓝ needs to be attached as a bond. This however can be changed by <a href="https://github.com/near-daos/sputnik-dao-contract#roles-and-permissions">setting roles in the DAO</a>. The type of proposals that can be added <a href="https://github.com/near-daos/sputnik-dao-contract#proposal-types">is predefined</a>, and include actions such as:</p>
<ol>
<li>Adding a member to the council.</li>
<li>Calling a method in a smart contract.</li>
<li>Transferring NEAR or a FT to some account.
Each action has its own kind of arguments. The complete list of actions can be <a href="https://github.com/near-daos/sputnik-dao-contract#proposal-types">found here</a>.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</li>
</ol>
<pre><code class="language-bash">near call &lt;dao-account&gt; add_proposal \
'{&quot;proposal&quot;: {&quot;description&quot;: &quot;&lt;description&gt;&quot;, &quot;kind&quot;: {&quot;&lt;proposalKind&gt;&quot;: {&quot;&lt;argument&gt;&quot;: &quot;&lt;value&gt;&quot;, &quot;&lt;argument&gt;&quot;: &quot;&lt;value&gt;&quot;}}}}' \
--accountId proposer.testnet \
--amount 1
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/dao">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Acting on a Proposal?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Once a proposal is added, <strong>council members</strong> can act on them calling the <code>act_proposal</code> method. The available actions are one of the following: AddProposal, RemoveProposal, VoteApprove, VoteReject, VoteRemove, Finalize, or MoveToHub.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near call &lt;dao-account&gt; act_proposal '{&quot;id&quot;: &lt;proposal-id&gt;, &quot;action&quot;: &quot;&lt;action&gt;&quot;}' --accountId &lt;a-council-account-id&gt;
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
Each time somebody acts on the proposal, the DAO checks if the proposal has enough votes to be approved. If the proposal is approve, then the DAO executes the proposal (for example, adding a new member to the council).</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/dao">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to create a Fungible Token?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Creating a new FT is as simple as deploying a new FT contract and initializing it. On initialization you will define the token's metadata such as its name (e.g. Ethereum), symbol (e.g. ETH) and total supply (e.g. 10M). You will also define an <code>owner</code>, which will own the tokens <strong>total supply</strong>.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash"># 1. Deploy the contract in a testnet account
near dev-deploy --wasmFile fungible_token.wasm
# 2. Initialize the contract with metadata
near call &lt;ft-contract&gt; new '{&quot;owner_id&quot;: &quot;&lt;owner-account&gt;&quot;, &quot;total_supply&quot;: &quot;1000000000000000&quot;, &quot;metadata&quot;: { &quot;spec&quot;: &quot;ft-1.0.0&quot;, &quot;name&quot;: &quot;Example Token Name&quot;, &quot;symbol&quot;: &quot;EXLT&quot;, &quot;decimals&quot;: 8 }}' --accountId &lt;ft-contract&gt;
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
info
On initialization you will define an <strong>owner</strong>, who will own <strong>ALL</strong> the tokens.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/ft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to query FT metadata?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can query the FT's metadata by calling the <code>ft_metadata</code>.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near view &lt;ft-contract&gt; ft_metadata
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/ft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to register a User in FT?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order for a user to own and transfer tokens they need to first <strong>register</strong> in the contract. This is done by calling <code>storage_deposit</code> and attaching 0.00125Ⓝ. This method also allows to pay for other users to register them.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near call &lt;ft-contract&gt; storage_deposit '{&quot;account_id&quot;: &quot;&lt;account-to-register&gt;&quot;}' --accountId &lt;your-account&gt; --amount 0.00125
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
info
You can make sure a user is registered by asserting they have a <code>storage_balance_of</code> greater than 0.00125 Ⓝ.</p>
<p>After you call the <code>storage_deposit</code> the FT will appear in the NEAR WALLET.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/ft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Hot to get FT balance?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>To know how many coins a user has you will need to query the method <code>ft_balance_of</code>.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near view &lt;ft-contract&gt; ft_balance_of '{&quot;account_id&quot;: &quot;&lt;users-account&gt;&quot;}'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
caution
Keep in mind the <code>decimals</code> from the <a href="https://docs.near.org/develop/relevant-contracts/#query-metadata">metadata</a>. A balance of <code>150 FT</code> for a token with 2 <code>decimals</code> actually represents <code>1.50 FT</code>.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/ft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Transferring?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>To send FT to another account you will use the <code>ft_transfer</code> method, indicating the receiver and the amount of FT you want to send.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near call &lt;ft-contract&gt; ft_transfer '{&quot;receiver_id&quot;: &quot;&lt;receiver-account&gt;&quot;, &quot;amount&quot;: &quot;&lt;amount&gt;&quot;}' --accountId &lt;your-account&gt; --depositYocto 1
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p>Implement <a href="https://nomicon.io/Standards/Tokens/FungibleToken/Event">events</a> to be able to <a href="https://docs.near.org/tools/events">track FT transfers in real time</a>.</p>
<p>warning
In order to send a fungible token to an account, both the sender and receiver must be <a href="https://docs.near.org/develop/relevant-contracts/#register-a-user">registered</a> in the FT contract.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/ft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to attach FT to a Call?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Natively, only NEAR tokens (Ⓝ) can be attached to a method calls. However, the FT standard enables to attach fungible tokens in a call by using the FT-contract as intermediary. This means that, instead of you attaching tokens directly to the call, you ask the FT-contract to do both a transfer and a method call in your name.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near call &lt;ft-contract&gt; ft_transfer_call '{&quot;receiver_id&quot;: &quot;&lt;receiver-contract&gt;&quot;, &quot;amount&quot;: &quot;&lt;amount&gt;&quot;, &quot;msg&quot;: &quot;&lt;a-string-message&gt;&quot;}' --accountId &lt;user_account_id&gt; --depositYocto 1
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<h4>Example</h4>
<p>Assume you want to attach some FT (🪙) to a call on the receiver contract. The workflow is as follows:</p>
<ol>
<li>You call <code>ft_transfer_call</code> in the 🪙-contract passing: the receiver, a message, and the amount.</li>
<li>The FT contract transfers the amount to the receiver.</li>
<li>The FT contract calls <strong><code>receiver.ft_on_transfer(sender, msg, amount)</code></strong>.</li>
<li>The FT contract handles errors in the <code>ft_resolve_transfer</code> callback.</li>
<li>The FT contract returns you how much of the attached amount was actually used.</li>
</ol>
<h4>The ft_on_transfer method</h4>
<p>From the workflow above it follows that the receiver we want to call needs to implement the <code>ft_on_transfer</code> method. When executed, such method will know:</p>
<ul>
<li>Which FT was transferred, since it is the <a href="https://docs.near.org/develop/relevant-contracts/../contracts/environment/environment#predecessor-and-signer"><code>predecessor</code></a> account.</li>
<li>Who is sending the FT, since it is a parameter</li>
<li>How many FT were transferred, since it is a parameter</li>
<li>If there are any parameters encoded as a message
The <code>ft_on_transfer</code> <strong>must return how many FT tokens it used</strong>, so the FT contract knows how many to transfer you back.</li>
</ul>
<p><a href="https://docs.near.org/develop/relevant-contracts/ft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to track events?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can track real time events (such as transfers) by implementing the <a href="https://nomicon.io/Standards/Tokens/FungibleToken/Event">FT Event Standards</a>.
<code>Events</code> are simple to use, because they are just login messages formatted in a standardize way. Since these logged messages are public, a service
can then be built to <a href="https://docs.near.org/tools/events">track them in real time</a>.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/ft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to mint an NFT?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order to create a new NFT (a.k.a. mint it) you need first to deploy an <a href="https://github.com/near-examples/NFT">NFT contract</a> and initialize it with an <code>owner</code>. Currently, the <code>owner</code> simply sets an internal variable (<code>Contract.owner_id</code>), meaning it is <strong>NOT the default owner</strong> of all minted NFTs.
Once deployed and initialized, you can call the <code>nft_mint</code> method. You will need to pass as parameters a unique id, an owner, the token's metadata, and (optionally) royalties. The metadata will include information such as the title, a description, and an URL to associated media.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash"># 1. Deploy the contract in a testnet account
near dev-deploy --wasmFile non_fungible_token.wasm
# 2. Initialize NFT contract
# 3. Mint an NFT
near call &lt;nft-contract&gt; nft_mint '{&quot;token_id&quot;: &quot;&lt;token-unique-id&gt;&quot;, &quot;receiver_id&quot;: &quot;&lt;nft-owner-account&gt;&quot;, &quot;token_metadata&quot;: {&quot;title&quot;: &quot;&lt;title&gt;&quot;, &quot;description&quot;: &quot;&lt;description&gt;&quot;, &quot;media&quot;: &quot;&lt;url&gt;&quot; }, &quot;royalties&quot;: {&quot;&lt;account&gt;&quot; : &lt;percentage&gt;, &quot;&lt;account&gt;&quot; : &lt;percentage&gt;}}' --accountId &lt;your-account&gt;
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
info
See the <a href="https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata">metadata standard</a> for the full list of <code>TokenMetadata</code> parameters.</p>
<p>Implement <a href="https://nomicon.io/Standards/Tokens/NonFungibleToken/Event">events</a> to be able to <a href="https://docs.near.org/tools/events">track NFT mints in real time</a>.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/nft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to mint an NFT collections?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Many times people want to create multiple 100 copies of an NFT (this is called a collection). In such cases, what you actually need to do is to mint 100 different NFTs with the same metadata (but different <code>token-id</code>).</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/nft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are NFT royalties?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You might have noticed that one of the parameters is a structure called royalties. Royalties enable you to create a list of users that should get paid when the token is sell in a marketplace. For example, if <code>anna</code> has <code>5%</code> of royalties, each time the NFT is sell, <code>anna</code> should get a 5% of the selling price.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/nft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to approve users in NFT contact?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can authorize other users to transfer an NFT you own. This is useful, for example, to enable listing your NFT in a marketplace. In such scenario, you <strong>trust</strong> that the marketplace will only transfer the NFT upon receiving a certain amount of money in exchange.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near call &lt;nft-contract&gt; nft_approve '{
 &quot;token_id&quot;: &quot;&lt;token-unique-id&gt;&quot;,
 &quot;account_id&quot;: &quot;&lt;authorized-account&gt;&quot;,
 &quot;msg&quot;: &quot;&lt;json-structure&gt;&quot;
}' --accountId &lt;your-account&gt; --depositYocto 1
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
info
If the <code>msg</code> parameter is included, then a cross-contract call will be made to <code>&lt;authorized_account&gt;.nft_on_approve(msg)</code>. Which in turn will make a callback to <code>nft_resolve_transfer</code> in your NFT contract.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/nft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to transfer an NFT?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Transferring an NFT can happen in two scenarios: (1) you ask to transfer an NFT, and (2) an authorized account asks to transfer the NFT. In both cases, it is necessary to invoke the <code>nft_transfer</code> method, indicating the token id, the receiver, and an (optionally) an <a href="https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement">approval_id</a>.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near call &lt;nft-contract&gt; nft_transfer '{&quot;receiver_id&quot;: &quot;&lt;receiver-account&gt;&quot;, &quot;token_id&quot;: &quot;&lt;token-unique-id&gt;&quot;}' --accountId &lt;your-account&gt; --depositYocto 1
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p>Implement <a href="https://nomicon.io/Standards/Tokens/NonFungibleToken/Event">events</a> to be able to <a href="https://docs.near.org/tools/events">track NFT transfers in real time</a>.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/nft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How to attach NFTs to a Call?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Natively, only NEAR tokens (Ⓝ) can be attached to a method calls. However, the NFT standard enables to attach a non-fungible tokens in a call by using the NFT-contract as intermediary. This means that, instead of you attaching tokens directly to the call, you ask the NFT-contract to do both a transfer and a method call in your name.
&lt;Tabs className=&quot;language-tabs&quot;&gt;
&lt;TabItem value=&quot;cli&quot; label=&quot;NEAR CLI&quot;&gt;</p>
<pre><code class="language-bash">near call &lt;nft-contract&gt; nft_transfer_call '{&quot;receiver_id&quot;: &quot;&lt;receiver-contract&gt;&quot;, &quot;token_id&quot;: &quot;&lt;token_id&gt;&quot;, &quot;msg&quot;: &quot;&lt;a-string-message&gt;&quot;}' --accountId &lt;your-account&gt; --depositYocto 1
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
info
Optionally, a <a href="https://nomicon.io/Standards/Tokens/NonFungibleToken/Core#nft-interface"><code>memo</code> parameter</a> can be passed to provide more information to your contract.</p>
<p><a href="https://docs.near.org/develop/relevant-contracts/nft">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the NEAR Workspaces?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In NEAR, integration tests are implemented using a framework called <strong>Workspaces</strong>. Workspaces comes in two flavors: <a href="https://github.com/near/workspaces-rs">🦀 Rust</a> and <a href="https://github.com/near/workspaces-js">🌐 Typescript</a>.
If you used one of our <a href="https://github.com/near-examples/docs-examples">examples</a> as template, then integration testing using workspaces is already implemented, and you simply need to run <code>yarn test:integration</code> from the project's root folder.</p>
<p><a href="https://docs.near.org/develop/testing/integration">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Programming Languages?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Smart Contracts in the NEAR blockchain are encoded using <a href="https://webassembly.org/">WebAssembly</a>. However, you don't need to write WebAssembly, instead, you can use high-level languages such as Rust and AssemblyScript, which then get compiled to Web Assembly.
While it is not necessary to be an expert in either language, during these docs we will assume you have a basic knowledge of at least one of them. If you never used any we recommend you to start <a href="https://doc.rust-lang.org/book/title-page.html">here with Rust</a> and <a href="https://www.assemblyscript.org/introduction.html">here with AssemblyScript</a>.</p>
<p><a href="https://docs.near.org/develop/whatiscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Rust?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Rust is a programming language designed for performance and safety. It is syntactically similar to C++, but can guarantee memory safety without resorting to garbage collection. Rust has proven to be a mature and secure language, which makes it ideal to write smart contracts. Because of this, <strong>Rust is the preferred programming language for writing smart contracts on NEAR</strong>. While there might be a learning curve for those coming from web development, learning Rust enables to write safer and faster contracts. Furthermore, core contracts such as Fungible Tokens and DAOs are currently only available in Rust.</p>
<p><a href="https://docs.near.org/develop/whatiscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the AssemblyScript?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><a href="https://www.assemblyscript.org/">AssemblyScript</a> is a dialect of TypeScript programming language that compiles to WebAssembly. The syntax resembles JavaScript, but with strict and static typing. One can think of it as a mix of TypeScript's high level syntax and C's low-level capabilities. Thanks to this, the resulting WebAssembly modules can profit from predictable performance while guaranteeing a small binary size. However, this comes with the tradeoff of having to strictly type all variables and structures, and therefore not having <code>any</code>, <code>union</code> types or <code>undefined</code> variables.
caution
Because of its maturity and safety features, we strongly recommend to use Rust when writing financial contracts.</p>
<p><a href="https://docs.near.org/develop/whatiscontract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Starting the Donation Example?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You have two options to start the Donation Example. The first and recommended is to use the app through Gitpod, which will open a web-based interactive environment. The second option is to clone the repository locally, for which you will need to install all the <a href="https://docs.near.org/develop/prerequisites">Prerequisites</a>.
&lt;Tabs className=&quot;language-tabs&quot; groupId=&quot;code-tabs&quot;&gt;
&lt;TabItem value={0} label=&quot;🦀 - Rust&quot;&gt;</p>
<table>
<thead>
<tr>
<th>Gitpod</th>
<th>Clone locally</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;a href=&quot;https://gitpod.io/#https://github.com/near-examples/docs-examples/blob/main/donation-rs&quot;&gt;&lt;img src=&quot;https://gitpod.io/button/open-in-gitpod.svg&quot; alt=&quot;Open in Gitpod&quot; /&gt;&lt;/a&gt;</td>
<td>🦀 <code>https://github.com/near-examples/docs-examples</code> -&gt; donation-rs</td>
</tr>
<tr>
<td>&lt;/TabItem&gt;</td>
<td></td>
</tr>
<tr>
<td>&lt;TabItem value={1} label=&quot;🚀 - AssemblyScript&quot;&gt;</td>
<td></td>
</tr>
<tr>
<td>Gitpod</td>
<td>Clone locally</td>
</tr>
<tr>
<td>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</td>
<td>-----------------------------------------------------------------</td>
</tr>
<tr>
<td>&lt;a href=&quot;https://gitpod.io/#https://github.com/near-examples/docs-examples/blob/main/donation-as&quot;&gt;&lt;img src=&quot;https://gitpod.io/button/open-in-gitpod.svg&quot; alt=&quot;Open in Gitpod&quot; /&gt;&lt;/a&gt;</td>
<td>🚀 <code>https://github.com/near-examples/docs-examples</code> -&gt; donation-as</td>
</tr>
<tr>
<td>&lt;/TabItem&gt;</td>
<td></td>
</tr>
<tr>
<td>&lt;/Tabs&gt;</td>
<td></td>
</tr>
<tr>
<td>If you choose Gitpod a new browser window will open automatically with the code. Navigate to the <code>donation-as</code> or <code>donation-rs</code> folder and use <code>yarn</code> and <code>yarn start</code>.</td>
<td></td>
</tr>
<tr>
<td>The project will compile and eventually the frontend will open in a new window/tab (make sure the pop-up window is not blocked). If you are running the app locally, enter the directory where you cloned it and use <code>yarn</code> to install dependencies, and <code>yarn start</code> to start it.</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-bash">cd counter
yarn
yarn start
</code></pre>
<p>Your contract will then be <strong>compiled</strong> and <strong>deployed</strong> to an <strong>account</strong> in the <code>testnet</code> network. When done, a browser window should open.</p>
<p><a href="https://docs.near.org/tutorials/examples/donation">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Interacting With the dApp?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in, input the amount of NEAR you want
to donate and press the donate button. You will be redirected to the NEAR Wallet to confirm the transaction. After confirming it, the donation will be listed
in the &quot;Latest Donations&quot;.
<img src="https://docs.near.org/docs/assets/examples/donation.png" alt="img">
<em>Frontend of the Donation App</em></p>
<p><a href="https://docs.near.org/tutorials/examples/donation">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Structure of a dApp?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Now that you understand what the dApp does, let us take a closer look to its structure:</p>
<ol>
<li>The frontend code lives in the <code>/frontend</code> folder.</li>
<li>The smart contract code is in the <code>/contract</code> folder.</li>
<li>The compiled smart contract can be found in <code>/out/main.wasm</code>.</li>
<li>The account's name in which the contract was deployed is in <code>/neardev/dev-account</code>.</li>
</ol>
<p><a href="https://docs.near.org/tutorials/examples/donation">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The contract exposes methods to donate money (<code>donate</code>), and methods to retrieve the recorded donations (e.g. <code>get_donation_by_number</code>).
&lt;CodeTabs&gt;
&lt;Language value=&quot;🦀 - Rust&quot; language=&quot;rust&quot;&gt;
&lt;Github fname=&quot;lib.rs&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/contract/src/lib.rs&quot;
start=&quot;19&quot; end=&quot;44&quot; /&gt;
&lt;/Language&gt;
&lt;Language value=&quot;🚀 - AssemblyScript&quot; language=&quot;ts&quot;&gt;
&lt;Github fname=&quot;index.ts&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-as/contract/assembly/index.ts&quot;
start=&quot;11&quot; end=&quot;34&quot;/&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/tutorials/examples/donation">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Frontend?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The frontend is composed by a single HTML file (<code>/index.html</code>). This file defines the components displayed in the screen.
The website's logic lives in <code>/assets/js/index.js</code>, which communicates with the contract through <code>/assets/js/near/utils.js</code>.
An interesting aspect of the donation example is that it showcases how to retrieve a result after being redirected to the
NEAR wallet to accept a transaction.
&lt;CodeTabs&gt;
&lt;Language value=&quot;🌐 - Javascript&quot; language=&quot;js&quot;&gt;
&lt;Github fname=&quot;index.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/index.js&quot;
start=&quot;68&quot; end=&quot;74&quot; /&gt;
&lt;Github fname=&quot;near/utils.js&quot;
url=&quot;https://github.com/near-examples/docs-examples/blob/main/donation-rs/frontend/assets/js/near/utils.js&quot;
start=&quot;38&quot; end=&quot;41&quot; /&gt;
&lt;/Language&gt;
&lt;/CodeTabs&gt;</p>
<p><a href="https://docs.near.org/tutorials/examples/donation">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Starting the Project?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You have two options to start using the project. The first and recommended is to use the app through Gitpod, which will open a web-based interactive environment. The second option is to clone the repository locally, for which you will need to install all the <a href="https://docs.near.org/develop/prerequisites">Prerequisites</a>.
&lt;Tabs className=&quot;language-tabs&quot; groupId=&quot;code-tabs&quot;&gt;
&lt;TabItem value={1} label=&quot;🚀 - AssemblyScript&quot;&gt;</p>
<table>
<thead>
<tr>
<th>Gitpod</th>
<th>Clone locally</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;a href=&quot;https://gitpod.io/#https://github.com/near-examples/guest-book.git&quot;&gt;&lt;img src=&quot;https://gitpod.io/button/open-in-gitpod.svg&quot; alt=&quot;Open in Gitpod&quot; /&gt;&lt;/a&gt;</td>
<td>🚀 <code>https://github.com/near-examples/guest-book</code></td>
</tr>
<tr>
<td>&lt;/TabItem&gt;</td>
<td></td>
</tr>
<tr>
<td>&lt;TabItem value={0} label=&quot;🦀 - Rust&quot;&gt;</td>
<td></td>
</tr>
<tr>
<td>Gitpod</td>
<td>Clone locally</td>
</tr>
<tr>
<td>-------------------</td>
<td>---------------------</td>
</tr>
<tr>
<td>Not Implemented yet</td>
<td>🦀 Not Implemented yet</td>
</tr>
<tr>
<td>&lt;/TabItem&gt;</td>
<td></td>
</tr>
<tr>
<td>&lt;/Tabs&gt;</td>
<td></td>
</tr>
<tr>
<td>If you choose Gitpod a new browser window will open automatically with the code, give it a minute and the frontend will pop-up (make sure the pop-up window is not blocked). If you are running the app locally, enter the directory where you cloned it and use <code>yarn</code> to install dependencies, and <code>yarn start</code> to start it.</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-bash">cd counter
yarn
yarn start
</code></pre>
<p>Your contract will then be <strong>compiled</strong> and <strong>deployed</strong> to an <strong>account</strong> in the <code>testnet</code> network. When done, a browser window should open.</p>
<p><a href="https://docs.near.org/tutorials/examples/guest-book">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Interacting With the Guest Book?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><img src="https://docs.near.org/docs/assets/examples/guest-book.png" alt="img">
<em>Frontend of the Guest Book app</em>
Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in,
you will be able to sign a message in the guest book. You can further send some money alongside your message. If you attach
more than 0.01Ⓝ then your message will be marked as &quot;premium&quot;.</p>
<p><a href="https://docs.near.org/tutorials/examples/guest-book">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Interacting with the Project?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Since this example does not have a frontend, we will interact with it through the <a href="https://docs.near.org/develop/integrate/cli">NEAR CLI</a>.
&lt;Tabs className=&quot;language-tabs&quot; groupId=&quot;code-tabs&quot;&gt;
&lt;TabItem value={0} label=&quot;🦀 - Rust&quot;&gt;</p>
<table>
<thead>
<tr>
<th>Gitpod</th>
<th>Clone locally</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;a href=&quot;https://gitpod.io/#https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-rs&quot;&gt;&lt;img src=&quot;https://gitpod.io/button/open-in-gitpod.svg&quot; alt=&quot;Open in Gitpod&quot; /&gt;&lt;/a&gt;</td>
<td>🦀 <code>https://github.com/near-examples/docs-examples</code> -&gt; cross-contract-hello-rs</td>
</tr>
<tr>
<td>&lt;/TabItem&gt;</td>
<td></td>
</tr>
<tr>
<td>&lt;TabItem value={1} label=&quot;🚀 - AssemblyScript&quot;&gt;</td>
<td></td>
</tr>
<tr>
<td>Gitpod</td>
<td>Clone locally</td>
</tr>
<tr>
<td>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</td>
<td>-----------------------------------------------------------------------------</td>
</tr>
<tr>
<td>&lt;a href=&quot;https://gitpod.io/#https://github.com/near-examples/docs-examples/blob/main/cross-contract-hello-as&quot;&gt;&lt;img src=&quot;https://gitpod.io/button/open-in-gitpod.svg&quot; alt=&quot;Open in Gitpod&quot; /&gt;&lt;/a&gt;</td>
<td>🚀 <code>https://github.com/near-examples/docs-examples</code> -&gt; cross-contract-hello-as</td>
</tr>
<tr>
<td>&lt;/TabItem&gt;</td>
<td></td>
</tr>
<tr>
<td>&lt;/Tabs&gt;</td>
<td></td>
</tr>
<tr>
<td>&lt;!-- Expand on this explanation adding snippets  --&gt;</td>
<td></td>
</tr>
<tr>
<td>To try the project you will need to:</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>Deploy the Hello NEAR contract. A compiled version is available in <code>/test/aux_contracts/hello-near.wasm</code>.</li>
<li>Deploy the Cross Contract Example. A compiled version is available in <code>/out/main.wasm</code>.</li>
<li>Initialize the cross-contract example using the account's address of the <code>hello-near</code> contract deployed in (1).</li>
<li>Call <code>set_greeting</code> and <code>get_greeting</code> in the cross-contract example.</li>
</ol>
<p><a href="https://docs.near.org/tutorials/examples/xcc">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Structure of the Project?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The project is organized as follows:</p>
<ol>
<li>The smart contract code is in the <code>/contract</code> folder.</li>
<li>The compiled smart contract can be found in <code>/out/main.wasm</code>.</li>
<li>A compiled <code>Hello NEAR</code> contract can be found in <code>/test/aux_contracts/hello-near.wasm</code>.</li>
</ol>
<p><a href="https://docs.near.org/tutorials/examples/xcc">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the App Overview?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The app is fairly simple: the user signs in and hits the &lt;kbd&gt;Mint NFT&lt;/kbd&gt; button. Once the user hits the mint button, a &quot;Go Team&quot; NFT is minted and sent to their NEAR Wallet.
<img src="https://docs.near.org/docs/assets/nfts/nft-mint-frontend.png" alt="Front-end"></p>
<p><a href="https://docs.near.org/tutorials/nfts/simple-nft-minting-example">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Smart Contract code?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The code for the NFT smart contract can be found in the <a href="https://docs.near.org/tutorials/nfts/tutorials/nfts/introduction">Zero to Hero NFT tutorial</a>'s  <a href="https://github.com/near-examples/nft-tutorial/tree/main/nft-contract/src">GitHub repository</a>, under the <code>main</code> branch.
The contract methods used in this application are as follows:</p>
<ul>
<li><code>nft_mint</code>: Function used to mint tokens.</li>
<li><code>check_token</code>: Custom function created to check for the existence of a token. This helps to ensure one token per user.</li>
</ul>
<p><a href="https://docs.near.org/tutorials/nfts/simple-nft-minting-example">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Front-end?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The front-end of the contract was implemented using <code>create-near-app</code>. <a href="https://react-bootstrap.github.io/">React Bootstrap</a> was used for the styling of the application.
To bootstrap your React front-end, run the following command on your terminal:</p>
<pre><code class="language-sh">npx create-near-app --frontend react --contract rust
</code></pre>
<p>Then, simply import the contract files from the <code>main</code> branch, and you'll have the needed structure to run the application.</p>
<p><a href="https://docs.near.org/tutorials/nfts/simple-nft-minting-example">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Start?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Upon mounting the application's components, the app checks for the existence of a non-fungible token.</p>
<pre><code class="language-js">https://github.com/near-examples/nft-tutorial-frontend/blob/master/src/App.js#L24-L46
</code></pre>
<p>If no prior NFT has been minted, the mint button will be available for use.</p>
<p><a href="https://docs.near.org/tutorials/nfts/simple-nft-minting-example">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Mint button?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Here is the function behind the mint button. The meta data has been filled out for the user already:</p>
<ul>
<li><code>token_id</code> is set by the user's account id,</li>
<li>and the <code>media</code> link is hard-coded to a <code>goteam-gif.gif</code> hosted on IPFS.</li>
</ul>
<pre><code class="language-js">https://github.com/near-examples/nft-tutorial-frontend/blob/master/src/Components/MintingTool.js#L7-L23
</code></pre>
<p>After hitting the &lt;kbd&gt;Mint NFT&lt;/kbd&gt; button the user will be able to check out the newly minted NFT at <a href="https://wallet.testnet.near.org/?tab=collectibles">wallet.testnet.near.org</a>, under the Wallet's <code>Collectibles</code> tab.</p>
<p><a href="https://docs.near.org/tutorials/nfts/simple-nft-minting-example">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Examples?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><table>
<thead>
<tr>
<th>Title</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.near.org/tutorials/examples/hello-near">👋 Hello NEAR</a></td>
<td><strong>Hello NEAR</strong> is a friendly decentralized App that stores a greeting message. It is one of the simplest contracts you can create, and the perfect gateway to introduce yourself in the world of smart contracts.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/tutorials/examples/count-near">🧮 Count on NEAR</a></td>
<td><strong>Count on NEAR</strong> is a decentralized app that stores a simple counter, enabling to increment, decrement and reset it.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/tutorials/examples/guest-book">📖 Guest Book</a></td>
<td>The <strong>Guest Book</strong> is a simple app that stores messages from users, allowing to attach money to them.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/tutorials/examples/donation">🙏 Donation</a></td>
<td>Our <strong>Donation</strong> example enables to forward money to an account while keeping track of it.  It is one of the simplest examples on making a contract receive and send money.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/tutorials/examples/xcc">📞 Cross-Contract Call</a></td>
<td>This example performs the simplest <strong>cross-contract</strong> call possible: it calls our <a href="https://docs.near.org/tutorials/examples/hello-near">Hello NEAR</a> example to set and retrieve a greeting. It is the perfect gateway to the world of interoperative contracts.</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.near.org/tutorials/welcome">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the NEP-297 - Events?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In NEAR, <code>Events</code> use the standard logs capability of contracts, since every log is forever stored in the blockchain. In this way,
Events are normal log entries that start with the <code>EVENT_JSON:</code> prefix, followed by a single valid JSON string. The JSON string
must codify an object with the following interface:</p>
<pre><code class="language-ts">interface EventLogData {
    standard: string, // name of standard, e.g. nep171
    version: string, // e.g. 1.0.0
    event: string, // type of the event, e.g. nft_mint
    data?: unknown, // event data defined in the nep171
}
</code></pre>
<p>See the <a href="https://nomicon.io/Standards/EventsFormat">NEP-297 page</a> for examples.
warning
There is a known limitation of 16kb strings when capturing logs</p>
<p><a href="https://docs.near.org/tools/events">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the NEAR Explorer?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Created by NEAR, the <a href="https://explorer.near.org">Near Explorer</a> enables to check information for transactions and accounts through a user-friendly interface.
<img src="https://docs.near.org/docs/assets/explorers/near-explorer.png" alt="NEAR Explorer">
<em>Main page of <a href="https://explorer.near.org">NEAR Explorer</a></em></p>
<p><a href="https://docs.near.org/tools/explorer">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Stats Gallery?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Created by the community, <a href="https://stats.gallery">Stats Gallery</a> gamifies the experience of looking to an account, adding levels and badges based on the account's activity. One of its
best features is that it allows you to see the contract's methods.
<img src="https://docs.near.org/docs/assets/explorers/stats-gallery.png" alt="Stats Gallery">
<em>Account view in <a href="https://stats.gallery">Stats Gallery</a></em></p>
<p><a href="https://docs.near.org/tools/explorer">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Connecting to the Database?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can use any database manager compatible with PostgreSQL. If you don't know any, we can recommend you to try <a href="https://dbeaver.io/">DBeaver Community</a>.</p>
<table>
<thead>
<tr>
<th>Network</th>
<th>Host</th>
<th>Port</th>
<th>Database</th>
<th>Username</th>
<th>Password</th>
</tr>
</thead>
<tbody>
<tr>
<td>mainnet</td>
<td>mainnet.db.explorer.indexer.near.dev</td>
<td>5432</td>
<td>mainnet_explorer</td>
<td>public_readonly</td>
<td>nearprotocol</td>
</tr>
<tr>
<td>testnet</td>
<td>testnet.db.explorer.indexer.near.dev</td>
<td>5432</td>
<td>testnet_explorer</td>
<td>public_readonly</td>
<td>nearprotocol</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.near.org/tools/indexer4explorer">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Database Structure?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Please bear in mind that the structure might evolve or change with time.
<a href="https://raw.githubusercontent.com/near/near-indexer-for-explorer/master/docs/near-indexer-for-explorer-db.png"><img src="https://raw.githubusercontent.com/near/near-indexer-for-explorer/master/docs/near-indexer-for-explorer-db.png" alt="structure_img"></a></p>
<p><a href="https://docs.near.org/tools/indexer4explorer">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Transactions Calling a Method?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Query for all transaction that called <code>contribute</code> in the <code>v1.faucet.nonofficial.testnet</code> testnet account.</p>
<pre><code class="language-sql">select r.predecessor_account_id, t.transaction_hash 
from receipts r, action_receipt_actions ara, transactions t
where r.receiver_account_id ='v1.faucet.nonofficial.testnet'
  and ara.receipt_id = r.receipt_id
  and ara.action_kind = 'FUNCTION_CALL'
  and ara.args @&gt; '{&quot;method_name&quot;: &quot;contribute&quot;}'
  and t.transaction_hash = r.originated_from_transaction_hash
</code></pre>
<p><a href="https://docs.near.org/tools/indexer4explorer">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Users, Status and Attached Money?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Query for all users that called <code>contribute</code> in <code>v1.faucet.nonofficial.testnet</code>, how much they attached to the call, and the transaction status.</p>
<pre><code class="language-sql">select t.transaction_hash, eo.status, r.predecessor_account_id , ara.args -&gt; 'deposit' as deposit
from receipts r, action_receipt_actions ara, transactions t, execution_outcomes eo
where r.receiver_account_id ='v1.faucet.nonofficial.testnet'
  and ara.receipt_id = r.receipt_id and ara.action_kind = 'FUNCTION_CALL'
  and ara.args @&gt; '{&quot;method_name&quot;: &quot;contribute&quot;}'
  and t.transaction_hash = r.originated_from_transaction_hash
  and r.receipt_id = eo.receipt_id
</code></pre>
<p><a href="https://docs.near.org/tools/indexer4explorer">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Sent Money?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Query for all the transfers going out from <code>v1.faucet.nonofficial.testnet</code>.</p>
<pre><code class="language-sql">select r.receiver_account_id, ara.args -&gt; 'deposit' as deposit	
from receipts r, action_receipt_actions ara
where r.predecessor_account_id  ='v1.faucet.nonofficial.testnet'
  and ara.receipt_id = r.receipt_id and ara.action_kind = 'TRANSFER'
</code></pre>
<p><a href="https://docs.near.org/tools/indexer4explorer">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Can I use <code>near-api-js</code> on a static html page?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Yes! See examples below:</p>
<pre><code class="language-html">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/near-api-js@0.41.0/dist/near-api-js.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>&lt;details&gt;
&lt;summary&gt;<strong>Example Implementation:</strong> &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt;
  &lt;textarea id=&quot;text&quot; placeholder=&quot;Add Message&quot;&gt;&lt;/textarea&gt;
  &lt;button id=&quot;add-text&quot;&gt;Add Text&lt;/button&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/near-api-js@0.41.0/dist/near-api-js.min.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    // connect to NEAR
    const near = new nearApi.Near({
      keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      walletUrl: 'https://wallet.testnet.near.org'
    });
    
    // connect to the NEAR Wallet
    const wallet = new nearApi.WalletConnection(near, 'my-app');
    // connect to a NEAR smart contract
    const contract = new nearApi.Contract(wallet.account(), 'guest-book.testnet', {
      viewMethods: ['getMessages'],
      changeMethods: ['addMessage']
    });
    const button = document.getElementById('add-text');
    if (!wallet.isSignedIn()) {
      button.textContent = 'SignIn with NEAR'
    }
    // call the getMessages view method
    contract.getMessages()
      .then(messages =&gt; {
        const ul = document.getElementById('messages');
        messages.forEach(message =&gt; {
          const li = document.createElement('li');
          li.textContent = `${message.sender} - ${message.text}`;
          ul.appendChild(li);
        })
      });
    // Either sign in or call the addMessage change method on button click
    document.getElementById('add-text').addEventListener('click', () =&gt; {
      if (wallet.isSignedIn()) {
        contract.addMessage({
          args: { text: document.getElementById('text').value },
          amount: nearApi.utils.format.parseNearAmount('1')
        })
      } else {
        wallet.requestSignIn({
          contractId: 'guest-book.testnet',
          methodNames: ['getMessages', 'addMessage']
        });
      }
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<p><a href="https://docs.near.org/tools/near-api-js/faq#can-i-use-near-api-js-on-a-static-html-page">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How do I attach gas / a deposit?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>After <a href="https://docs.near.org/tools/near-api-js/quick-reference#load-contract-load-contract">contract is instantiated</a> you can then call the contract and specify the amount of attached gas.</p>
<pre><code class="language-js">await contract.method_name(
  {
    arg_name: &quot;value&quot;, // argument name and value - pass empty object if no args required
  },
  &quot;300000000000000&quot;, // attached GAS (optional)
  &quot;1000000000000000000000000&quot; // attached deposit in yoctoNEAR (optional)
);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/faq#how-do-i-attach-gas--a-deposit">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Missing contract method?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Missing a contract method when trying to call a contract? Check to see if you added the view or change methods when instantiating your contract.
<strong>Example:</strong></p>
<pre><code class="language-js">const contract = await new nearAPI.Contract(
  walletConnection.account(),
  'guest-book.testnet',
  {
    viewMethods: [&quot;getMessages&quot;],  
    changeMethods: [&quot;addMessage&quot;], 
    sender: walletConnection.getAccountId(),
  }
);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/faq#missing-contract-method">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the <code>regeneratorRuntime</code> is not defined?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You are probably using <a href="https://parceljs.org/">Parcel</a> like we do in <a href="https://near.dev">other examples</a>. Please make sure you have this line at the top of your main JS file. (Most likely <code>index.js</code>):</p>
<pre><code class="language-js">import &quot;regenerator-runtime/runtime&quot;;
</code></pre>
<ul>
<li>Also, ensure the dependencies for this are added to the project by checking the dev dependencies in your <code>package.json</code>. If not found you can install this by running the following in your terminal:</li>
</ul>
<pre><code class="language-bash">npm install regenerator-runtime --save-dev
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/faq#regeneratorruntime-is-not-defined">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Window error using <code>Node.js</code>?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You maybe using a KeyStore that's for the browser. Instead use a filesystem key or private key string. <a href="https://docs.near.org/tools/near-api-js/quick-reference#key-store-key-store">See methods here</a>
<strong>Browser KeyStore:</strong></p>
<pre><code class="language-js">const { keyStores } = require(&quot;near-api-js&quot;);
const keyStore = new keyStores.BrowserLocalStorageKeyStore();
</code></pre>
<p><strong>FileSystem KeyStore:</strong></p>
<pre><code class="language-js">const { keyStores } = require(&quot;near-api-js&quot;);
const KEY_PATH = &quot;~./near-credentials/testnet/example-account.json&quot;;
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(KEY_PATH);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/faq#window-error-using-nodejs">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the What is <code>near-api-js</code>?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p><code>near-api-js</code> is a complete library to interact with the NEAR blockchain. You can use it in the browser, or in Node.js runtime.
You'll typically first create a connection to NEAR with <a href="https://docs.near.org/tools/near-api-js/#connect"><code>connect</code></a>. If you need to sign transaction, you also create a <a href="https://docs.near.org/tools/near-api-js/#key-store"><code>KeyStore</code></a>.
With the connection object you now can:</p>
<ul>
<li>Interact with the <a href="https://docs.near.org/tools/near-api-js/#wallet">Wallet</a> in a browser.</li>
<li>Instantiate an <a href="https://docs.near.org/tools/near-api-js/#account">Account</a> object to inspect, create or delete accounts, and also send tokens, deploy contracts and manage keys for accounts.</li>
<li>Instantiate an <a href="https://docs.near.org/tools/near-api-js/#contract">Contract</a> object to call smart contract methods.
The library also contains some <a href="https://docs.near.org/tools/near-api-js/#utils">utils</a> functions.
info
Note the difference between <code>near-api-js</code> and <code>near-sdk-js</code>:
The JavaScript <em>SDK</em> is a library for developing smart contracts. It contains classes and functions you use to write your smart contract code.
The JavaScript <em>API</em> is a complete library for all possible commands to interact with NEAR. It’s a wrapper for the RPC endpoints, a library to interact with NEAR Wallet in the browser, and a tool for keys management.</li>
</ul>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Install?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Include <code>near-api-js</code> as a dependency in your package.</p>
<pre><code class="language-bash">npm i --save near-api-js
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#install">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Import?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can use the API library in the browser, or in Node.js runtime. Some features are available only in one of the environments.
For example, the <code>WalletConnection</code> is only for the browser, and there are different <code>KeyStore</code> providers for each environment.
&lt;Tabs&gt;
&lt;TabItem value=&quot;Browser&quot; label=&quot;Browser&quot; default&gt;</p>
<pre><code class="language-js">import * as nearAPI from &quot;near-api-js&quot;;
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;Node&quot; label=&quot;Node&quot;&gt;</p>
<pre><code class="language-js">const nearAPI = require(&quot;near-api-js&quot;);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#import">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Key Store?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If you sign transactions you need to create a <em>Key Store</em>. In the browser, the LocalStorage KeyStore will be used once you ask your user to Sign In with the Wallet.
&lt;Tabs&gt;
&lt;TabItem value=&quot;browser&quot; label=&quot;Using Browser&quot; default&gt;</p>
<pre><code class="language-js">// creates keyStore using private key in local storage
const { keyStores } = nearAPI;
const myKeyStore = new keyStores.BrowserLocalStorageKeyStore();
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;dir&quot; label=&quot;Using Credentials Directory&quot;&gt;</p>
<pre><code class="language-js">// creates a keyStore that searches for keys in .near-credentials
// requires credentials stored locally by using a NEAR-CLI command: `near login` 
// https://docs.near.org/tools/cli#near-login
const { keyStores } = nearAPI;
const homedir = require(&quot;os&quot;).homedir();
const CREDENTIALS_DIR = &quot;.near-credentials&quot;;
const credentialsPath = require(&quot;path&quot;).join(homedir, CREDENTIALS_DIR);
const myKeyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;file&quot; label=&quot;Using a File&quot;&gt;</p>
<pre><code class="language-js">// creates keyStore from a provided file
// you will need to pass the location of the .json key pair
const { KeyPair, keyStores } = require(&quot;near-api-js&quot;);
const fs = require(&quot;fs&quot;);
const homedir = require(&quot;os&quot;).homedir();
const ACCOUNT_ID = &quot;near-example.testnet&quot;;  // NEAR account tied to the keyPair
const NETWORK_ID = &quot;testnet&quot;;
// path to your custom keyPair location (ex. function access key for example account)
const KEY_PATH = '/.near-credentials/near-example-testnet/get_token_price.json';
const credentials = JSON.parse(fs.readFileSync(homedir + KEY_PATH));
const myKeyStore = new keyStores.InMemoryKeyStore();
myKeyStore.setKey(NETWORK_ID, ACCOUNT_ID, KeyPair.fromString(credentials.private_key));
</code></pre>
<p>   
&lt;/TabItem&gt;
&lt;TabItem value=&quot;key&quot; label=&quot;Using a private key string&quot;&gt;</p>
<pre><code class="language-js">// creates keyStore from a private key string
// you can define your key here or use an environment variable
const { keyStores, KeyPair } = nearAPI;
const myKeyStore = new keyStores.InMemoryKeyStore();
const PRIVATE_KEY =
  &quot;by8kdJoJHu7uUkKfoaLd2J2Dp1q1TigeWMG123pHdu9UREqPcshCM223kWadm&quot;;
// creates a public / private key pair using the provided private key
const keyPair = KeyPair.fromString(PRIVATE_KEY);
// adds the keyPair you created to keyStore
await myKeyStore.setKey(&quot;testnet&quot;, &quot;example-account.testnet&quot;, keyPair);
</code></pre>
<p>   
&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p>Key store is <strong><em>not required</em></strong> if you are not signing transactions (meaning - you are only calling read-only <em>view</em> methods on a contract)</p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#key-store">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Connecting to NEAR?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The object returned from <code>connect</code> is your entry-point for all commands in the API.
If you need to sign transaction, you'll need a <a href="https://docs.near.org/tools/near-api-js/#key-store"><code>KeyStore</code></a> to create a connection.
&lt;Tabs&gt;
&lt;TabItem value=&quot;testnet&quot; label=&quot;TestNet&quot; default&gt;</p>
<pre><code class="language-js">const { connect } = nearAPI;
const connectionConfig = {
  networkId: &quot;testnet&quot;,
  keyStore: myKeyStore, // first create a key store 
  nodeUrl: &quot;https://rpc.testnet.near.org&quot;,
  walletUrl: &quot;https://wallet.testnet.near.org&quot;,
  helperUrl: &quot;https://helper.testnet.near.org&quot;,
  explorerUrl: &quot;https://explorer.testnet.near.org&quot;,
};
const nearConnection = await connect(connectionConfig);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;mainnet&quot; label=&quot;MainNet&quot;&gt;</p>
<pre><code class="language-js">const { connect } = nearAPI;
const connectionConfig = {
  networkId: &quot;mainnet&quot;,
  keyStore: myKeyStore, // first create a key store
  nodeUrl: &quot;https://rpc.mainnet.near.org&quot;,
  walletUrl: &quot;https://wallet.mainnet.near.org&quot;,
  helperUrl: &quot;https://helper.mainnet.near.org&quot;,
  explorerUrl: &quot;https://explorer.mainnet.near.org&quot;,
};
const nearConnection = await connect(connectionConfig);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;betanet&quot; label=&quot;BetaNet&quot;&gt;</p>
<pre><code class="language-js">const { connect } = nearAPI;
const connectionConfig = {
  networkId: &quot;betanet&quot;,
  keyStore: myKeyStore, // first create a key store
  nodeUrl: &quot;https://rpc.betanet.near.org&quot;,
  walletUrl: &quot;https://wallet.betanet.near.org&quot;,
  helperUrl: &quot;https://helper.betanet.near.org&quot;,
  explorerUrl: &quot;https://explorer.betanet.near.org&quot;,
};
const nearConnection = await connect(connectionConfig);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;localnet&quot; label=&quot;LocalNet&quot;&gt;</p>
<pre><code class="language-js">const { connect } = nearAPI;
const connectionConfig = {
  networkId: &quot;local&quot;,
  nodeUrl: &quot;http://localhost:3030&quot;,
  walletUrl: &quot;http://localhost:4000/wallet&quot;,
};
const nearConnection = await connect(connectionConfig);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#connect">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Interacting with the Wallet?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Wallet interaction is possible only in the browser, because NEAR's Wallet is web-based.</p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#wallet">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Creating Wallet Connection?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In Wallet connection you use a LocalStorage <a href="https://docs.near.org/tools/near-api-js/#key-store"><code>KeyStore</code></a>.
&lt;Tabs&gt;
&lt;TabItem value=&quot;testnet&quot; label=&quot;TestNet&quot; default&gt;</p>
<pre><code class="language-js">const { connect, keyStores, WalletConnection } = nearAPI;
const connectionConfig = {
  networkId: &quot;testnet&quot;,
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  nodeUrl: &quot;https://rpc.testnet.near.org&quot;,
  walletUrl: &quot;https://wallet.testnet.near.org&quot;,
  helperUrl: &quot;https://helper.testnet.near.org&quot;,
  explorerUrl: &quot;https://explorer.testnet.near.org&quot;,
};
// connect to NEAR
const nearConnection = await connect(connectionConfig);
// create wallet connection
const walletConnection = new WalletConnection(nearConnection);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;mainnet&quot; label=&quot;MainNet&quot;&gt;</p>
<pre><code class="language-js">const { connect, keyStores, WalletConnection } = nearAPI;
const connectionConfig = {
  networkId: &quot;mainnet&quot;,
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  nodeUrl: &quot;https://rpc.mainnet.near.org&quot;,
  walletUrl: &quot;https://wallet.mainnet.near.org&quot;,
  helperUrl: &quot;https://helper.mainnet.near.org&quot;,
  explorerUrl: &quot;https://explorer.mainnet.near.org&quot;,
};
// connect to NEAR
const nearConnection = await connect(connectionConfig);
// create wallet connection
const walletConnection = new WalletConnection(nearConnection);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;betanet&quot; label=&quot;BetaNet&quot;&gt;</p>
<pre><code class="language-js">const { connect, keyStores, WalletConnection } = nearAPI;
const connectionConfig = {
  networkId: &quot;betanet&quot;,
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  nodeUrl: &quot;https://rpc.betanet.near.org&quot;,
  walletUrl: &quot;https://wallet.betanet.near.org&quot;,
  helperUrl: &quot;https://helper.betanet.near.org&quot;,
  explorerUrl: &quot;https://explorer.betanet.near.org&quot;,
};
// connect to NEAR
const nearConnection = await connect(connectionConfig);
// create wallet connection
const walletConnection = new WalletConnection(nearConnection);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
   </p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#wallet-connection">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Ask your user to Sign In?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You first create a <a href="https://docs.near.org/tools/near-api-js/#wallet-connection">WalletConnection</a>, and then call <code>requestSignIn</code>.
This will redirect the current page to the Wallet authentication page.
You can configure success and failure redirect URLs.
This action creates an access key that will be stored in the browser's local storage.
The access key can then be used to connect to NEAR and sign transactions via the KeyStore.</p>
<pre><code class="language-js">// const walletConnection = new WalletConnection(nearConnection);
walletConnection.requestSignIn(
  &quot;example-contract.testnet&quot;, // contract requesting access
  &quot;Example App&quot;, // optional title
  &quot;http://YOUR-URL.com/success&quot;, // optional redirect URL on success
  &quot;http://YOUR-URL.com/failure&quot; // optional redirect URL on failure
);
</code></pre>
<p>Sign In is <strong><em>not required</em></strong> if you are using an alternative key store to local storage, or you are not signing transactions (meaning - you are only calling read-only <em>view</em> methods on a contract)</p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#sign-in">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Sign Out on behalf of your user?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// const walletConnection = new WalletConnection(nearConnection);
walletConnection.signOut();
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#sign-out">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Check if Signed In?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// const walletConnection = new WalletConnection(nearConnection);
if (walletConnection.isSignedIn()) {
	// user is signed in
}
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#check-if-signed-in">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Get Authorized Account Id?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// const walletConnection = new WalletConnection(nearConnection);
const walletAccountId = walletConnection.getAccountId();
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#get-authorized-account-id">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Get Authorized Account Object?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>This will return an instance of <a href="https://docs.near.org/tools/near-api-js/#account">Account</a> that this wallet is authorized for.</p>
<pre><code class="language-js">// const walletConnection = new WalletConnection(nearConnection);
const walletAccountObj = walletConnection.account();
</code></pre>
<p>   </p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#get-authorized-account-object">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can create, delete and interact with accounts with the Account module.</p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#account">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Load Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>This will return an Account object for you to interact with.</p>
<pre><code class="language-js">const account = await nearConnection.account(&quot;example-account.testnet&quot;);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#load-account">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Create Account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// create a new account using funds from the account used to create it.
const account = await nearConnection.account(&quot;example-account.testnet&quot;);
await account.createAccount(
  &quot;example-account2.testnet&quot;, // new account name
  &quot;8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc&quot;, // public key for new account
  &quot;10000000000000000000&quot; // initial balance for new account in yoctoNEAR
);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#create-account">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Get Account Balance?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// gets account balance
const account = await nearConnection.account(&quot;example-account.testnet&quot;);
await account.getAccountBalance();
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#get-account-balance">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Get Account details?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// gets account details in terms of authorized apps and transactions
const account = await nearConnection.account(&quot;example-account.testnet&quot;);
await account.getAccountDetails();
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#get-account-details">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Send Tokens?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// sends NEAR tokens
const account = await nearConnection.account(&quot;sender-account.testnet&quot;);
await account.sendMoney(
  &quot;receiver-account.testnet&quot;, // receiver account
  &quot;1000000000000000000000000&quot; // amount in yoctoNEAR
);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#send-tokens">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the State?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// gets the state of the account
const account = await nearConnection.account(&quot;example-account.testnet&quot;);
const response = await account.state();
console.log(response);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#state">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Access Keys?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Add Full Access Key {#add-full-access-key}</h4>
<pre><code class="language-js">// takes public key as string for argument
const account = await nearConnection.account(&quot;example-account.testnet&quot;);
await account.addKey(&quot;8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc&quot;);
</code></pre>
<h4>Add Function Access Key {#add-function-access-key}</h4>
<pre><code class="language-js">// adds function access key
const account = await nearConnection.account(&quot;example-account.testnet&quot;);
await account.addKey(
  &quot;8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc&quot;, // public key for new account
  &quot;example-account.testnet&quot;, // contract this key is allowed to call (optional)
  &quot;example_method&quot;, // methods this key is allowed to call (optional)
  &quot;2500000000000&quot; // allowance key can use to call methods (optional)
);
</code></pre>
<h4>Get All Access Keys {#get-all-access-keys}</h4>
<pre><code class="language-js">// returns all access keys associated with an account
const account = await nearConnection.account(&quot;example-account.testnet&quot;);
await account.getAccessKeys();
</code></pre>
<h4>Delete Access Key {#delete-access-key}</h4>
<pre><code class="language-js">// takes public key as string for argument
const account = await nearConnection.account(&quot;example-account.testnet&quot;);
await account.deleteKey(&quot;8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc&quot;);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#access-keys">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Load Contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>&lt;Tabs&gt;
&lt;TabItem value=&quot;Standard&quot; label=&quot;Standard&quot; default&gt;</p>
<pre><code class="language-js">const { Contract } = nearAPI;
const contract = new Contract(
  account, // the account object that is connecting
  &quot;example-contract.testnet&quot;,
  {
    // name of contract you're connecting to
    viewMethods: [&quot;getMessages&quot;], // view methods do not change state but usually return a value
    changeMethods: [&quot;addMessage&quot;], // change methods modify state
    sender: account, // account object to initialize and sign transactions.
  }
);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;wallet&quot; label=&quot;Using Wallet&quot;&gt;</p>
<pre><code class="language-js">const { Contract } = nearAPI;
const contract = new Contract(
  wallet.account(), // the account object that is connecting
  &quot;example-contract.testnet&quot;,
  {
    // name of contract you're connecting to
    viewMethods: [&quot;getMessages&quot;], // view methods do not change state but usually return a value
    changeMethods: [&quot;addMessage&quot;], // change methods modify state
    sender: wallet.account(), // account object to initialize and sign transactions.
  }
);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#load-contract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Call Contract?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>&lt;Tabs&gt;
&lt;TabItem value=&quot;method&quot; label=&quot;Change Method&quot; default&gt;</p>
<pre><code class="language-js">await contract.method_name(
  {
    arg_name: &quot;value&quot;, // argument name and value - pass empty object if no args required
  },
  &quot;300000000000000&quot;, // attached GAS (optional)
  &quot;1000000000000000000000000&quot; // attached deposit in yoctoNEAR (optional)
);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;callback&quot; label=&quot;Change Method w/ callbackUrl and meta&quot;&gt;</p>
<pre><code class="language-js">await contract.method_name(
  {
    callbackUrl: 'https://example.com/callback', // callbackUrl after the transaction approved (optional)
    meta: 'some info', // meta information NEAR Wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param
    args: {
        arg_name: &quot;value&quot; // argument name and value - pass empty object if no args required
    },
    gas: 300000000000000, // attached GAS (optional)
    amount: 1000000000000000000000000 // attached deposit in yoctoNEAR (optional)
  }
);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;view&quot; label=&quot;View Method&quot;&gt;</p>
<pre><code class="language-js">const response = await contract.view_method_name();
console.log(response);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;args&quot; label=&quot;View Method w/ args&quot;&gt;</p>
<pre><code class="language-js">const response = await contract.view_method_name({ arg_name: &quot;arg_value&quot; });
console.log(response);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;</p>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#call-contract">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the NEAR =&gt; yoctoNEAR?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-js">// converts NEAR amount into yoctoNEAR (10^-24)
const { utils } = nearAPI;
const amountInYocto = utils.format.parseNearAmount(&quot;1&quot;);
</code></pre>
<p><a href="https://docs.near.org/tools/near-api-js/quick-reference#near--yoctonear">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Integrating Contracts into a Web App?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If you are developing a website (or a web-app), then you will be using <code>near-api-js</code> to communicate with the blockchain. Go to the <a href="https://docs.near.org/tools/tools/near-api-js/cookbook">website</a> for more information about it.</p>
<p><a href="https://docs.near.org/tools/usecases">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Command Line Interface?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can use <a href="https://docs.near.org/tools/./cli">NEAR CLI</a> to automatize tasks from the command line such as:</p>
<ul>
<li>Creating sub-accounts</li>
<li>Deploying contracts to them</li>
<li>Calling initialization methods</li>
</ul>
<p><a href="https://docs.near.org/tools/usecases">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Querying Post Hoc Information?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The <a href="https://docs.near.org/tools/./indexer4explorer">NEAR Indexer</a> enables you to query information from a deployed contract such as:</p>
<ol>
<li>Which users called a specific method?</li>
<li>How much money they attached?</li>
<li>How much GAS was used?
It is very useful for analyzing scenarios that happened in the past.</li>
</ol>
<p><a href="https://docs.near.org/tools/usecases">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the View access key?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Returns information about a single access key for given account.
If <code>permission</code> of the key is <code>FunctionCall</code>, it will return more details such as the <code>allowance</code>, <code>receiver_id</code>, and <code>method_names</code>.</p>
<ul>
<li>method: <code>query</code></li>
<li>params:
<ul>
<li><code>request_type</code>: <code>view_access_key</code></li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a></li>
<li><code>account_id</code>: <em><code>&quot;example.testnet&quot;</code></em></li>
<li><code>public_key</code>: <em><code>&quot;example.testnet's public key&quot;</code></em>
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;query&quot;,
  &quot;params&quot;: {
    &quot;request_type&quot;: &quot;view_access_key&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;client.chainlink.testnet&quot;,
    &quot;public_key&quot;: &quot;ed25519:H9k5eiU4xXS3M4z8HzKJSLaZdqGdGwBG49o7orNC4eZW&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.query({
  request_type: &quot;view_access_key&quot;,
  finality: &quot;final&quot;,
  account_id: &quot;client.chainlink.testnet&quot;,
  public_key: &quot;ed25519:H9k5eiU4xXS3M4z8HzKJSLaZdqGdGwBG49o7orNC4eZW&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    &quot;request_type&quot;: &quot;view_access_key&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;client.chainlink.testnet&quot;,
    &quot;public_key&quot;: &quot;ed25519:H9k5eiU4xXS3M4z8HzKJSLaZdqGdGwBG49o7orNC4eZW&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;nonce&quot;: 85,
    &quot;permission&quot;: {
      &quot;FunctionCall&quot;: {
        &quot;allowance&quot;: &quot;18501534631167209000000000&quot;,
        &quot;receiver_id&quot;: &quot;client.chainlink.testnet&quot;,
        &quot;method_names&quot;: [&quot;get_token_price&quot;]
      }
    },
    &quot;block_height&quot;: 19884918,
    &quot;block_hash&quot;: &quot;GGJQ8yjmo7aEoj8ZpAhGehnq9BSWFx4xswHYzDwwAP2n&quot;
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong?</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>view_access_key</code> request type:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;6&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INVALID_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; is invalid&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Provide a valid &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNKNOWN_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; has not been found while viewing since the account has not been created or has been already deleted&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Specify a different block or retry if you request the latest state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNKNOWN_ACCESS_KEY&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;public_key&lt;/code&gt; has not been found while viewing since the public key has not been created or has been already deleted&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the &lt;code&gt;public_key&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Specify a different block or retry if you request the latest state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNAVAILABLE_SHARD&lt;/td&gt;
&lt;td&gt;The node was unable to found the requested data because it does not track the shard where data is present&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Send a request to a different node which might track the shard&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NO_SYNCED_BLOCKS&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/access-keys#view-access-key">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the View access key list?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>You can query &lt;strong&gt;all&lt;/strong&gt; access keys for a given account.</p>
<ul>
<li>method: <code>query</code></li>
<li>params:
<ul>
<li><code>request_type</code>: <code>view_access_key_list</code></li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a></li>
<li><code>account_id</code>: <em><code>&quot;example.testnet&quot;</code></em>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;query&quot;,
  &quot;params&quot;: {
    &quot;request_type&quot;: &quot;view_access_key_list&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;example.testnet&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.query({
  request_type: &quot;view_access_key_list&quot;,
  finality: &quot;final&quot;,
  account_id: &quot;example.testnet&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    &quot;request_type&quot;: &quot;view_access_key_list&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;example.testnet&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;keys&quot;: [
      {
        &quot;public_key&quot;: &quot;ed25519:2j6qujbkPFuTstQLLTxKZUw63D5Wu3SG79Gop5JQrNJY&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 17,
          &quot;permission&quot;: {
            &quot;FunctionCall&quot;: {
              &quot;allowance&quot;: &quot;9999203942481156415000&quot;,
              &quot;receiver_id&quot;: &quot;place.meta&quot;,
              &quot;method_names&quot;: []
            }
          }
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:46etzhzZHN4NSQ8JEQtbHCX7sT8WByS3vmSEb3fbmSgf&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 2,
          &quot;permission&quot;: {
            &quot;FunctionCall&quot;: {
              &quot;allowance&quot;: &quot;9999930655034196535000&quot;,
              &quot;receiver_id&quot;: &quot;dev-1596616186817-8588944&quot;,
              &quot;method_names&quot;: []
            }
          }
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:4F9TwuSqWwvoyu7JVZDsupPhC7oYbYNsisBV2yQvyXFn&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 0,
          &quot;permission&quot;: &quot;FullAccess&quot;
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:4bZqp6nm1btr92UfKbyADDzJ4oPK9JetHXqEYqbYZmkD&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 2,
          &quot;permission&quot;: &quot;FullAccess&quot;
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:6ZPzX7hS37jiU9dRxbV1Waf8HSyKKFypJbrnZXzNhqjs&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 2,
          &quot;permission&quot;: {
            &quot;FunctionCall&quot;: {
              &quot;allowance&quot;: &quot;9999922083697042955000&quot;,
              &quot;receiver_id&quot;: &quot;example.testnet&quot;,
              &quot;method_names&quot;: []
            }
          }
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:81RKfuo7mBbsaviTmBsq18t6Eq4YLnSi3ye2CBLcKFUX&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 8,
          &quot;permission&quot;: &quot;FullAccess&quot;
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:B4W1oAYTcG8GxwKev8jQtsYWkGwGdqP24W7eZ6Fmpyzc&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 0,
          &quot;permission&quot;: {
            &quot;FunctionCall&quot;: {
              &quot;allowance&quot;: &quot;10000000000000000000000&quot;,
              &quot;receiver_id&quot;: &quot;dev-1594144238344&quot;,
              &quot;method_names&quot;: []
            }
          }
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:BA3AZbACoEzAsxKeToFd36AVpPXFSNhSMW2R6UYeGRwM&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 0,
          &quot;permission&quot;: {
            &quot;FunctionCall&quot;: {
              &quot;allowance&quot;: &quot;10000000000000000000000&quot;,
              &quot;receiver_id&quot;: &quot;new-corgis&quot;,
              &quot;method_names&quot;: []
            }
          }
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:BRyHUGAJjRKVTc9ZqXTTSJnFmSca8WLj8TuVe1wXK3LZ&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 17,
          &quot;permission&quot;: &quot;FullAccess&quot;
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:DjytaZ1HZ5ZFmH3YeJeMCiC886K1XPYeGsbz2E1AZj2J&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 31,
          &quot;permission&quot;: &quot;FullAccess&quot;
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:DqJn5UCq6vdNAvfhnbpdAeuui9a6Hv9DKYDxeRACPUDP&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 0,
          &quot;permission&quot;: &quot;FullAccess&quot;
        }
      },
      {
        &quot;public_key&quot;: &quot;ed25519:FFxG8x6cDDyiErFtRsdw4dBNtCmCtap4tMTjuq3umvSq&quot;,
        &quot;access_key&quot;: {
          &quot;nonce&quot;: 0,
          &quot;permission&quot;: &quot;FullAccess&quot;
        }
      }
    ],
    &quot;block_height&quot;: 17798231,
    &quot;block_hash&quot;: &quot;Gm7YSdx22wPuciW1jTTeRGP9mFqmon69ErFQvgcFyEEB&quot;
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong?</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>view_access_key_list</code> request type:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;5&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INVALID_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; is invalid&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Provide a valid &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNKNOWN_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; has not been found while viewing since the account has not been created or has been already deleted&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Specify a different block or retry if you request the latest state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNAVAILABLE_SHARD&lt;/td&gt;
&lt;td&gt;The node was unable to find the requested data because it does not track the shard where data is present&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Send a request to a different node which might track the shard&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NO_SYNCED_BLOCKS&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/access-keys#view-access-key-list">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the View access key changes (single)?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Returns individual access key changes in a specific block. You can query multiple keys by passing an array of objects containing the <code>account_id</code> and <code>public_key</code>.</p>
<ul>
<li>method: <code>EXPERIMENTAL_changes</code></li>
<li>params:
<ul>
<li><code>changes_type</code>: <code>single_access_key_changes</code></li>
<li><code>keys</code>: <code>[{ account_id, public_key }]</code></li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_changes&quot;,
  &quot;params&quot;: {
    &quot;changes_type&quot;: &quot;single_access_key_changes&quot;,
    &quot;keys&quot;: [
      {
        &quot;account_id&quot;: &quot;example-acct.testnet&quot;,
        &quot;public_key&quot;: &quot;ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM&quot;
      }
    ],
    &quot;finality&quot;: &quot;final&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_changes({
  changes_type: &quot;single_access_key_changes&quot;,
  keys: [
    {
      account_id: &quot;example-acct.testnet&quot;,
      public_key: &quot;ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM&quot;,
    },
  ],
  finality: &quot;final&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    &quot;changes_type&quot;: &quot;single_access_key_changes&quot;,
    &quot;keys&quot;: [
      {
        &quot;account_id&quot;: &quot;example-acct.testnet&quot;,
        &quot;public_key&quot;: &quot;ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM&quot;
      }
    ],
    &quot;finality&quot;: &quot;final&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;block_hash&quot;: &quot;4kvqE1PsA6ic1LG7S5SqymSEhvjqGqumKjAxnVdNN3ZH&quot;,
    &quot;changes&quot;: [
      {
        &quot;cause&quot;: {
          &quot;type&quot;: &quot;transaction_processing&quot;,
          &quot;tx_hash&quot;: &quot;HshPyqddLxsganFxHHeH9LtkGekXDCuAt6axVgJLboXV&quot;
        },
        &quot;type&quot;: &quot;access_key_update&quot;,
        &quot;change&quot;: {
          &quot;account_id&quot;: &quot;example-acct.testnet&quot;,
          &quot;public_key&quot;: &quot;ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM&quot;,
          &quot;access_key&quot;: {
            &quot;nonce&quot;: 1,
            &quot;permission&quot;: &quot;FullAccess&quot;
          }
        }
      }
    ]
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong?{#what-could-go-wrong-2}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>EXPERIMENTAL_changes_in_block</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;2&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT_SYNCED_YET&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/access-keys#view-access-key-changes-single">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Block details?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Queries network and returns block for given height or hash. You can also use <code>finality</code> param to return latest block details.
<strong>Note</strong>: You may choose to search by a specific block <em>or</em> finality, you can not choose both.</p>
</blockquote>
<ul>
<li>method: <code>block</code></li>
<li>params:
<ul>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a>
<code>finality</code> example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;block&quot;,
  &quot;params&quot;: {
    &quot;finality&quot;: &quot;final&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.block({
  finality: &quot;final&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=block \
  params:='{
    &quot;finality&quot;: &quot;final&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
<code>[block_id]</code>
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;block&quot;,
  &quot;params&quot;: {
    &quot;block_id&quot;: 17821130
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.block(17821130);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=block \
  params:='{
    &quot;block_id&quot;: 17821130
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
<code>[block_hash]</code>
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;block&quot;,
  &quot;params&quot;: {
    &quot;block_id&quot;: &quot;7nsuuitwS7xcdGnD9JgrE22cRB2vf2VS4yh1N9S71F4d&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.block(
  &quot;7nsuuitwS7xcdGnD9JgrE22cRB2vf2VS4yh1N9S71F4d&quot;
);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=block \
  params:='{
    &quot;block_id&quot;: &quot;7nsuuitwS7xcdGnD9JgrE22cRB2vf2VS4yh1N9S71F4d&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response:&lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;author&quot;: &quot;bitcat.pool.f863973.m0&quot;,
    &quot;header&quot;: {
      &quot;height&quot;: 17821130,
      &quot;epoch_id&quot;: &quot;7Wr3GFJkYeCxjVGz3gDaxvAMUzXuzG8MjFXTFoAXB6ZZ&quot;,
      &quot;next_epoch_id&quot;: &quot;A5AdnxEn7mfHieQ5fRxx9AagCkHNJz6wr61ppEXiWvvh&quot;,
      &quot;hash&quot;: &quot;CLo31YCUhzz8ZPtS5vXLFskyZgHV5qWgXinBQHgu9Pyd&quot;,
      &quot;prev_hash&quot;: &quot;2yUTTubrv1gJhTUVnHXh66JG3qxStBqySoN6wzRzgdVD&quot;,
      &quot;prev_state_root&quot;: &quot;5rSz37fySS8XkVgEy3FAZwUncX4X1thcSpuvCgA6xmec&quot;,
      &quot;chunk_receipts_root&quot;: &quot;9ETNjrt6MkwTgSVMMbpukfxRshSD1avBUUa4R4NuqwHv&quot;,
      &quot;chunk_headers_root&quot;: &quot;HMpEoBhPvThWZvppLwrXQSSfumVdaDW7WfZoCAPtjPfo&quot;,
      &quot;chunk_tx_root&quot;: &quot;7tkzFg8RHBmMw1ncRJZCCZAizgq4rwCftTKYLce8RU8t&quot;,
      &quot;outcome_root&quot;: &quot;7tkzFg8RHBmMw1ncRJZCCZAizgq4rwCftTKYLce8RU8t&quot;,
      &quot;chunks_included&quot;: 1,
      &quot;challenges_root&quot;: &quot;11111111111111111111111111111111&quot;,
      &quot;timestamp&quot;: 1601280114229875635,
      &quot;timestamp_nanosec&quot;: &quot;1601280114229875635&quot;,
      &quot;random_value&quot;: &quot;ACdUSF3nehbMTwT7qjUB6Mm4Ynck5TVAWbNH3DR1cjQ7&quot;,
      &quot;validator_proposals&quot;: [],
      &quot;chunk_mask&quot;: [true],
      &quot;gas_price&quot;: &quot;100000000&quot;,
      &quot;rent_paid&quot;: &quot;0&quot;,
      &quot;validator_reward&quot;: &quot;0&quot;,
      &quot;total_supply&quot;: &quot;1042339182040791154864822502764857&quot;,
      &quot;challenges_result&quot;: [],
      &quot;last_final_block&quot;: &quot;AaxTqjYND5WAKbV2UZaFed6DH1DShN9fEemtnpTsv3eR&quot;,
      &quot;last_ds_final_block&quot;: &quot;2yUTTubrv1gJhTUVnHXh66JG3qxStBqySoN6wzRzgdVD&quot;,
      &quot;next_bp_hash&quot;: &quot;3ZNEoFYh2CQeJ9dc1pLBeUd1HWG8657j2c1v72ENE45Q&quot;,
      &quot;block_merkle_root&quot;: &quot;H3912Nkw6rtamfjsjmafe2uV2p1XmUKDou5ywgxb1gJr&quot;,
      &quot;approvals&quot;: [
        &quot;ed25519:4hNtc9vLhn2PQhktWtLKJV9g8SBfpm6NBT1w4syNFqoKE7ZMts2WwKA9x1ZUSBGVKYCuDGEqogLvwCF25G7e1UR3&quot;,
        &quot;ed25519:2UNmbTqysMMevVPqJEKSq57hkcxVFcAMdGq7CFhpW65yBKFxYwpoziiWsAtARusLn9Sy1eXM7DkGTXwAqFiSooS6&quot;,
        &quot;ed25519:4sumGoW9dnQCsJRpzkd4FQ5NSJypGQRCppWp7eQ9tpsEcJXjHZN8GVTCyeEk19WmbbMEJ5KBNypryyHzaH2gBxd4&quot;,
        &quot;ed25519:3fP2dri6GjYkmHgEqQWWP9GcoQEgakbaUtfr3391tXtYBgxmiJUEymRe54m7D8bQrSJ3LhKD8gTFT7qqdemRnizR&quot;,
        &quot;ed25519:3mwdqSWNm6RiuZAoZhD6pqsirC2cL48nEZAGoKixpqbrsBpAzqV3W2paH4KtQQ4JPLvk5pnzojaint2kNBCcUyq1&quot;,
        &quot;ed25519:D4hMnxqLyQW4Wo29MRNMej887GH46yJXDKNN4es8UDSi9shJ9Y4FcGqkxdV4AZhn1yUjwN5LwfgAgY6fyczk5L3&quot;,
        null,
        &quot;ed25519:4WCVm4dn88VJxTkUgcvdS7vs34diBqtQY4XWMRctSN1NpbgdkwwVyxg7d2SbGC22SuED7w4nrToMhcpJXrkhkDmF&quot;,
        &quot;ed25519:JqtC7TFP7U14s7YhRKQEqwbc2RUxoctq75mrBdX91f7DuCWsPpe6ZTTnfHPmuJPjTzFHVZTsaQJWzwfSrrgNpnc&quot;,
        &quot;ed25519:ngGUpWc2SyHmMCkWGTNNNfvZAJQ5z7P92JCmDqB7JW3j8fNH6LobvFFXb2zVdssibJKgnjwBj8CRe6qiZtuYQZM&quot;,
        &quot;ed25519:5kzW6RbjukyJZiw9NTzTPPsQdoqN6EecafjVFEoWmTxQ4uSv1uSXhQYcHK2eq4m84oMmPABQDz2mm73Qx8mDdCQX&quot;,
        &quot;ed25519:5wHnuuxwJJiZ4bXNq5cESnr4YovFU2yaUcuHRDUw3DnLoxkqc15CsegoyUSQKEwtCZ4yETv8Z9QcD6Wr9zHV4AUk&quot;,
        &quot;ed25519:3F9XzWBxto31e8RAcBShAJBzJPgSJQsWbPXR38AfQnJn6AiveGz3JjebQm9Ye63BrnNA57QrPshwknxpzSrcNEZW&quot;,
        &quot;ed25519:2g5s4SKsHt9PMdekkDqVtwwtz14v4edhqdBX1MYA8tB6nDpj3vDCDCTy9pEU8dX31PoQe5ygnf88aTZukMBMK1Yt&quot;,
        &quot;ed25519:3Xz4jqhdyS3qs6xTmWdgjwt5gJraU5czMA89hPhmvbAN4aA7SUKL1HkevpmutRQqqxe7c7uCFeGiDHvDcxhhmD8W&quot;,
        null,
        &quot;ed25519:55xs3vwPEys39egf9Z8SNyn1JsHPRMgj9HCX1GE7GJsVTcAuutQUCo91E12ZdXkuToYRXb9KzoT8n9XQRCNuLpwY&quot;,
        null,
        &quot;ed25519:28JrFw7KnhnQPN89qZnnw17KDBjS6CDN7zB1hTg7KGg8qQPoCzakz9DNnaSnx39ji7e2fQSpZt4cNJaD7K7Yu7yo&quot;,
        &quot;ed25519:41hAr5qhtvUYpdD2NK9qqTVnpG325ZoAiwrcmk1MJH7fdpxm7oSKXvXZqh7bTmPhv61hH2RpHnhcGuN4QqLzK2zt&quot;,
        &quot;ed25519:4QacMsQ5FJgvecAYDFq8QBh19BBjh4qU8oeD5bV7p6Zhhu3e6r2iSHTvDBU2Q62RZAaWQQkkEwDUC9rsXdkGVhAt&quot;,
        &quot;ed25519:27smtCZ3WobEvBuD5DggY6kkGxjB9qRVY6kPixgwqvBT1eKbRVoV8cLj1z51S8RTcp7YzAr1vhHJUHgksatR9Udz&quot;,
        &quot;ed25519:4wspCWoAbhYxb3th2eX6ZXvKep1Fsco7mFP5zBodXBR8Wr344ANXSUCri3gUgNCCSoQ2CKSdqDEsvE6Y2jQ9hmbB&quot;,
        &quot;ed25519:46XpYf9ZB9gjDfdnJLHqqhYJpQCuvCgB9tzKWS88GANMCb2j9BM3KXyjaEzynSsaPK8VrKFXQuTsTzgQSeo9cWGW&quot;,
        null,
        &quot;ed25519:Y5ehsrhEpTRGjG6fHJHsEXj2NYPGMmKguiJHXP7TqsCWHBvNzaJbieR7UDp78hJ1ib7C18J5MB2kCzTXBCF9c3b&quot;,
        &quot;ed25519:3P9363Dc8Kqvgjt3TsNRncUrncCHid7aSRnuySjF4JYmQbApkAxomyMu8xm9Rgo3mj9rqXb16PM7Xjn7hKP6TyVr&quot;,
        null,
        null,
        &quot;ed25519:65ATjGsigZ3vMp7sGcp1c4ptxoqhHPkBeAaZ5GWJguVDLyrRLPJrtXhLGjH9DpXd7CZswjyMYq5aRtorLnmmJ7GW&quot;,
        null,
        &quot;ed25519:5SvqSViXbtsLoFMdtCufyyDgZnrEK7LheFi38X5M2ic17gfV5cz37r85RyixjUv98MbAmgVdmkxVFDGfSbeoHW7X&quot;,
        null,
        null,
        &quot;ed25519:2n3fQiBEiDKkB84biXWyQmvnupKX7B8faugY37jVi8hVXuWLggJmaEjqub511RCYwFnwW1RBxYpuJQ455KaniCd4&quot;,
        &quot;ed25519:2K9xKFLJ2fW74tddXtghFGFurKWomAqaJmkKYVZKHQT6zHe5wNSYT3vzMotLQcez5JD1Ta57N9zQ4H1RysB2s5DZ&quot;,
        null,
        null,
        &quot;ed25519:3qeCRtcLAqLtQ2YSQLcHDa26ykKX1BvAhP9jshLLYapxSEGGgZJY8sU72p9E78AkXwHP3X2Eq74jvts7gTRzNgMg&quot;,
        null,
        &quot;ed25519:2czSQCF8wBDomEeSdDRH4gFoyJrp2ppZqR6JDaDGoYpaFkpWxZf2oGDkKfQLZMbfvU6LXkQjJssVHcLCJRMzG8co&quot;
      ],
      &quot;signature&quot;: &quot;ed25519:58sdWd6kxzhQdCGvHzxqvdtDLJzqspe74f3gytnqdxDLHf4eesXi7B3nYq2YaosCHZJYmcR4HPHKSoFm3WE4MbxT&quot;,
      &quot;latest_protocol_version&quot;: 35
    },
    &quot;chunks&quot;: [
      {
        &quot;chunk_hash&quot;: &quot;EBM2qg5cGr47EjMPtH88uvmXHDHqmWPzKaQadbWhdw22&quot;,
        &quot;prev_block_hash&quot;: &quot;2yUTTubrv1gJhTUVnHXh66JG3qxStBqySoN6wzRzgdVD&quot;,
        &quot;outcome_root&quot;: &quot;11111111111111111111111111111111&quot;,
        &quot;prev_state_root&quot;: &quot;HqWDq3f5HJuWnsTfwZS6jdAUqDjGFSTvjhb846vV27dx&quot;,
        &quot;encoded_merkle_root&quot;: &quot;9zYue7drR1rhfzEEoc4WUXzaYRnRNihvRoGt1BgK7Lkk&quot;,
        &quot;encoded_length&quot;: 8,
        &quot;height_created&quot;: 17821130,
        &quot;height_included&quot;: 17821130,
        &quot;shard_id&quot;: 0,
        &quot;gas_used&quot;: 0,
        &quot;gas_limit&quot;: 1000000000000000,
        &quot;rent_paid&quot;: &quot;0&quot;,
        &quot;validator_reward&quot;: &quot;0&quot;,
        &quot;balance_burnt&quot;: &quot;0&quot;,
        &quot;outgoing_receipts_root&quot;: &quot;H4Rd6SGeEBTbxkitsCdzfu9xL9HtZ2eHoPCQXUeZ6bW4&quot;,
        &quot;tx_root&quot;: &quot;11111111111111111111111111111111&quot;,
        &quot;validator_proposals&quot;: [],
        &quot;signature&quot;: &quot;ed25519:4iPgpYAcPztAvnRHjfpegN37Rd8dTJKCjSd1gKAPLDaLcHUySJHjexMSSfC5iJVy28vqF9VB4psz13x2nt92cbR7&quot;
      }
    ]
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong?? {#what-could-go-wrong}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>block</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;2&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT_SYNCED_YET&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/block-chunk#block-details">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Changes in Block?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns changes in block for given block height or hash. You can also use <code>finality</code> param to return latest block details.
<strong>Note</strong>: You may choose to search by a specific block <em>or</em> finality, you can not choose both.</p>
</blockquote>
<ul>
<li>method: <code>EXPERIMENTAL_changes_in_block</code></li>
<li>params:
<ul>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a>
<code>finality</code>
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_changes_in_block&quot;,
  &quot;params&quot;: {
    &quot;finality&quot;: &quot;final&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_changes_in_block({
  finality: &quot;final&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes_in_block \
  params:='{
    &quot;finality&quot;: &quot;final&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
<code>[block_id]</code>
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_changes_in_block&quot;,
  &quot;params&quot;: {
    &quot;block_id&quot;: 17821135
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_changes_in_block(
  17821135
);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes_in_block \
  params:='{
    &quot;block_id&quot;: 17821135
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
<code>block_hash</code>
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_changes_in_block&quot;,
  &quot;params&quot;: {
    &quot;block_id&quot;: &quot;81k9ked5s34zh13EjJt26mxw5npa485SY4UNoPi6yYLo&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_changes_in_block(
  &quot;81k9ked5s34zh13EjJt26mxw5npa485SY4UNoPi6yYLo&quot;
);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes_in_block \
  params:='{
    &quot;block_id&quot;: &quot;81k9ked5s34zh13EjJt26mxw5npa485SY4UNoPi6yYLo&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;block_hash&quot;: &quot;81k9ked5s34zh13EjJt26mxw5npa485SY4UNoPi6yYLo&quot;,
    &quot;changes&quot;: [
      {
        &quot;type&quot;: &quot;account_touched&quot;,
        &quot;account_id&quot;: &quot;lee.testnet&quot;
      },
      {
        &quot;type&quot;: &quot;contract_code_touched&quot;,
        &quot;account_id&quot;: &quot;lee.testnet&quot;
      },
      {
        &quot;type&quot;: &quot;access_key_touched&quot;,
        &quot;account_id&quot;: &quot;lee.testnet&quot;
      }
    ]
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong?? {#what-could-go-wrong-1}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>EXPERIMENTAL_changes_in_block</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;2&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT_SYNCED_YET&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/block-chunk#changes-in-block">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the View account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns basic account information.</p>
</blockquote>
<ul>
<li>method: <code>query</code></li>
<li>params:
<ul>
<li><code>request_type</code>: <code>view_account</code></li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a></li>
<li><code>account_id</code>: <em><code>&quot;example.testnet&quot;</code></em>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;query&quot;,
  &quot;params&quot;: {
    &quot;request_type&quot;: &quot;view_account&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;nearkat.testnet&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.query({
  request_type: &quot;view_account&quot;,
  finality: &quot;final&quot;,
  account_id: &quot;nearkat.testnet&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    &quot;request_type&quot;: &quot;view_account&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;nearkat.testnet&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;amount&quot;: &quot;399992611103597728750000000&quot;,
    &quot;locked&quot;: &quot;0&quot;,
    &quot;code_hash&quot;: &quot;11111111111111111111111111111111&quot;,
    &quot;storage_usage&quot;: 642,
    &quot;storage_paid_at&quot;: 0,
    &quot;block_height&quot;: 17795474,
    &quot;block_hash&quot;: &quot;9MjpcnwW3TSdzGweNfPbkx8M74q1XzUcT1PAN8G5bNDz&quot;
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong? {#what-could-go-wrong}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>view_account</code> request type:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;5&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INVALID_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; is invalid&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Provide a valid &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNKNOWN_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; has not been found while viewing since the account has not been created or has been already deleted&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Specify a different block or retry if you request the latest state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNAVAILABLE_SHARD&lt;/td&gt;
&lt;td&gt;The node was unable to find the requested data because it does not track the shard where data is present&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Send a request to a different node which might track the shard&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NO_SYNCED_BLOCKS&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/contracts#view-account">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the View account changes?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns account changes from transactions in a given account.</p>
</blockquote>
<ul>
<li>method: <code>EXPERIMENTAL_changes</code></li>
<li>params:
<ul>
<li><code>changes_type</code>: <code>account_changes</code></li>
<li><code>account_ids</code>: [<code>&quot;example.testnet&quot;</code>]</li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_changes&quot;,
  &quot;params&quot;: {
    &quot;changes_type&quot;: &quot;account_changes&quot;,
    &quot;account_ids&quot;: [&quot;your_account.testnet&quot;],
    &quot;block_id&quot;: 19703467
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_changes({
  changes_type: &quot;account_changes&quot;,
  account_ids: [&quot;nearkat.testnet&quot;],
  block_id: 19703467,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    &quot;changes_type&quot;: &quot;account_changes&quot;,
    &quot;account_ids&quot;: [&quot;your_account.testnet&quot;],
    &quot;block_id&quot;: 19703467
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;block_hash&quot;: &quot;6xsfPSG89s6fCMShxxxQTP6D4ZHM9xkGCgubayTDRzAP&quot;,
    &quot;changes&quot;: [
      {
        &quot;cause&quot;: {
          &quot;type&quot;: &quot;transaction_processing&quot;,
          &quot;tx_hash&quot;: &quot;HLvxLKFM7gohFSqXPp5SpyydNEVpAno352qJJbnddsz3&quot;
        },
        &quot;type&quot;: &quot;account_update&quot;,
        &quot;change&quot;: {
          &quot;account_id&quot;: &quot;your_account.testnet&quot;,
          &quot;amount&quot;: &quot;499999959035075000000000000&quot;,
          &quot;locked&quot;: &quot;0&quot;,
          &quot;code_hash&quot;: &quot;11111111111111111111111111111111&quot;,
          &quot;storage_usage&quot;: 182,
          &quot;storage_paid_at&quot;: 0
        }
      },
      {
        &quot;cause&quot;: {
          &quot;type&quot;: &quot;receipt_processing&quot;,
          &quot;receipt_hash&quot;: &quot;CPenN1dp4DNKnb9LiL5hkPmu1WiKLMuM7msDjEZwDmwa&quot;
        },
        &quot;type&quot;: &quot;account_update&quot;,
        &quot;change&quot;: {
          &quot;account_id&quot;: &quot;your_account.testnet&quot;,
          &quot;amount&quot;: &quot;499999959035075000000000000&quot;,
          &quot;locked&quot;: &quot;0&quot;,
          &quot;code_hash&quot;: &quot;11111111111111111111111111111111&quot;,
          &quot;storage_usage&quot;: 264,
          &quot;storage_paid_at&quot;: 0
        }
      }
    ]
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong? {#what-could-go-wrong-1}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>EXPERIMENTAL_changes</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;2&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT_SYNCED_YET&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/contracts#view-account-changes">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the View contract code?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns the contract code (Wasm binary) deployed to the account. Please note that the returned code will be encoded in base64.</p>
</blockquote>
<ul>
<li>method: <code>query</code></li>
<li>params:
<ul>
<li><code>request_type</code>: <code>view_code</code></li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a></li>
<li><code>account_id</code>: <code>&quot;guest-book.testnet&quot;</code>,
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;query&quot;,
  &quot;params&quot;: {
    &quot;request_type&quot;: &quot;view_code&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;guest-book.testnet&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.query({
  request_type: &quot;view_code&quot;,
  finality: &quot;final&quot;,
  account_id: &quot;guest-book.testnet&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    &quot;request_type&quot;: &quot;view_code&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;guest-book.testnet&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;code_base64&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;,
    &quot;hash&quot;: &quot;7KoFshMQkdyo5iTx8P2LbLu9jQpxRn24d27FrKShNVXs&quot;,
    &quot;block_height&quot;: 17814234,
    &quot;block_hash&quot;: &quot;GT1D8nweVQU1zyCUv399x8vDv2ogVq71w17MyR66hXBB&quot;
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong? {#what-could-go-wrong-2}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>view_code</code> request type:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;6&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INVALID_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; is invalid&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Provide a valid &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNKNOWN_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; has not been found while viewing since the account has not been created or has been already deleted&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Specify a different block or retry if you request the latest state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NO_CONTRACT_CODE&lt;/td&gt;
&lt;td&gt;The account does not have any &lt;code&gt;contract&lt;/code&gt; deployed on it&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Use different account&lt;/li&gt;
&lt;li&gt;Specify a different block or retry if you request the latest state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNAVAILABLE_SHARD&lt;/td&gt;
&lt;td&gt;The node was unable to find the requested data because it does not track the shard where data is present&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Send a request to a different node which might track the shard&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NO_SYNCED_BLOCKS&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/contracts#view-contract-code">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the View contract state?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns the state (key value pairs) of a contract based on the key prefix (base64 encoded). Pass an empty string for <code>prefix_base64</code> if you would like to return the entire state. Please note that the returned state will be base64 encoded as well.</p>
</blockquote>
<ul>
<li>method: <code>query</code></li>
<li>params:
<ul>
<li><code>request_type</code>: <code>view_state</code></li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a></li>
<li><code>account_id</code>: <code>&quot;guest-book.testnet&quot;</code>,</li>
<li><code>prefix_base64</code>: <code>&quot;&quot;</code>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;query&quot;,
  &quot;params&quot;: {
    &quot;request_type&quot;: &quot;view_state&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;guest-book.testnet&quot;,
    &quot;prefix_base64&quot;: &quot;&quot;
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.query({
  request_type: &quot;view_state&quot;,
  finality: &quot;final&quot;,
  account_id: &quot;guest-book.testnet&quot;,
  prefix_base64: &quot;&quot;,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    &quot;request_type&quot;: &quot;view_state&quot;,
    &quot;finality&quot;: &quot;final&quot;,
    &quot;account_id&quot;: &quot;guest-book.testnet&quot;,
    &quot;prefix_base64&quot;: &quot;&quot;
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;values&quot;: [
      {
        &quot;key&quot;: &quot;bTo6MA==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJqb3NoZm9yZC50ZXN0bmV0IiwidGV4dCI6ImhlbGxvIn0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MQ==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiY2hhZG9oIiwidGV4dCI6ImhlbGxvIGVyeWJvZHkifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTA=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoic2F0b3NoaWYudGVzdG5ldCIsInRleHQiOiJIaWxsbyEifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTE=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidmFsZW50aW5lc29rb2wudGVzdG5ldCIsInRleHQiOiJIaSEifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTI=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJobngudGVzdG5ldCIsInRleHQiOiJoZWxsbyJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTM=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJobngudGVzdG5ldCIsInRleHQiOiJzZCJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTQ=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiamdoZy50ZXN0bmV0IiwidGV4dCI6IktoZyJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTU=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiYWNjb3VudC50ZXN0bmV0IiwidGV4dCI6IldoZW4gSUNPPyJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTY=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiYWNjb3VudC50ZXN0bmV0IiwidGV4dCI6IlRlc3QgMiJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTc=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC1kcm9wLTEwLnRlc3RuZXQiLCJ0ZXh0IjoiRnJlZSBtZXNzYWdlcyBhcmUgdGhlIGJlc3QifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTg=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC1kcm9wLTEwLnRlc3RuZXQiLCJ0ZXh0IjoiV2hlbiBJQ08/In0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MTk=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC1kcm9wLTEwLnRlc3RuZXQiLCJ0ZXh0IjoiV2hlbiBJQ08/In0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6Mg==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoibnVsbCIsInRleHQiOiJ1bmRlZmluZWQifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MjA=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC04NDEudGVzdG5ldCIsInRleHQiOiJXaGVuIElDTz8ifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MjE=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC04NDEudGVzdG5ldCIsInRleHQiOiJoZXkgaGV5IGhleSJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MjI=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiam9zaGZvcmQudGVzdG5ldCIsInRleHQiOiJoaSJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MjM=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiam9zaGZvcmQudGVzdG5ldCIsInRleHQiOiJoaSB4MiJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MjQ=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoibWFzdGVydGh5c2VsZi50ZXN0bmV0IiwidGV4dCI6ImhhbmRzaGFrZS5oYWNrbWVkb21haW4vICJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MjU=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiSGVsbG8gQ29zbW9zLCBob21lLmNvc21hdHJpeGNvbm5lY3Rpb25zLyJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MjY=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiYnVpbGQsIGJ1aWxkLCBidWlsZCBpIGNhbWUgdG8gYnVpbGQgYSBicmlkZ2UgaW4gUEVBQ0UsIHNvIGNvbWUgbGV0cyBidWlsZC4uLnNvbmcgYnkgXCJOYWhrbyBCZWFyXCIgIn0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6Mjc=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiYnVpbGQgYSBicmlkZ2UgKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vdXJsP3NhPXQmcmN0PWomcT0mZXNyYz1zJnNvdXJjZT13ZWImY2Q9JmNhZD1yamEmdWFjdD04JnZlZD0yYWhVS0V3ajA0ZGlnMTlqckFoV05tbGtLSGR5X0FnUVEzeXd3QUhvRUNBVVFBZyZ1cmw9aHR0cHMlM0ElMkYlMkZ3d3cueW91dHViZS5jb20lMkZ3YXRjaCUzRnYlM0Rlb1RYNWZmOVplMCZ1c2c9QU92VmF3MFoxZzFIMkZzeF85d3FJSmg5RTk2UCkifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6Mjg=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiaHR0cDovL3RyaXBweS7wn42EbWFnaWMvIn0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6Mjk=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiaHR0cDovL3VuaXRlLnJhaW5ib3d0cmliZXMvIn0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6Mw==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiam9zaGZvcmQudGVzdG5ldCIsInRleHQiOiJobW1tbW1tIn0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MzA=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiZXhlbXBsYXJ5LnRlc3RuZXQiLCJ0ZXh0IjoiaGVsbG8ifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MzE=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiYWRpMjMudGVzdG5ldCIsInRleHQiOiJobW0ifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MzI=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiYWRpMjMudGVzdG5ldCIsInRleHQiOiJ3aGF0In0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6MzM=&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidmxhZGJhc2gudGVzdG5ldCIsInRleHQiOiJIaSJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6NA==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoibnVsbCIsInRleHQiOiIgIn0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6NQ==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJ0ZXN0YWNjb3VudDEudGVzdG5ldCIsInRleHQiOiJ0ZXN0In0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6Ng==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiZXVnZW5ldGhlZHJlYW0iLCJ0ZXh0IjoibnVsbCJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6Nw==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiZGVtby50ZXN0bmV0IiwidGV4dCI6Ikkgb25seSB3cml0ZSBmcmVlIG1lc3NhZ2VzLiJ9&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6OA==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJqb3NoZm9yZC50ZXN0bmV0IiwidGV4dCI6IkkgcHJlZmVyIHByZW1pdW0gbWVzc2FnZXMifQ==&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTo6OQ==&quot;,
        &quot;value&quot;: &quot;eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJuZXdsZWRnZXIzLnRlc3RuZXQiLCJ0ZXh0IjoiTGVkZ2VyIn0=&quot;,
        &quot;proof&quot;: []
      },
      {
        &quot;key&quot;: &quot;bTpsZW4=&quot;,
        &quot;value&quot;: &quot;MzQ=&quot;,
        &quot;proof&quot;: []
      }
    ],
    &quot;proof&quot;: [],
    &quot;block_height&quot;: 17814234,
    &quot;block_hash&quot;: &quot;GT1D8nweVQU1zyCUv399x8vDv2ogVq71w17MyR66hXBB&quot;
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<blockquote>
<p><strong>Heads up</strong></p>
<p>There is a limitation on default RPC nodes. You won't be able to get the contract state if it is too big. The default limit of for contract state is 50kb of state size. You're able to change the limits if you <a href="https://near-nodes.io/validator/compile-and-run-a-node">run your own RPC node</a> with adjusted <code>trie_viewer_state_size_limit</code> value in <code>config.json</code></p>
</blockquote>
<h4>What Could Go Wrong? {#what-could-go-wrong-3}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>view_state</code> request type:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;7&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INVALID_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; is invalid&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Provide a valid &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNKNOWN_ACCOUNT&lt;/td&gt;
&lt;td&gt;The requested &lt;code&gt;account_id&lt;/code&gt; has not been found while viewing since the account has not been created or has been already deleted&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the &lt;code&gt;account_id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Specify a different block or retry if you request the latest state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NO_CONTRACT_CODE&lt;/td&gt;
&lt;td&gt;The account does not have any &lt;code&gt;contract&lt;/code&gt; deployed on it&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Query and account with contract deployed&lt;/li&gt;
&lt;li&gt;Specify a different block or retry if you request the latest state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TOO_LARGE_CONTRACT_STATE&lt;/td&gt;
&lt;td&gt;The requested contract state is too large to be returned from this node (the default limit is 50kb of state size)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Send the request to a node with larger limits in order to view the requested state&lt;/li&gt;
&lt;li&gt;Spin up your own node where you can increase the limits to view state&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNAVAILABLE_SHARD&lt;/td&gt;
&lt;td&gt;The node was unable to find the requested data because it does not track the shard where data is present&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Send a request to a different node which might track the shard&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NO_SYNCED_BLOCKS&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/contracts#view-contract-state">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the View contract state changes?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns the state change details of a contract based on the key prefix (encoded to base64). Pass an empty string for this param if you would like to return all state changes.</p>
</blockquote>
<ul>
<li>method: <code>EXPERIMENTAL_changes</code></li>
<li>params:
<ul>
<li><code>changes_type</code>: <code>data_changes</code></li>
<li><code>account_ids</code>: <code>[&quot;example.testnet&quot;]</code>,</li>
<li><code>key_prefix_base64</code>: <code>&quot;base64 encoded key value&quot;</code>,</li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_changes&quot;,
  &quot;params&quot;: {
    &quot;changes_type&quot;: &quot;data_changes&quot;,
    &quot;account_ids&quot;: [&quot;guest-book.testnet&quot;],
    &quot;key_prefix_base64&quot;: &quot;&quot;,
    &quot;block_id&quot;: 19450732
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_changes({
  changes_type: &quot;data_changes&quot;,
  account_ids: [&quot;guest-book.testnet&quot;],
  key_prefix_base64: &quot;&quot;,
  block_id: 19450732,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    &quot;changes_type&quot;: &quot;data_changes&quot;,
    &quot;account_ids&quot;: [&quot;guest-book.testnet&quot;],
    &quot;key_prefix_base64&quot;: &quot;&quot;,
    &quot;block_id&quot;: 19450732
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;block_hash&quot;: &quot;6U8Yd4JFZwJUNfqkD4KaKgTKmpNSmVRTSggpjmsRWdKY&quot;,
    &quot;changes&quot;: [
      {
        &quot;cause&quot;: {
          &quot;type&quot;: &quot;receipt_processing&quot;,
          &quot;receipt_hash&quot;: &quot;9ewznXgs2t7vRCssxW4thgaiwggnMagKybZ7ryLNTT2z&quot;
        },
        &quot;type&quot;: &quot;data_update&quot;,
        &quot;change&quot;: {
          &quot;account_id&quot;: &quot;guest-book.testnet&quot;,
          &quot;key_base64&quot;: &quot;bTo6Mzk=&quot;,
          &quot;value_base64&quot;: &quot;eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiZmhyLnRlc3RuZXQiLCJ0ZXh0IjoiSGkifQ==&quot;
        }
      },
      {
        &quot;cause&quot;: {
          &quot;type&quot;: &quot;receipt_processing&quot;,
          &quot;receipt_hash&quot;: &quot;9ewznXgs2t7vRCssxW4thgaiwggnMagKybZ7ryLNTT2z&quot;
        },
        &quot;type&quot;: &quot;data_update&quot;,
        &quot;change&quot;: {
          &quot;account_id&quot;: &quot;guest-book.testnet&quot;,
          &quot;key_base64&quot;: &quot;bTpsZW4=&quot;,
          &quot;value_base64&quot;: &quot;NDA=&quot;
        }
      }
    ]
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong? {#what-could-go-wrong-4}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>EXPERIMENTAL_changes</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;2&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT_SYNCED_YET&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/contracts#view-contract-state-changes">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the View contract code changes?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns code changes made when deploying a contract. Change is returned is a base64 encoded WASM file.</p>
</blockquote>
<ul>
<li>method: <code>EXPERIMENTAL_changes</code></li>
<li>params:
<ul>
<li><code>changes_type</code>: <code>contract_code_changes</code></li>
<li><code>account_ids</code>: <code>[&quot;example.testnet&quot;]</code>,</li>
<li><a href="https://docs.near.org/api/rpc/api/rpc/setup#using-finality-param"><code>finality</code></a> <em>OR</em> <a href="https://docs.near.org/api/rpc/api/rpc/setup#using-block_id-param"><code>block_id</code></a>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_changes&quot;,
  &quot;params&quot;: {
    &quot;changes_type&quot;: &quot;contract_code_changes&quot;,
    &quot;account_ids&quot;: [&quot;dev-1602714453032-7566969&quot;],
    &quot;block_id&quot;: 20046655
  }
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_changes({
  changes_type: &quot;contract_code_changes&quot;,
  account_ids: [&quot;dev-1602714453032-7566969&quot;],
  block_id: 20046655,
});
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    &quot;changes_type&quot;: &quot;contract_code_changes&quot;,
    &quot;account_ids&quot;: [&quot;dev-1602714453032-7566969&quot;],
    &quot;block_id&quot;: 20046655
  }'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;block_hash&quot;: &quot;3yLNV5zdpzRJ8HP5xTXcF7jdFxuHnmKNUwWcok4616WZ&quot;,
    &quot;changes&quot;: [
      {
        &quot;cause&quot;: {
          &quot;type&quot;: &quot;receipt_processing&quot;,
          &quot;receipt_hash&quot;: &quot;CEm3NNaNdu9cijh9NvZMM1srbtEYSsBVwGbZxFQYKt5B&quot;
        },
        &quot;type&quot;: &quot;contract_code_update&quot;,
        &quot;change&quot;: {
          &quot;account_id&quot;: &quot;dev-1602714453032-7566969&quot;,
          &quot;code_base64&quot;: &quot;AGFzbQEAAAABpAM3YAF/AGAAAX9gAn9+AGADf35+AGAEf35+fgF+YAZ/fn5+fn4BfmADf35+AX5gAn9+AX5gAn9/AX9gAn9/AGADf39/AX9gAX8BfmACfn4AYAF+AX5gAX4AYAABfmADfn5+AGAAAGAIfn5+fn5+fn4BfmAJfn5+fn5+fn5+AX5gAn5+AX5gA35+fgF+YAd+fn5+fn5+AGAEfn5+fgBgCX5+fn5+fn5+fgBgBX5+fn5+AX5gA39/fwBgAX8Bf2ACf3wAYAR/f39+AGAFf39/fn8AYAV/f39/fwBgBH9/f38AYAN/f38BfmADf39+AGACf38BfmAFf39/f38Bf2AEf39/fwF/YAZ/f39/f38AYAV/f35/fwBgBH9+f38Bf2ACf34Bf2AHf35+f39+fwBgBX9/f39+AGAEf35+fgBgCX9+fn5+fn5+fgF+YAp/fn5+fn5+fn5+AX5gCH9+fn5+fn5+AGAFf35+fn4AYAp/fn5+fn5+fn5+AGAHf39/f39/fwBgBH98f38Bf2AGf39/f39...&quot;
        }
      }
    ]
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What Could Go Wrong? {#what-could-go-wrong-5}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>EXPERIMENTAL_changes</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;2&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;UNKNOWN_BLOCK&lt;/td&gt;
&lt;td&gt;The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check that the requested block is legit&lt;/li&gt;
&lt;li&gt;If the block had been produced more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT_SYNCED_YET&lt;/td&gt;
&lt;td&gt;The node is still syncing and the requested block is not in the database yet&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Wait until the node finish syncing&lt;/li&gt;
&lt;li&gt;Send a request to a different node which is synced&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/contracts#view-contract-code-changes">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Table of Resources?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.near.org/api/rpc/api/rpc/access-keys">Access Keys</a></td>
<td>Retrieve information about an account's access keys.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/api/rpc/api/rpc/contracts">Accounts / Contracts</a></td>
<td>View details about accounts and contracts as well as perform contract calls.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/api/rpc/api/rpc/block-chunk">Block / Chunk</a></td>
<td>Query the network and get details about specific blocks or chunks.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/api/rpc/api/rpc/gas">Gas</a></td>
<td>Get gas price for a specific block or hash.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/api/rpc/api/rpc/protocol">Protocol</a></td>
<td>Retrieve current genesis and protocol configuration.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/api/rpc/api/rpc/network">Network</a></td>
<td>Return status information for nodes and validators.</td>
</tr>
<tr>
<td><a href="https://docs.near.org/api/rpc/api/rpc/transactions">Transactions</a></td>
<td>Send transactions and query their status.</td>
</tr>
</tbody>
</table>
<p>You can access the JSON RPC 2.0 endpoints using <a href="https://docs.near.org/api/rpc/api/rpc/setup#postman-setup">Postman</a>,
<a href="https://docs.near.org/api/rpc/api/rpc/setup#javascript-setup">JavaScript</a>, and <a href="https://docs.near.org/api/rpc/api/rpc/setup#httpie-setup">HTTPie</a>.</p>
<p><a href="https://docs.near.org/api/rpc/introduction">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Node Status?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns general status of a given node (sync status, nearcore node version, protocol version, etc), and the current set of validators.</p>
</blockquote>
<ul>
<li>method: <code>status</code></li>
<li>params: <code>[]</code>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;status&quot;,
  &quot;params&quot;: []
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.status();
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 method=status params:='[]' id=dontcare
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;version&quot;: {
      &quot;version&quot;: &quot;1.14.0-rc.1&quot;,
      &quot;build&quot;: &quot;effa3b7a-modified&quot;
    },
    &quot;chain_id&quot;: &quot;testnet&quot;,
    &quot;protocol_version&quot;: 35,
    &quot;latest_protocol_version&quot;: 35,
    &quot;rpc_addr&quot;: &quot;0.0.0.0:3030&quot;,
    &quot;validators&quot;: [
      {
        &quot;account_id&quot;: &quot;node3&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;node0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;staked.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;01node.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;node2&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;dokia.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;node1&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;lowfeevalidation.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;sl1sub.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;zainy.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;chorus-one.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;thepassivetrust.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;certusone.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;joe1.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;bisontrails.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;valeraverim.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;lunanova.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;bazilik.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;dsrvlabs.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;kronos.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;nodeasy.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;kytzu.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;bitcat.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;pool_easy2stake.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;fresh_lockup.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;staking-power.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;syncnode.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;inotel.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;zpool.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;aquarius.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;cloudpost.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;staked.pool.6fb1358&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;moonlet.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;jazza.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;orangeclub.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;blazenet.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;pathrock.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;stakin.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;northernlights.stakingpool&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;alexandruast.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      },
      {
        &quot;account_id&quot;: &quot;top.pool.f863973.m0&quot;,
        &quot;is_slashed&quot;: false
      }
    ],
    &quot;sync_info&quot;: {
      &quot;latest_block_hash&quot;: &quot;44kieHwr7Gg5r72V3DgU7cpgV2aySkk5qbBCdvwens8T&quot;,
      &quot;latest_block_height&quot;: 17774278,
      &quot;latest_state_root&quot;: &quot;3MD3fQqnm3JYa9UQgenEJsR6UHoWuHV4Tpr4hZY7QwfY&quot;,
      &quot;latest_block_time&quot;: &quot;2020-09-27T23:59:38.008063088Z&quot;,
      &quot;syncing&quot;: false
    },
    &quot;validator_account_id&quot;: &quot;nearup-node8&quot;
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What could go wrong? {#what-could-go-wrong}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>status</code> method:
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/network#node-status">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Network Info?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns the current state of node network connections (active peers, transmitted data, etc.)</p>
</blockquote>
<ul>
<li>method: <code>network_info</code></li>
<li>params: <em>none</em>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;network_info&quot;,
  &quot;params&quot;: []
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 method=network_info params:='[]' id=dontcare
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response:&lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;active_peers&quot;: [
      {
        &quot;id&quot;: &quot;ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5&quot;,
        &quot;addr&quot;: &quot;35.193.24.121:24567&quot;,
        &quot;account_id&quot;: null
      }
    ],
    &quot;num_active_peers&quot;: 34,
    &quot;peer_max_count&quot;: 40,
    &quot;sent_bytes_per_sec&quot;: 17754754,
    &quot;received_bytes_per_sec&quot;: 492116,
    &quot;known_producers&quot;: [
      {
        &quot;account_id&quot;: &quot;node0&quot;,
        &quot;addr&quot;: null,
        &quot;peer_id&quot;: &quot;ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX&quot;
      }
    ]
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What could go wrong? {#what-could-go-wrong-1}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>network_info</code> method:
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/network#network-info">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Genesis Config?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Returns current genesis configuration.</p>
</blockquote>
<ul>
<li>method: <code>EXPERIMENTAL_genesis_config</code></li>
<li>params: <em>none</em>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_genesis_config&quot;
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_genesisConfig();
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_genesis_config
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;protocol_version&quot;: 29,
    &quot;genesis_time&quot;: &quot;2020-07-31T03:39:42.911378Z&quot;,
    &quot;chain_id&quot;: &quot;testnet&quot;,
    &quot;genesis_height&quot;: 10885359,
    &quot;num_block_producer_seats&quot;: 100,
    &quot;num_block_producer_seats_per_shard&quot;: [100],
    &quot;avg_hidden_validator_seats_per_shard&quot;: [0],
    &quot;dynamic_resharding&quot;: false,
    &quot;protocol_upgrade_stake_threshold&quot;: [4, 5],
    &quot;protocol_upgrade_num_epochs&quot;: 2,
    &quot;epoch_length&quot;: 43200,
    &quot;gas_limit&quot;: 1000000000000000,
    &quot;min_gas_price&quot;: &quot;5000&quot;,
    &quot;max_gas_price&quot;: &quot;10000000000000000000000&quot;,
    &quot;block_producer_kickout_threshold&quot;: 80,
    &quot;chunk_producer_kickout_threshold&quot;: 90,
    &quot;online_min_threshold&quot;: [90, 100],
    &quot;online_max_threshold&quot;: [99, 100],
    &quot;gas_price_adjustment_rate&quot;: [1, 100],
    &quot;runtime_config&quot;: {
      &quot;storage_amount_per_byte&quot;: &quot;90949470177292823791&quot;,
      &quot;transaction_costs&quot;: {
        &quot;action_receipt_creation_config&quot;: {
          &quot;send_sir&quot;: 108059500000,
          &quot;send_not_sir&quot;: 108059500000,
          &quot;execution&quot;: 108059500000
        },
        &quot;data_receipt_creation_config&quot;: {
          &quot;base_cost&quot;: {
            &quot;send_sir&quot;: 4697339419375,
            &quot;send_not_sir&quot;: 4697339419375,
            &quot;execution&quot;: 4697339419375
          },
          &quot;cost_per_byte&quot;: {
            &quot;send_sir&quot;: 59357464,
            &quot;send_not_sir&quot;: 59357464,
            &quot;execution&quot;: 59357464
          }
        },
        &quot;action_creation_config&quot;: {
          &quot;create_account_cost&quot;: {
            &quot;send_sir&quot;: 99607375000,
            &quot;send_not_sir&quot;: 99607375000,
            &quot;execution&quot;: 99607375000
          },
          &quot;deploy_contract_cost&quot;: {
            &quot;send_sir&quot;: 184765750000,
            &quot;send_not_sir&quot;: 184765750000,
            &quot;execution&quot;: 184765750000
          },
          &quot;deploy_contract_cost_per_byte&quot;: {
            &quot;send_sir&quot;: 6812999,
            &quot;send_not_sir&quot;: 6812999,
            &quot;execution&quot;: 6812999
          },
          &quot;function_call_cost&quot;: {
            &quot;send_sir&quot;: 2319861500000,
            &quot;send_not_sir&quot;: 2319861500000,
            &quot;execution&quot;: 2319861500000
          },
          &quot;function_call_cost_per_byte&quot;: {
            &quot;send_sir&quot;: 2235934,
            &quot;send_not_sir&quot;: 2235934,
            &quot;execution&quot;: 2235934
          },
          &quot;transfer_cost&quot;: {
            &quot;send_sir&quot;: 115123062500,
            &quot;send_not_sir&quot;: 115123062500,
            &quot;execution&quot;: 115123062500
          },
          &quot;stake_cost&quot;: {
            &quot;send_sir&quot;: 141715687500,
            &quot;send_not_sir&quot;: 141715687500,
            &quot;execution&quot;: 102217625000
          },
          &quot;add_key_cost&quot;: {
            &quot;full_access_cost&quot;: {
              &quot;send_sir&quot;: 101765125000,
              &quot;send_not_sir&quot;: 101765125000,
              &quot;execution&quot;: 101765125000
            },
            &quot;function_call_cost&quot;: {
              &quot;send_sir&quot;: 102217625000,
              &quot;send_not_sir&quot;: 102217625000,
              &quot;execution&quot;: 102217625000
            },
            &quot;function_call_cost_per_byte&quot;: {
              &quot;send_sir&quot;: 1925331,
              &quot;send_not_sir&quot;: 1925331,
              &quot;execution&quot;: 1925331
            }
          },
          &quot;delete_key_cost&quot;: {
            &quot;send_sir&quot;: 94946625000,
            &quot;send_not_sir&quot;: 94946625000,
            &quot;execution&quot;: 94946625000
          },
          &quot;delete_account_cost&quot;: {
            &quot;send_sir&quot;: 147489000000,
            &quot;send_not_sir&quot;: 147489000000,
            &quot;execution&quot;: 147489000000
          }
        },
        &quot;storage_usage_config&quot;: {
          &quot;num_bytes_account&quot;: 100,
          &quot;num_extra_bytes_record&quot;: 40
        },
        &quot;burnt_gas_reward&quot;: [3, 10],
        &quot;pessimistic_gas_price_inflation_ratio&quot;: [103, 100]
      },
      &quot;wasm_config&quot;: {
        &quot;ext_costs&quot;: {
          &quot;base&quot;: 264768111,
          &quot;contract_compile_base&quot;: 35445963,
          &quot;contract_compile_bytes&quot;: 216750,
          &quot;read_memory_base&quot;: 2609863200,
          &quot;read_memory_byte&quot;: 3801333,
          &quot;write_memory_base&quot;: 2803794861,
          &quot;write_memory_byte&quot;: 2723772,
          &quot;read_register_base&quot;: 2517165186,
          &quot;read_register_byte&quot;: 98562,
          &quot;write_register_base&quot;: 2865522486,
          &quot;write_register_byte&quot;: 3801564,
          &quot;utf8_decoding_base&quot;: 3111779061,
          &quot;utf8_decoding_byte&quot;: 291580479,
          &quot;utf16_decoding_base&quot;: 3543313050,
          &quot;utf16_decoding_byte&quot;: 163577493,
          &quot;sha256_base&quot;: 4540970250,
          &quot;sha256_byte&quot;: 24117351,
          &quot;keccak256_base&quot;: 5879491275,
          &quot;keccak256_byte&quot;: 21471105,
          &quot;keccak512_base&quot;: 5811388236,
          &quot;keccak512_byte&quot;: 36649701,
          &quot;log_base&quot;: 3543313050,
          &quot;log_byte&quot;: 13198791,
          &quot;storage_write_base&quot;: 64196736000,
          &quot;storage_write_key_byte&quot;: 70482867,
          &quot;storage_write_value_byte&quot;: 31018539,
          &quot;storage_write_evicted_byte&quot;: 32117307,
          &quot;storage_read_base&quot;: 56356845750,
          &quot;storage_read_key_byte&quot;: 30952533,
          &quot;storage_read_value_byte&quot;: 5611005,
          &quot;storage_remove_base&quot;: 53473030500,
          &quot;storage_remove_key_byte&quot;: 38220384,
          &quot;storage_remove_ret_value_byte&quot;: 11531556,
          &quot;storage_has_key_base&quot;: 54039896625,
          &quot;storage_has_key_byte&quot;: 30790845,
          &quot;storage_iter_create_prefix_base&quot;: 0,
          &quot;storage_iter_create_prefix_byte&quot;: 0,
          &quot;storage_iter_create_range_base&quot;: 0,
          &quot;storage_iter_create_from_byte&quot;: 0,
          &quot;storage_iter_create_to_byte&quot;: 0,
          &quot;storage_iter_next_base&quot;: 0,
          &quot;storage_iter_next_key_byte&quot;: 0,
          &quot;storage_iter_next_value_byte&quot;: 0,
          &quot;touching_trie_node&quot;: 16101955926,
          &quot;promise_and_base&quot;: 1465013400,
          &quot;promise_and_per_promise&quot;: 5452176,
          &quot;promise_return&quot;: 560152386,
          &quot;validator_stake_base&quot;: 911834726400,
          &quot;validator_total_stake_base&quot;: 911834726400
        },
        &quot;grow_mem_cost&quot;: 1,
        &quot;regular_op_cost&quot;: 3856371,
        &quot;limit_config&quot;: {
          &quot;max_gas_burnt&quot;: 200000000000000,
          &quot;max_gas_burnt_view&quot;: 200000000000000,
          &quot;max_stack_height&quot;: 16384,
          &quot;initial_memory_pages&quot;: 1024,
          &quot;max_memory_pages&quot;: 2048,
          &quot;registers_memory_limit&quot;: 1073741824,
          &quot;max_register_size&quot;: 104857600,
          &quot;max_number_registers&quot;: 100,
          &quot;max_number_logs&quot;: 100,
          &quot;max_total_log_length&quot;: 16384,
          &quot;max_total_prepaid_gas&quot;: 300000000000000,
          &quot;max_actions_per_receipt&quot;: 100,
          &quot;max_number_bytes_method_names&quot;: 2000,
          &quot;max_length_method_name&quot;: 256,
          &quot;max_arguments_length&quot;: 4194304,
          &quot;max_length_returned_data&quot;: 4194304,
          &quot;max_contract_size&quot;: 4194304,
          &quot;max_length_storage_key&quot;: 4194304,
          &quot;max_length_storage_value&quot;: 4194304,
          &quot;max_promises_per_function_call_action&quot;: 1024,
          &quot;max_number_input_data_dependencies&quot;: 128
        }
      },
      &quot;account_creation_config&quot;: {
        &quot;min_allowed_top_level_account_length&quot;: 0,
        &quot;registrar_account_id&quot;: &quot;registrar&quot;
      }
    },
    &quot;validators&quot;: [
      {
        &quot;account_id&quot;: &quot;node0&quot;,
        &quot;public_key&quot;: &quot;ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX&quot;,
        &quot;amount&quot;: &quot;1000000000000000000000000000000&quot;
      },
      {
        &quot;account_id&quot;: &quot;node1&quot;,
        &quot;public_key&quot;: &quot;ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e&quot;,
        &quot;amount&quot;: &quot;1000000000000000000000000000000&quot;
      },
      {
        &quot;account_id&quot;: &quot;node2&quot;,
        &quot;public_key&quot;: &quot;ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5&quot;,
        &quot;amount&quot;: &quot;1000000000000000000000000000000&quot;
      },
      {
        &quot;account_id&quot;: &quot;node3&quot;,
        &quot;public_key&quot;: &quot;ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su&quot;,
        &quot;amount&quot;: &quot;1000000000000000000000000000000&quot;
      }
    ],
    &quot;transaction_validity_period&quot;: 86400,
    &quot;protocol_reward_rate&quot;: [1, 10],
    &quot;max_inflation_rate&quot;: [1, 20],
    &quot;total_supply&quot;: &quot;1031467299046044096035532756810080&quot;,
    &quot;num_blocks_per_year&quot;: 31536000,
    &quot;protocol_treasury_account&quot;: &quot;near&quot;,
    &quot;fishermen_threshold&quot;: &quot;10000000000000000000&quot;,
    &quot;minimum_stake_divisor&quot;: 10
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What could go wrong? {#what-could-go-wrong}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>EXPERIMENTAL_genesis_config</code> method:
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/protocol#genesis-config">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Postman Setup?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>An easy way to test the queries in this documentation page is to use an API request tool such as <a href="https://www.postman.com/">Postman</a>.
You only need to configure two things:</p>
<ol>
<li>Make sure you add a header with a key of <code>Content-Type</code> and value of <code>application/json</code>.
<img src="https://docs.near.org/docs/assets/postman-setup-headers.png" alt="postman-setup-header"></li>
<li>Then select the <code>Body</code> tab and choose the <code>raw</code> radio button and ensure <code>JSON</code> is the selected format.
<img src="/docs/assets/postman-setup-body.png" alt="postman-setup-header">
After that is set up, just copy/paste the <code>JSON object</code> example snippets below into the <code>body</code> of your request, on Postman, and click <code>send</code>.</li>
</ol>
<p><a href="https://docs.near.org/api/rpc/setup#postman-setup">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the JavaScript Setup?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>All of the queries listed in this documentation page can be called using <a href="https://github.com/near/near-api-js"><code>near-api-js</code></a>.</p>
<ul>
<li>For <code>near-api-js</code> installation and setup please refer to <code>near-api-js</code> <a href="https://docs.near.org/tools/near-api-js/quick-reference">quick reference documentation</a>.</li>
<li>All JavaScript code snippets below require a <code>near</code> object. For examples of how to instantiate, <a href="https://docs.near.org/tools/near-api-js/quick-reference#connect-connect"><strong>click here</strong></a>.</li>
</ul>
<p><a href="https://docs.near.org/api/rpc/setup#javascript-setup">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the HTTPie Setup?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>If you prefer to use a command line interface, we have provided RPC examples you can use with <a href="https://httpie.org/">HTTPie</a>. Please note that params take
either an object or array passed as a string.</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=network_info params:='[]'
</code></pre>
<p><a href="https://docs.near.org/api/rpc/setup#httpie-setup">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Using <code>block_id</code> param?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>The <code>block_id</code> param can take either the block number (e.g. <code>27912554</code>) or the block hash (e.g. <code>'3Xz2wM9rigMXzA2c5vgCP8wTgFBaePucgUmVYPkMqhRL'</code> ) as an argument.
caution
The block IDs of transactions shown in &lt;a href=&quot;https://explorer.testnet.near.org&quot;&gt;NEAR Explorer&lt;/a&gt; are not necessarily the block ID of the executed transaction. Transactions may execute a block or two after its recorded, and in some cases, can take place over several blocks. Due to this, it is important to to check subsequent blocks to be sure all results related to the queried transaction are discovered.</p>
<p><a href="https://docs.near.org/api/rpc/setup#using-block_id-param">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Send transaction (async)?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Sends a transaction and immediately returns transaction hash.</p>
</blockquote>
<ul>
<li>method: <code>broadcast_tx_async</code></li>
<li>params: [SignedTransaction encoded in base64]
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;broadcast_tx_async&quot;,
  &quot;params&quot;: [
    &quot;DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE=&quot;
  ]
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_async \
    params:='[
        &quot;DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE=&quot;
    ]'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
Example response:</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: &quot;6zgh2u9DqHHiXzdy9ouTP7oGky2T4nugqzqt9wJZwNFm&quot;,
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>Final transaction results can be queried using <a href="https://docs.near.org/api/rpc/#transaction-status">Transaction Status</a>
or <a href="https://explorer.testnet.near.org/">NEAR Explorer</a> using the above <code>result</code> hash returning a result similar to the example below.
<img src="https://docs.near.org/docs/assets/NEAR-Explorer-transactionHash.png" alt="NEAR-Explorer-transactionHash"></p>
<h4>What could go wrong? {#what-could-go-wrong}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>broadcast_tx_async</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/transactions#send-transaction-async">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Send transaction (await)?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Sends a transaction and waits until transaction is fully complete. <em>(Has a 10 second timeout)</em></p>
</blockquote>
<ul>
<li>method: <code>broadcast_tx_commit</code></li>
<li>params: <code>[SignedTransaction encoded in base64]</code>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;broadcast_tx_commit&quot;,
  &quot;params&quot;: [
    &quot;DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDQAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldIODI4YfV/QS++blXpQYT+bOsRblTRW4f547y/LkvMQ9AQAAAAMAAACh7czOG8LTAAAAAAAAAAXcaTJzu9GviPT7AD4mNJGY79jxTrjFLoyPBiLGHgBi8JK1AnhK8QknJ1ourxlvOYJA2xEZE8UR24THmSJcLQw=&quot;
  ]
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
    params:='[
        &quot;DwAAAG5lYXJrYXQudGVzdG5ldABuTi5L1rwnlb35hc9tn5WELkxfiGfGh1Q5aeGNQDejo0QAAAAAAAAAEAAAAGpvc2hmb3JkLnRlc3RuZXSiWAc6W9KlqXS5fK+vjFRDV5pAxHRKU0srKX/cmdRTBgEAAAADAAAAoe3MzhvC0wAAAAAAAAB9rOE9zc5zQYLL1j6VTh3I4fQbERs6I07gJfrAC6jo8DB4HolR9Xps3v4qrZxkgZjwv6wB0QOROM4UEbeOaBoB&quot;
    ]'
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;
&lt;summary&gt;Example response: &lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;status&quot;: {
      &quot;SuccessValue&quot;: &quot;&quot;
    },
    &quot;transaction&quot;: {
      &quot;signer_id&quot;: &quot;sender.testnet&quot;,
      &quot;public_key&quot;: &quot;ed25519:Gowpa4kXNyTMRKgt5W7147pmcc2PxiFic8UHW9rsNvJ6&quot;,
      &quot;nonce&quot;: 13,
      &quot;receiver_id&quot;: &quot;receiver.testnet&quot;,
      &quot;actions&quot;: [
        {
          &quot;Transfer&quot;: {
            &quot;deposit&quot;: &quot;1000000000000000000000000&quot;
          }
        }
      ],
      &quot;signature&quot;: &quot;ed25519:7oCBMfSHrZkT7tzPDBxxCd3tWFhTES38eks3MCZMpYPJRfPWKxJsvmwQiVBBxRLoxPTnXVaMU2jPV3MdFKZTobH&quot;,
      &quot;hash&quot;: &quot;ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR&quot;
    },
    &quot;transaction_outcome&quot;: {
      &quot;proof&quot;: [],
      &quot;block_hash&quot;: &quot;9MzuZrRPW1BGpFnZJUJg6SzCrixPpJDfjsNeUobRXsLe&quot;,
      &quot;id&quot;: &quot;ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR&quot;,
      &quot;outcome&quot;: {
        &quot;logs&quot;: [],
        &quot;receipt_ids&quot;: [&quot;BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh&quot;],
        &quot;gas_burnt&quot;: 223182562500,
        &quot;tokens_burnt&quot;: &quot;22318256250000000000&quot;,
        &quot;executor_id&quot;: &quot;sender.testnet&quot;,
        &quot;status&quot;: {
          &quot;SuccessReceiptId&quot;: &quot;BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh&quot;
        }
      }
    },
    &quot;receipts_outcome&quot;: [
      {
        &quot;proof&quot;: [],
        &quot;block_hash&quot;: &quot;5Hpj1PeCi32ZkNXgiD1DrW4wvW4Xtic74DJKfyJ9XL3a&quot;,
        &quot;id&quot;: &quot;BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh&quot;,
        &quot;outcome&quot;: {
          &quot;logs&quot;: [],
          &quot;receipt_ids&quot;: [&quot;3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR&quot;],
          &quot;gas_burnt&quot;: 223182562500,
          &quot;tokens_burnt&quot;: &quot;22318256250000000000&quot;,
          &quot;executor_id&quot;: &quot;receiver.testnet&quot;,
          &quot;status&quot;: {
            &quot;SuccessValue&quot;: &quot;&quot;
          }
        }
      },
      {
        &quot;proof&quot;: [],
        &quot;block_hash&quot;: &quot;CbwEqMpPcu6KwqVpBM3Ry83k6M4H1FrJjES9kBXThcRd&quot;,
        &quot;id&quot;: &quot;3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR&quot;,
        &quot;outcome&quot;: {
          &quot;logs&quot;: [],
          &quot;receipt_ids&quot;: [],
          &quot;gas_burnt&quot;: 0,
          &quot;tokens_burnt&quot;: &quot;0&quot;,
          &quot;executor_id&quot;: &quot;sender.testnet&quot;,
          &quot;status&quot;: {
            &quot;SuccessValue&quot;: &quot;&quot;
          }
        }
      }
    ]
  },
  &quot;id&quot;: &quot;dontcare&quot;
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What could go wrong? {#what-could-go-wrong-1}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>broadcast_tx_commit</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;2&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;INVALID_TRANSACTION&lt;/td&gt;
&lt;td&gt;An error happened during transaction execution&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;See &lt;code&gt;error.cause.info&lt;/code&gt; for details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIMEOUT_ERROR&lt;/td&gt;
&lt;td&gt;Transaction was routed, but has not been recorded on chain in 10 seconds.&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt; Re-submit the request with the identical transaction (in NEAR Protocol unique transactions apply exactly once, so if the previously sent transaction gets applied, this request will just return the known result, otherwise, it will route the transaction to the chain once again)&lt;/li&gt;
&lt;li&gt;Check that your transaction is valid&lt;/li&gt;
&lt;li&gt;Check that the signer account id has enough tokens to cover the transaction fees (keep in mind that some tokens on each account are locked to cover the storage cost)&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/transactions#send-transaction-await">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Transaction Status with Receipts?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><blockquote>
<p>Queries status of a transaction by hash, returning the final transaction result <em>and</em> details of all receipts.</p>
</blockquote>
<ul>
<li>method: <code>EXPERIMENTAL_tx_status</code></li>
<li>params:
<ul>
<li><code>transaction hash</code> <em>(see <a href="https://explorer.testnet.near.org">NEAR Explorer</a> for a valid transaction hash)</em></li>
<li><code>sender account id</code> <em>(used to determine which shard to query for transaction)</em>
Example:
&lt;Tabs&gt;
&lt;TabItem value=&quot;json&quot; label=&quot;JSON&quot; default&gt;</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;dontcare&quot;,
  &quot;method&quot;: &quot;EXPERIMENTAL_tx_status&quot;,
  &quot;params&quot;: [&quot;HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd&quot;, &quot;bowen&quot;]
}
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;js&quot; label=&quot;JavaScript&quot;&gt;</p>
<pre><code class="language-js">const response = await near.connection.provider.experimental_txStatus(
  &quot;HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd&quot;,
  &quot;bowen&quot;
);
</code></pre>
<p>&lt;/TabItem&gt;
&lt;TabItem value=&quot;http&quot; label=&quot;HTTPie&quot;&gt;</p>
<pre><code class="language-bash">http post https://rpc.testnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status params:='[&quot;HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd&quot;, &quot;bowen&quot;]' id=dontcare
</code></pre>
<p>&lt;/TabItem&gt;
&lt;/Tabs&gt;
&lt;details&gt;&lt;summary&gt;Example response:&lt;/summary&gt;
&lt;p&gt;</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;123&quot;,
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;receipts&quot;: [
      {
        &quot;predecessor_id&quot;: &quot;bowen&quot;,
        &quot;receipt&quot;: {
          &quot;Action&quot;: {
            &quot;actions&quot;: [
              {
                &quot;FunctionCall&quot;: {
                  &quot;args&quot;: &quot;eyJhbW91bnQiOiIxMDAwIiwicmVjZWl2ZXJfaWQiOiJib3dlbiJ9&quot;,
                  &quot;deposit&quot;: &quot;0&quot;,
                  &quot;gas&quot;: 100000000000000,
                  &quot;method_name&quot;: &quot;transfer&quot;
                }
              }
            ],
            &quot;gas_price&quot;: &quot;186029458&quot;,
            &quot;input_data_ids&quot;: [],
            &quot;output_data_receivers&quot;: [],
            &quot;signer_id&quot;: &quot;bowen&quot;,
            &quot;signer_public_key&quot;: &quot;ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK&quot;
          }
        },
        &quot;receipt_id&quot;: &quot;FXMVxdhSUZaZftbmPJWaoqhEB9GrKB2oqg9Wgvuyvom8&quot;,
        &quot;receiver_id&quot;: &quot;evgeny.lockup.m0&quot;
      },
      {
        &quot;predecessor_id&quot;: &quot;evgeny.lockup.m0&quot;,
        &quot;receipt&quot;: {
          &quot;Action&quot;: {
            &quot;actions&quot;: [
              {
                &quot;Transfer&quot;: {
                  &quot;deposit&quot;: &quot;1000&quot;
                }
              }
            ],
            &quot;gas_price&quot;: &quot;186029458&quot;,
            &quot;input_data_ids&quot;: [],
            &quot;output_data_receivers&quot;: [],
            &quot;signer_id&quot;: &quot;bowen&quot;,
            &quot;signer_public_key&quot;: &quot;ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK&quot;
          }
        },
        &quot;receipt_id&quot;: &quot;3Ad7pUygUegMUWUb1rEazfjnTaHfptXCABqKQ6WNq6Wa&quot;,
        &quot;receiver_id&quot;: &quot;bowen&quot;
      },
      {
        &quot;predecessor_id&quot;: &quot;system&quot;,
        &quot;receipt&quot;: {
          &quot;Action&quot;: {
            &quot;actions&quot;: [
              {
                &quot;Transfer&quot;: {
                  &quot;deposit&quot;: &quot;19200274886926125000&quot;
                }
              }
            ],
            &quot;gas_price&quot;: &quot;0&quot;,
            &quot;input_data_ids&quot;: [],
            &quot;output_data_receivers&quot;: [],
            &quot;signer_id&quot;: &quot;bowen&quot;,
            &quot;signer_public_key&quot;: &quot;ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK&quot;
          }
        },
        &quot;receipt_id&quot;: &quot;5DdQg9pfoJMX1q6bvhsjyyRihzA3sb9Uq5K1J7vK43Ze&quot;,
        &quot;receiver_id&quot;: &quot;bowen&quot;
      },
      {
        &quot;predecessor_id&quot;: &quot;system&quot;,
        &quot;receipt&quot;: {
          &quot;Action&quot;: {
            &quot;actions&quot;: [
              {
                &quot;Transfer&quot;: {
                  &quot;deposit&quot;: &quot;18663792669276228632284&quot;
                }
              }
            ],
            &quot;gas_price&quot;: &quot;0&quot;,
            &quot;input_data_ids&quot;: [],
            &quot;output_data_receivers&quot;: [],
            &quot;signer_id&quot;: &quot;bowen&quot;,
            &quot;signer_public_key&quot;: &quot;ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK&quot;
          }
        },
        &quot;receipt_id&quot;: &quot;FDp8ovTf5uJYDFemW5op6ebjCT2n4CPExHYie3S1h4qp&quot;,
        &quot;receiver_id&quot;: &quot;bowen&quot;
      }
    ],
    &quot;receipts_outcome&quot;: [
      {
        &quot;block_hash&quot;: &quot;HuqYrYsC7h2VERFMgFkqaNqSiFuTH9CA3uJr3BkyNxhF&quot;,
        &quot;id&quot;: &quot;FXMVxdhSUZaZftbmPJWaoqhEB9GrKB2oqg9Wgvuyvom8&quot;,
        &quot;outcome&quot;: {
          &quot;executor_id&quot;: &quot;evgeny.lockup.m0&quot;,
          &quot;gas_burnt&quot;: 3493189769144,
          &quot;logs&quot;: [&quot;Transferring 1000 to account @bowen&quot;],
          &quot;receipt_ids&quot;: [
            &quot;3Ad7pUygUegMUWUb1rEazfjnTaHfptXCABqKQ6WNq6Wa&quot;,
            &quot;FDp8ovTf5uJYDFemW5op6ebjCT2n4CPExHYie3S1h4qp&quot;
          ],
          &quot;status&quot;: {
            &quot;SuccessReceiptId&quot;: &quot;3Ad7pUygUegMUWUb1rEazfjnTaHfptXCABqKQ6WNq6Wa&quot;
          },
          &quot;tokens_burnt&quot;: &quot;349318976914400000000&quot;
        },
        &quot;proof&quot;: [
          {
            &quot;direction&quot;: &quot;Right&quot;,
            &quot;hash&quot;: &quot;5WwHEszBcpfrHnt2VTvVDVnEEACNq5EpQdjz1aW9gTAa&quot;
          }
        ]
      },
      {
        &quot;block_hash&quot;: &quot;DJ6oK5FtPPSwksS6pKdEjFvHWAaSVocnVNLoyi8aYk1k&quot;,
        &quot;id&quot;: &quot;3Ad7pUygUegMUWUb1rEazfjnTaHfptXCABqKQ6WNq6Wa&quot;,
        &quot;outcome&quot;: {
          &quot;executor_id&quot;: &quot;bowen&quot;,
          &quot;gas_burnt&quot;: 223182562500,
          &quot;logs&quot;: [],
          &quot;receipt_ids&quot;: [&quot;5DdQg9pfoJMX1q6bvhsjyyRihzA3sb9Uq5K1J7vK43Ze&quot;],
          &quot;status&quot;: {
            &quot;SuccessValue&quot;: &quot;&quot;
          },
          &quot;tokens_burnt&quot;: &quot;22318256250000000000&quot;
        },
        &quot;proof&quot;: [
          {
            &quot;direction&quot;: &quot;Right&quot;,
            &quot;hash&quot;: &quot;CXSXmKpDU8R3UUrBAsffWMeGfKanKqEHCQrHeZkR3RKT&quot;
          },
          {
            &quot;direction&quot;: &quot;Right&quot;,
            &quot;hash&quot;: &quot;2dNo7A1VHKBmMA86m1k3Z9DVXwWgQJGkKGRg8wUR3co9&quot;
          }
        ]
      },
      {
        &quot;block_hash&quot;: &quot;9cjUoqAksMbs7ZJ4CXiuwm8vppz9QctTwGmgwZ5mDmUA&quot;,
        &quot;id&quot;: &quot;5DdQg9pfoJMX1q6bvhsjyyRihzA3sb9Uq5K1J7vK43Ze&quot;,
        &quot;outcome&quot;: {
          &quot;executor_id&quot;: &quot;bowen&quot;,
          &quot;gas_burnt&quot;: 0,
          &quot;logs&quot;: [],
          &quot;receipt_ids&quot;: [],
          &quot;status&quot;: {
            &quot;SuccessValue&quot;: &quot;&quot;
          },
          &quot;tokens_burnt&quot;: &quot;0&quot;
        },
        &quot;proof&quot;: []
      },
      {
        &quot;block_hash&quot;: &quot;DJ6oK5FtPPSwksS6pKdEjFvHWAaSVocnVNLoyi8aYk1k&quot;,
        &quot;id&quot;: &quot;FDp8ovTf5uJYDFemW5op6ebjCT2n4CPExHYie3S1h4qp&quot;,
        &quot;outcome&quot;: {
          &quot;executor_id&quot;: &quot;bowen&quot;,
          &quot;gas_burnt&quot;: 0,
          &quot;logs&quot;: [],
          &quot;receipt_ids&quot;: [],
          &quot;status&quot;: {
            &quot;SuccessValue&quot;: &quot;&quot;
          },
          &quot;tokens_burnt&quot;: &quot;0&quot;
        },
        &quot;proof&quot;: [
          {
            &quot;direction&quot;: &quot;Left&quot;,
            &quot;hash&quot;: &quot;A2Ry6NCeuK8WhRCWc41hy6uddadc5nLJ1NBX5wVYo3Yb&quot;
          },
          {
            &quot;direction&quot;: &quot;Right&quot;,
            &quot;hash&quot;: &quot;2dNo7A1VHKBmMA86m1k3Z9DVXwWgQJGkKGRg8wUR3co9&quot;
          }
        ]
      }
    ],
    &quot;status&quot;: {
      &quot;SuccessValue&quot;: &quot;&quot;
    },
    &quot;transaction&quot;: {
      &quot;actions&quot;: [
        {
          &quot;FunctionCall&quot;: {
            &quot;args&quot;: &quot;eyJhbW91bnQiOiIxMDAwIiwicmVjZWl2ZXJfaWQiOiJib3dlbiJ9&quot;,
            &quot;deposit&quot;: &quot;0&quot;,
            &quot;gas&quot;: 100000000000000,
            &quot;method_name&quot;: &quot;transfer&quot;
          }
        }
      ],
      &quot;hash&quot;: &quot;HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd&quot;,
      &quot;nonce&quot;: 77,
      &quot;public_key&quot;: &quot;ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK&quot;,
      &quot;receiver_id&quot;: &quot;evgeny.lockup.m0&quot;,
      &quot;signature&quot;: &quot;ed25519:5v1hJuw5RppKGezJHBFU6z3hwmmdferETud9rUbwxVf6xSBAWyiod93Lezaq4Zdcp4zbukDusQY9PjhV47JVCgBx&quot;,
      &quot;signer_id&quot;: &quot;bowen&quot;
    },
    &quot;transaction_outcome&quot;: {
      &quot;block_hash&quot;: &quot;9RX2pefXKw8M4EYjLznDF3AMvbkf9asAjN8ACK7gxKsa&quot;,
      &quot;id&quot;: &quot;HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd&quot;,
      &quot;outcome&quot;: {
        &quot;executor_id&quot;: &quot;bowen&quot;,
        &quot;gas_burnt&quot;: 2428026088898,
        &quot;logs&quot;: [],
        &quot;receipt_ids&quot;: [&quot;FXMVxdhSUZaZftbmPJWaoqhEB9GrKB2oqg9Wgvuyvom8&quot;],
        &quot;status&quot;: {
          &quot;SuccessReceiptId&quot;: &quot;FXMVxdhSUZaZftbmPJWaoqhEB9GrKB2oqg9Wgvuyvom8&quot;
        },
        &quot;tokens_burnt&quot;: &quot;242802608889800000000&quot;
      },
      &quot;proof&quot;: [
        {
          &quot;direction&quot;: &quot;Right&quot;,
          &quot;hash&quot;: &quot;DXf4XVmAF5jnjZhcxi1CYxGPuuQrcAmayq9X5inSAYvJ&quot;
        }
      ]
    }
  }
}
</code></pre>
<p>&lt;/p&gt;
&lt;/details&gt;</p>
<h4>What could go wrong? {#what-could-go-wrong-3}</h4>
<p>When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow <a href="https://github.com/joyent/node-verror">verror</a> convention for structuring the error response:</p>
<pre><code class="language-json">{
    &quot;error&quot;: {
        &quot;name&quot;: &lt;ERROR_TYPE&gt;,
        &quot;cause&quot;: {
            &quot;info&quot;: {..},
            &quot;name&quot;: &lt;ERROR_CAUSE&gt;
        },
        &quot;code&quot;: -32000,
        &quot;data&quot;: String,
        &quot;message&quot;: &quot;Server error&quot;,
    },
    &quot;id&quot;: &quot;dontcare&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;
}
</code></pre>
<blockquote>
<p><strong>Heads up</strong></p>
<p>The fields <code>code</code>, <code>data</code>, and <code>message</code> in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.
Here is the exhaustive list of the error variants that can be returned by <code>EXPERIMENTAL_tx_status</code> method:
&lt;table class=&quot;custom-stripe&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
ERROR_TYPE&lt;br /&gt;
&lt;code&gt;error.name&lt;/code&gt;
&lt;/th&gt;
&lt;th&gt;ERROR_CAUSE&lt;br /&gt;&lt;code&gt;error.cause.name&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;th&gt;Solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;3&quot;&gt;HANDLER_ERROR&lt;/td&gt;
&lt;td&gt;INVALID_TRANSACTION&lt;/td&gt;
&lt;td&gt;An error happened during transaction execution&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;See &lt;code&gt;error.cause.info&lt;/code&gt; for details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNKNOWN_TRANSACTION&lt;/td&gt;
&lt;td&gt;The requested transaction is not available on the node since it might have not been recorded on the chain yet or has been garbage-collected&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;If the transaction had been submitted more than 5 epochs ago, try to send your request to &lt;a href=&quot;https://near-nodes.io/intro/node-types#archival-node&quot;&gt;an archival node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Check the transaction hash&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIMEOUT_ERROR&lt;/td&gt;
&lt;td&gt;It was unable to wait for the transaction status for reasonable time&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;stripe&quot;&gt;
&lt;td&gt;REQUEST_VALIDATION_ERROR&lt;/td&gt;
&lt;td&gt;PARSE_ERROR&lt;/td&gt;
&lt;td&gt;Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Check the arguments passed and pass the correct ones&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;INTERNAL_ERROR&lt;/td&gt;
&lt;td&gt;Something went wrong with the node itself or overloaded&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;Try again later&lt;/li&gt;
&lt;li&gt;Send a request to a different node&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;error.cause.info&lt;/code&gt; for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
</blockquote>
<p><a href="https://docs.near.org/api/rpc/transactions#transaction-status-with-receipts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Setup?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ol>
<li>Clone the <a href="https://github.com/near-examples/transaction-examples">transaction-examples</a> repository by running:</li>
</ol>
<pre><code class="language-bash">git clone https://github.com/near-examples/transaction-examples.git
</code></pre>
<ol start="2">
<li>Follow <a href="https://github.com/near-examples/transaction-examples/blob/master/README#prerequisites">setup instructions</a></li>
</ol>
<p><a href="https://docs.near.org/integrator/create-transactions#setup">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Imports?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In <a href="https://github.com/near-examples/transaction-examples/blob/9e999253aafa2c3e3b537810a0b8ce7596c3506c/send-tokens-easy.js#L1-L5"><code>send-tokens-easy.js</code></a> we use two dependencies:</p>
<ol>
<li><a href="https://github.com/near/near-api-js">NEAR API JavaScript library</a></li>
<li><a href="https://www.npmjs.com/package/dotenv"><code>dotenv</code></a> (used to load environment variables for private key)</li>
</ol>
<pre><code class="language-js">const nearAPI = require(&quot;near-api-js&quot;);
const { connect, KeyPair, keyStores, utils } = nearAPI;
require(&quot;dotenv&quot;).config();
</code></pre>
<p>The second line above deconstructs several utilities from nearAPI that you will use to interact with the blockchain.</p>
<ul>
<li><code>connect</code> - create a connection to NEAR passing configuration variables</li>
<li><code>KeyPair</code> - creates a keyPair from the private key you'll provide in an <code>.env</code> file</li>
<li><code>keyStores</code> - stores the keyPair that you will create from the private key and used to sign Transactions</li>
<li><code>utils</code> - used to format NEAR amounts</li>
</ul>
<p><a href="https://docs.near.org/integrator/create-transactions#imports">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Accounts &amp; Network?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Next, you'll need to enter the <code>accountId</code> of the <code>sender</code> and <code>receiver</code>, as well as the <code>networkId</code> (<code>betanet</code>, <code>testnet</code>, or <code>mainnet</code>).</p>
<pre><code class="language-js">const sender = &quot;sender.testnet&quot;;
const receiver = &quot;receiver.testnet&quot;;
const networkId = &quot;testnet&quot;;
</code></pre>
<p><a href="https://docs.near.org/integrator/create-transactions#accounts--network">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Formatting Token Amounts?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>When sending NEAR tokens (Ⓝ) during a transaction, the amount needs to be converted into <a href="https://en.wikipedia.org/wiki/Yocto-">Yocto</a> Ⓝ or (10^-24).</p>
<ul>
<li>To perform this you will use the <a href="https://github.com/near/near-api-js"><code>near-api-js</code></a> method <a href="https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/utils/format.ts#L53-L63"><code>parseNearAmount()</code></a> (located in <code>utils/format</code>)</li>
</ul>
<pre><code class="language-js">const amount = nearAPI.utils.format.parseNearAmount(&quot;1.5&quot;);
</code></pre>
<p><a href="https://docs.near.org/integrator/create-transactions#formatting-token-amounts">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Create a Key Store?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>In order to sign transactions you will need to create a &quot;Key Store&quot; that will hold a <a href="https://docs.near.org/integrator/concepts/basics/accounts/access-keys#full-access-keys">full access key</a> to sign your transactions. There are several ways to accomplish this, but for this example we will use a private key stored in either an <code>.env</code> file in your project or an environment variable exported globally.</p>
<ul>
<li>If you created the account using <a href="https://docs.near.org/integrator/tools/near-cli"><code>near-cli</code></a> or ran <a href="https://docs.near.org/integrator/tools/near-cli#for-accounts"><code>near login</code></a> in your terminal, your private key can be found in a <code>.json</code> file located in <code>/HOME/.near-credentials</code>.</li>
<li>If you created an account using <a href="https://wallet.testnet.near.org/">NEAR Wallet</a>, your key will be found in your browser's <code>Local Storage</code>.
<ul>
<li>In your browser's dev tools... <code>Application</code> &gt;&gt; <code>Storage</code> &gt;&gt; <code>Local Storage</code></li>
</ul>
</li>
</ul>
<pre><code class="language-js">// sets up an empty keyStore object in memory using near-api-js
const keyStore = new keyStores.InMemoryKeyStore();
// creates a keyPair from the private key provided in your .env file
const keyPair = KeyPair.fromString(process.env.SENDER_PRIVATE_KEY);
// adds the key you just created to your keyStore which can hold multiple keys (must be inside an async function)
await keyStore.setKey(networkId, sender, keyPair);
</code></pre>
<p><a href="https://docs.near.org/integrator/create-transactions#create-a-key-store">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Setting up a connection to NEAR?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Now create a connection to NEAR using a configuration object that will contain your <code>networkId</code> setup earlier as well as your <code>keyStore</code>.</p>
<pre><code class="language-js">// configuration used to connect to NEAR
const config = {
  networkId,
  keyStore,
  nodeUrl: `https://rpc.${networkId}.near.org`,
  walletUrl: `https://wallet.${networkId}.near.org`,
  helperUrl: `https://helper.${networkId}.near.org`,
  explorerUrl: `https://explorer.${networkId}.near.org`,
};
// connect to NEAR! :)
const near = await connect(config);
// create a NEAR account object
const senderAccount = await near.account(sender);
</code></pre>
<p>You'll notice the last line uses your NEAR connection to create a <code>senderAccount</code> object that you'll use to perform the transaction.</p>
<p><a href="https://docs.near.org/integrator/create-transactions#setting-up-a-connection-to-near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Create, Sign, &amp; Send Transaction?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Now that everything is setup, creating the transaction is a single line of code.</p>
<pre><code class="language-js">const result = await senderAccount.sendMoney(receiver, amount);
</code></pre>
<p>This simple command constructs, signs, and sends a token transfer transaction on the NEAR blockchain. There is not a need to create a <code>result</code> variable aside from inspecting the response details from your transaction and even create a link to <a href="https://explorer.testnet.near.org/">NEAR Explorer</a> to view a GUI version of the transaction details.</p>
<p><a href="https://docs.near.org/integrator/create-transactions#create-sign--send-transaction">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Transaction Requirements?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>As stated before, all transactions require six parts:</p>
<ol>
<li><a href="https://docs.near.org/integrator/#1-signerid"><code>signerId</code></a></li>
<li><a href="https://docs.near.org/integrator/#2-signerpublickey"><code>signerPublicKey</code></a></li>
<li><a href="https://docs.near.org/integrator/#3-receiverid"><code>receiverId</code></a></li>
<li><a href="https://docs.near.org/integrator/#4-nonceforpublickey"><code>nonceForPublicKey</code></a></li>
<li><a href="https://docs.near.org/integrator/concepts/basics/transactions/overview#action"><code>actions</code></a></li>
<li><a href="https://docs.near.org/integrator/#6-blockhash"><code>blockHash</code></a></li>
</ol>
<p><a href="https://docs.near.org/integrator/create-transactions#transaction-requirements">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is signerId?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>The <code>signerId</code> is the account ID of the transaction originator.</li>
<li>This value is passed as a string (ex. <code>'example.testnet'</code> or <code>'bob.near'</code>)</li>
</ul>
<p><a href="https://docs.near.org/integrator/create-transactions#1-signerid">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is signerPublicKey?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>The <code>signerPublicKey</code> is required to be an object with two key value pairs: <code>keyType</code> and <code>data</code>.</li>
</ul>
<pre><code class="language-js">PublicKey = {
  keyType: 0,
  data: Uint8Array(32)[
    (190,
    150,
    152,
    145,
    232,
    248,
    128,
    151,
    167,
    165,
    128,
    46,
    20,
    231,
    103,
    142,
    39,
    56,
    152,
    46,
    135,
    1,
    161,
    180,
    94,
    212,
    195,
    201,
    73,
    190,
    70,
    242)
  ],
};
</code></pre>
<ul>
<li>This can be constructed by calling <code>getPublicKey()</code> using the <code>keyPair</code> we <a href="https://docs.near.org/integrator/#access-keys">setup earlier</a>.</li>
</ul>
<pre><code class="language-js">const publicKey = keyPair.getPublicKey();
</code></pre>
<p><a href="https://docs.near.org/integrator/create-transactions#2-signerpublickey">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is receiverId`?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>The <code>receiverId</code> is the account ID of the transaction recipient.</li>
<li>This value is passed as a string (ex. <code>'example.testnet'</code> or <code>'bob.near'</code>)</li>
<li>The certain cases, the <code>signerId</code> and the <code>receiverId</code> can be the same account.</li>
</ul>
<p><a href="https://docs.near.org/integrator/create-transactions#3-receiverid">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is nonceForPublicKey?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>A unique number or <code>nonce</code> is required for each transaction signed with an access key.</li>
<li>To ensure a unique number is created for each transaction, the current <code>nonce</code> should be queried and then incremented by 1.</li>
<li>Current nonce can be retrieved using the <code>provider</code> we <a href="https://docs.near.org/integrator/#setting-up-a-connection-to-near">created earlier</a>.</li>
</ul>
<pre><code class="language-js">const accessKey = await provider.query(
  `access_key/${sender}/${publicKey.toString()}`,
  &quot;&quot;
);
</code></pre>
<ul>
<li>now we can create a unique number for our transaction by incrementing the current <code>nonce</code>.</li>
</ul>
<pre><code class="language-js">const nonce = ++accessKey.nonce;
</code></pre>
<p><a href="https://docs.near.org/integrator/create-transactions#4-nonceforpublickey">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are actions?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>There are currently eight supported <code>Action</code> types. <a href="https://docs.near.org/integrator/concepts/basics/transactions/overview#action">[see here]</a></li>
<li>For this example, we are using <code>Transfer</code></li>
<li>This transfer action can be created using the <a href="https://docs.near.org/integrator/#imports">imported <code>nearAPI</code> object</a> and the <a href="https://docs.near.org/integrator/#formatting-token-amounts">formatted Ⓝ amount</a> created earlier.</li>
</ul>
<pre><code class="language-js">const actions = [nearAPI.transactions.transfer(amount)];
</code></pre>
<p><a href="https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L70-L72">[click here]</a> to view source for <code>transfer()</code>.</p>
<p><a href="https://docs.near.org/integrator/create-transactions#5-actions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is blockHash?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>Each transaction requires a current block hash (within 24hrs) to prove that the transaction was created recently.</li>
<li>Hash must be converted to an array of bytes using the <code>base_decode</code> method found in <a href="https://docs.near.org/integrator/#imports"><code>nearAPI</code></a>.</li>
</ul>
<pre><code class="language-js">const recentBlockHash = nearAPI.utils.serialize.base_decode(
  accessKey.block_hash
);
</code></pre>
<p><a href="https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/utils/serialize.ts#L16-L17">[click here]</a> to view source for <code>base_decode()</code>.</p>
<p><a href="https://docs.near.org/integrator/create-transactions#6-blockhash">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Constructing the Transaction?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>With all of our <a href="https://docs.near.org/integrator/#transaction-requirements">required arguments</a>, we can construct the transaction.</p>
<ul>
<li>Using <a href="https://docs.near.org/integrator/#imports"><code>nearAPI</code></a>, we call on <code>createTransaction()</code> to perform this task.</li>
</ul>
<pre><code class="language-js">const transaction = nearAPI.transactions.createTransaction(
  sender,
  publicKey,
  receiver,
  nonce,
  actions,
  recentBlockHash
);
</code></pre>
<p><a href="https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L95-L110">[click here]</a> to view source code for the Transaction class</p>
<p><a href="https://docs.near.org/integrator/create-transactions#constructing-the-transaction">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Send Transaction?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Final step is to encode and send the transaction.</p>
<ul>
<li>First we serialize transaction into <a href="https://borsh.io/">Borsh</a>, and store the result as <code>signedSerializedTx</code>. <em>(required for all transactions)</em></li>
<li>Then we send the transaction via <a href="https://docs.near.org/integrator/api/rpc/introduction">RPC call</a> using the <code>sendJsonRpc()</code> method nested inside <a href="https://docs.near.org/integrator/#setting-up-connection-to-near"><code>near</code></a>.</li>
</ul>
<pre><code class="language-js">// encodes transaction to serialized Borsh (required for all transactions)
const signedSerializedTx = signedTransaction.encode();
// sends transaction to NEAR blockchain via JSON RPC call and records the result
const result = await provider.sendJsonRpc(&quot;broadcast_tx_commit&quot;, [
  Buffer.from(signedSerializedTx).toString(&quot;base64&quot;),
]);
</code></pre>
<p><a href="https://docs.near.org/integrator/create-transactions#send-transaction">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the RuntimeError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition}</h4>
<pre><code class="language-rust">/// Error returned from `Runtime::apply`
pub enum RuntimeError {
    /// An unexpected integer overflow occurred. The likely issue is an invalid state or the transition.
    UnexpectedIntegerOverflow,
    /// An error happened during TX verification and account charging. It's likely the chunk is invalid.
    /// and should be challenged.
    InvalidTxError(InvalidTxError),
    /// Unexpected error which is typically related to the node storage corruption.account
    /// That it's possible the input state is invalid or malicious.
    StorageError(StorageError),
    /// An error happens if `check_balance` fails, which is likely an indication of an invalid state.
    BalanceMismatchError(BalanceMismatchError),
}
</code></pre>
<h4>Error Messages {#error-messages}</h4>
<ul>
<li>see below: <code>InvalidTxError</code>, <code>StorageError</code> and <code>BalanceMismatchError</code></li>
</ul>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#runtimeerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the InvalidTxError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-1}</h4>
<pre><code class="language-rust">/// An error happened during TX execution
pub enum InvalidTxError {
    /// Happens if a wrong AccessKey used or AccessKey has not enough permissions
    InvalidAccessKeyError(InvalidAccessKeyError),
    /// TX signer_id is not in a valid format or not satisfy requirements see `near_core::primitives::utils::is_valid_account_id`
    InvalidSignerId { signer_id: AccountId },
    /// TX signer_id is not found in a storage
    SignerDoesNotExist { signer_id: AccountId },
    /// Transaction nonce must be account[access_key].nonce + 1
    InvalidNonce { tx_nonce: Nonce, ak_nonce: Nonce },
    /// TX receiver_id is not in a valid format or not satisfy requirements see `near_core::primitives::utils::is_valid_account_id`
    InvalidReceiverId { receiver_id: AccountId },
    /// TX signature is not valid
    InvalidSignature,
    /// Account does not have enough balance to cover TX cost
    NotEnoughBalance {
        signer_id: AccountId,
        balance: Balance,
        cost: Balance,
    },
    /// Signer account rent is unpaid
    RentUnpaid {
        /// An account which is required to pay the rent
        signer_id: AccountId,
        /// Required balance to cover the state rent
        amount: Balance,
    },
    /// An integer overflow occurred during transaction cost estimation.
    CostOverflow,
    /// Transaction parent block hash doesn't belong to the current chain
    InvalidChain,
    /// Transaction has expired
    Expired,
    /// An error occurred while validating actions of a Transaction.
    ActionsValidation(ActionsValidationError),
}
</code></pre>
<h4>Error Messages {#error-messages-1}</h4>
<pre><code class="language-rust">InvalidTxError::InvalidSignerId { signer_id }
    &quot;Invalid signer account ID {:?} according to requirements&quot;
InvalidTxError::SignerDoesNotExist { signer_id }
    &quot;Signer {:?} does not exist&quot;
InvalidTxError::InvalidAccessKeyError(access_key_error)
InvalidTxError::InvalidNonce { tx_nonce, ak_nonce }
    &quot;Transaction nonce {} must be larger than nonce of the used access key {}&quot;
InvalidTxError::InvalidReceiverId { receiver_id }
    &quot;Invalid receiver account ID {:?} according to requirements&quot;
InvalidTxError::InvalidSignature
    &quot;Transaction is not signed with the given public key&quot;
InvalidTxError::NotEnoughBalance { signer_id, balance, cost }
    &quot;Sender {:?} does not have enough balance {} for operation costing {}&quot;
InvalidTxError::RentUnpaid { signer_id, amount }
    &quot;Failed to execute, because the account {:?} wouldn't have enough to pay required rent {}&quot; 
InvalidTxError::CostOverflow
    &quot;Transaction gas or balance cost is too high&quot;
InvalidTxError::InvalidChain
    &quot;Transaction parent block hash doesn't belong to the current chain&quot;
InvalidTxError::Expired
    &quot;Transaction has expired&quot;
InvalidTxError::ActionsValidation(error)
    &quot;Transaction actions validation error: {}&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#invalidtxerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the StorageError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-2}</h4>
<pre><code class="language-rust">pub enum StorageError {
    /// Key-value db internal failure
    StorageInternalError,
    /// Storage is PartialStorage and requested a missing trie node
    TrieNodeMissing,
    /// Either invalid state or key-value db is corrupted.
    /// For PartialStorage it cannot be corrupted.
    /// Error message is unreliable and for debugging purposes only. It's also probably ok to
    /// panic in every place that produces this error.
    /// We can check if db is corrupted by verifying everything in the state trie.
    StorageInconsistentState(String),
}
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#storageerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the BalanceMismatchError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-3}</h4>
<pre><code class="language-rust">/// Happens when the input balance doesn't match the output balance in Runtime apply.
pub struct BalanceMismatchError {
    // Input balances
    pub incoming_validator_rewards: Balance,
    pub initial_accounts_balance: Balance,
    pub incoming_receipts_balance: Balance,
    pub processed_delayed_receipts_balance: Balance,
    pub initial_postponed_receipts_balance: Balance,
    // Output balances
    pub final_accounts_balance: Balance,
    pub outgoing_receipts_balance: Balance,
    pub new_delayed_receipts_balance: Balance,
    pub final_postponed_receipts_balance: Balance,
    pub total_rent_paid: Balance,
    pub total_validator_reward: Balance,
    pub total_balance_burnt: Balance,
    pub total_balance_slashed: Balance,
}
</code></pre>
<h4>Error Messages {#error-messages-2}</h4>
<pre><code class="language-rust">&quot;Balance Mismatch Error. The input balance {} doesn't match output balance {}\n\
Inputs:\n\
    \tIncoming validator rewards sum: {}\n\
    \tInitial accounts balance sum: {}\n\
    \tIncoming receipts balance sum: {}\n\
    \tProcessed delayed receipts balance sum: {}\n\
    \tInitial postponed receipts balance sum: {}\n\
Outputs:\n\
    \tFinal accounts balance sum: {}\n\
    \tOutgoing receipts balance sum: {}\n\
    \tNew delayed receipts balance sum: {}\n\
    \tFinal postponed receipts balance sum: {}\n\
    \tTotal rent paid: {}\n\
    \tTotal validators reward: {}\n\
    \tTotal balance burnt: {}\n\
    \tTotal balance slashed: {}&quot;,
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#balancemismatcherror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the InvalidAccessKeyError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-4}</h4>
<pre><code class="language-rust">pub enum InvalidAccessKeyError {
    /// The access key identified by the `public_key` doesn't exist for the account
    AccessKeyNotFound { account_id: AccountId, public_key: PublicKey },
    /// Transaction `receiver_id` doesn't match the access key receiver_id
    ReceiverMismatch { tx_receiver: AccountId, ak_receiver: AccountId },
    /// Transaction method name isn't allowed by the access key
    MethodNameMismatch { method_name: String },
    /// Transaction requires a full permission access key.
    RequiresFullAccess,
    /// Access Key does not have enough allowance to cover transaction cost
    NotEnoughAllowance {
        account_id: AccountId,
        public_key: PublicKey,
        allowance: Balance,
        cost: Balance,
    },
    /// Having a deposit with a function call action is not allowed with a function call access key.
    DepositWithFunctionCall,
}
</code></pre>
<h4>Error Messages {#error-messages-3}</h4>
<pre><code class="language-rust">InvalidAccessKeyError::AccessKeyNotFound { account_id, public_key }
    &quot;Signer {:?} doesn't have access key with the given public_key {}&quot;
InvalidAccessKeyError::ReceiverMismatch { tx_receiver, ak_receiver }
    &quot;Transaction receiver_id {:?} doesn't match the access key receiver_id {:?}&quot;
InvalidAccessKeyError::MethodNameMismatch { method_name }
    &quot;Transaction method name {:?} isn't allowed by the access key&quot;
InvalidAccessKeyError::RequiresFullAccess
    &quot;The transaction contains more then one action, but it was signed \
     with an access key which allows transaction to apply only one specific action. \
     To apply more then one actions TX must be signed with a full access key&quot;
InvalidAccessKeyError::NotEnoughAllowance { account_id, public_key, allowance, cost }
    &quot;Access Key {:?}:{} does not have enough balance {} for transaction costing {}&quot;
InvalidAccessKeyError::DepositWithFunctionCall
    &quot;Having a deposit with a function call action is not allowed with a function call access key.&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#invalidaccesskeyerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the ActionsValidationError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-5}</h4>
<pre><code class="language-rust">/// Describes the error for validating a list of actions.
pub enum ActionsValidationError {
    /// The total prepaid gas (for all given actions) exceeded the limit.
    TotalPrepaidGasExceeded { total_prepaid_gas: Gas, limit: Gas },
    /// The number of actions exceeded the given limit.
    TotalNumberOfActionsExceeded { total_number_of_actions: u64, limit: u64 },
    /// The total number of bytes of the method names exceeded the limit in a Add Key action.
    AddKeyMethodNamesNumberOfBytesExceeded { total_number_of_bytes: u64, limit: u64 },
    /// The length of some method name exceeded the limit in a Add Key action.
    AddKeyMethodNameLengthExceeded { length: u64, limit: u64 },
    /// Integer overflow during a compute.
    IntegerOverflow,
    /// Invalid account ID.
    InvalidAccountId { account_id: AccountId },
    /// The size of the contract code exceeded the limit in a DeployContract action.
    ContractSizeExceeded { size: u64, limit: u64 },
    /// The length of the method name exceeded the limit in a Function Call action.
    FunctionCallMethodNameLengthExceeded { length: u64, limit: u64 },
    /// The length of the arguments exceeded the limit in a Function Call action.
    FunctionCallArgumentsLengthExceeded { length: u64, limit: u64 },
}
</code></pre>
<h4>Error Messages {#error-messages-4}</h4>
<pre><code class="language-rust">ActionsValidationError::TotalPrepaidGasExceeded     { total_prepaid_gas, limit }
     &quot;The total prepaid gas {} exceeds the limit {}&quot;
     
ActionsValidationError::TotalNumberOfActionsExceeded {total_number_of_actions, limit }
     &quot;The total number of actions {} exceeds the limit {}&quot;
     
ActionsValidationError::AddKeyMethodNamesNumberOfBytesExceeded { total_number_of_bytes, limit }
     &quot;The total number of bytes in allowed method names {} exceeds the maximum allowed number {} in a AddKey action&quot;
     
ActionsValidationError::AddKeyMethodNameLengthExceeded { length, limit }
     &quot;The length of some method name {} exceeds the maximum allowed length {} in a AddKey action&quot;
     
ActionsValidationError::IntegerOverflow
     &quot;Integer overflow during a compute&quot;
     
ActionsValidationError::InvalidAccountId { account_id }
     &quot;Invalid account ID `{}`&quot;
     
ActionsValidationError::ContractSizeExceeded { size, limit }
     &quot;The length of the contract size {} exceeds the maximum allowed size {} in a DeployContract action&quot;
     
ActionsValidationError::FunctionCallMethodNameLengthExceeded { length, limit }
     &quot;The length of the method name {} exceeds the maximum allowed length {} in a FunctionCall action&quot;
     
ActionsValidationError::FunctionCallArgumentsLengthExceeded { length, limit }
     &quot;The length of the arguments {} exceeds the maximum allowed length {} in a FunctionCall action&quot;
     
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#actionsvalidationerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the TxExecutionError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-6}</h4>
<pre><code class="language-rust">/// Error returned in the ExecutionOutcome in case of failure
pub enum TxExecutionError {
    /// An error happened during Acton execution
    ActionError(ActionError),
    /// An error happened during Transaction execution
    InvalidTxError(InvalidTxError),
}
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#txexecutionerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the ActionError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-7}</h4>
<pre><code class="language-rust">ActionError
pub struct ActionError {
    /// Index of the failed action in the transaction.
    /// Action index is not defined if ActionError.kind is `ActionErrorKind::RentUnpaid`
    pub index: Option&lt;u64&gt;,
    /// The kind of ActionError happened
    pub kind: ActionErrorKind,
}
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#actionerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the ActionErrorKind?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-8}</h4>
<pre><code class="language-rust">pub enum ActionErrorKind {
    /// Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage
    AccountAlreadyExists { account_id: AccountId },
    /// Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)
    AccountDoesNotExist { account_id: AccountId },
    /// A newly created account must be under a namespace of the creator account
    CreateAccountNotAllowed { account_id: AccountId, predecessor_id: AccountId },
    /// Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver
    /// or the first TX action is a `CreateAccount` action
    ActorNoPermission { account_id: AccountId, actor_id: AccountId },
    /// Account tries to remove an access key that doesn't exist
    DeleteKeyDoesNotExist { account_id: AccountId, public_key: PublicKey },
    /// The public key is already used for an existing access key
    AddKeyAlreadyExists { account_id: AccountId, public_key: PublicKey },
    /// Account is staking and can not be deleted
    DeleteAccountStaking { account_id: AccountId },
    /// Foreign sender (sender=!receiver) can delete an account only if a target account hasn't enough tokens to pay rent
    DeleteAccountHasRent {
        account_id: AccountId,
        balance: Balance,
    },
    /// ActionReceipt can't be completed, because the remaining balance will not be enough to pay rent.
    RentUnpaid {
        /// An account which is required to pay the rent
        account_id: AccountId,
        /// Rent due to pay.
        amount: Balance,
    },
    /// Account is not yet staked, but tries to unstake
    TriesToUnstake { account_id: AccountId },
    /// The account doesn't have enough balance to increase the stake.
    TriesToStake {
        account_id: AccountId,
        stake: Balance,
        locked: Balance,
        balance: Balance,
    },
    /// An error occurred during a `FunctionCall` Action.
    FunctionCallError(FunctionCallError),
    /// Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails
    /// receipt validation.
    NewReceiptValidationError(ReceiptValidationError),
}
</code></pre>
<h4>Error Messages {#error-messages-5}</h4>
<pre><code class="language-rust">ActionErrorKind::AccountAlreadyExists { account_id } 
&quot;Can't create a new account {:?}, because it already exists&quot;
ActionErrorKind::AccountDoesNotExist { account_id } 
&quot;Can't complete the action because account {:?} doesn't exist&quot;
ActionErrorKind::ActorNoPermission { actor_id, account_id } 
&quot;Actor {:?} doesn't have permission to account {:?} to complete the action&quot;
ActionErrorKind::RentUnpaid { account_id, amount } 
&quot;The account {} wouldn't have enough balance to pay required rent {}&quot;
ActionErrorKind::TriesToUnstake { account_id } 
&quot;Account {:?} is not yet staked, but tries to unstake&quot;
ActionErrorKind::TriesToStake { account_id, stake, locked, balance } 
&quot;Account {:?} tries to stake {}, but has staked {} and only has {}&quot;
ActionErrorKind::CreateAccountNotAllowed { account_id, predecessor_id } 
&quot;The new account_id {:?} can't be created by {:?}&quot;
ActionErrorKind::DeleteKeyDoesNotExist { account_id, .. } 
&quot;Account {:?} tries to remove an access key that doesn't exist&quot;
ActionErrorKind::AddKeyAlreadyExists { public_key, .. } 
&quot;The public key {:?} is already used for an existing access key&quot;
ActionErrorKind::DeleteAccountStaking { account_id }
&quot;Account {:?} is staking and can not be deleted&quot;
ActionErrorKind::DeleteAccountHasRent { account_id, balance } 
&quot;Account {:?} can't be deleted. It has {}, which is enough to cover the rent&quot;
ActionErrorKind::FunctionCallError(s) 
ActionErrorKind::NewReceiptValidationError(e) 
&quot;An new action receipt created during a FunctionCall is not valid: {}&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#actionerrorkind">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the ReceiptValidationError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-9}</h4>
<pre><code class="language-rust">/// Describes the error for validating a receipt.
pub enum ReceiptValidationError {
    /// The `predecessor_id` of a Receipt is not valid.
    InvalidPredecessorId { account_id: AccountId },
    /// The `receiver_id` of a Receipt is not valid.
    InvalidReceiverId { account_id: AccountId },
    /// The `signer_id` of an ActionReceipt is not valid.
    InvalidSignerId { account_id: AccountId },
    /// The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.
    InvalidDataReceiverId { account_id: AccountId },
    /// The length of the returned data exceeded the limit in a DataReceipt.
    ReturnedValueLengthExceeded { length: u64, limit: u64 },
    /// The number of input data dependencies exceeds the limit in an ActionReceipt.
    NumberInputDataDependenciesExceeded { number_of_input_data_dependencies: u64, limit: u64 },
    /// An error occurred while validating actions of an ActionReceipt.
    ActionsValidation(ActionsValidationError),
}
</code></pre>
<h4>Error Messages {#error-messages-6}</h4>
<pre><code class="language-rust">ReceiptValidationError::InvalidPredecessorId { account_id } 
&quot;The predecessor_id `{}` of a Receipt is not valid.&quot;
ReceiptValidationError::InvalidReceiverId { account_id } 
&quot;The receiver_id `{}` of a Receipt is not valid.&quot;
ReceiptValidationError::InvalidSignerId { account_id } 
&quot;The signer_id `{}` of an ActionReceipt is not valid.&quot;
ReceiptValidationError::InvalidDataReceiverId { account_id } 
&quot;The receiver_id `{}` of a DataReceiver within an ActionReceipt is not valid.&quot;
ReceiptValidationError::ReturnedValueLengthExceeded { length, limit } 
&quot;The length of the returned data {} exceeded the limit {} in a DataReceipt&quot;
ReceiptValidationError::NumberInputDataDependenciesExceeded { number_of_input_data_dependencies, limit } 
&quot;The number of input data dependencies {} exceeded the limit {} in an ActionReceipt&quot;
ReceiptValidationError::ActionsValidation(e) 
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#receiptvalidationerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the VMError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-10}</h4>
<pre><code class="language-rust">pub enum VMError {
    FunctionCallError(FunctionCallError),
    /// Serialized external error from External trait implementation.
    ExternalError(Vec&lt;u8&gt;),
    /// An error that is caused by an operation on an inconsistent state.
    /// E.g. an integer overflow by using a value from the given context.
    InconsistentStateError(InconsistentStateError),
}
</code></pre>
<h4>Error Messages {#error-messages-7}</h4>
<pre><code class="language-rust">VMError::ExternalError
  &quot;Serialized ExternalError&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#vmerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the FunctionCallError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-11}</h4>
<pre><code class="language-rust">pub enum FunctionCallError {
    CompilationError(CompilationError),
    LinkError { msg: String },
    MethodResolveError(MethodResolveError),
    WasmTrap { msg: String },
    HostError(HostError),
}
</code></pre>
<h4>Error Messages {#error-messages-8}</h4>
<pre><code class="language-rust">FunctionCallError::WasmTrap
  &quot;WebAssembly trap: {}&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#functioncallerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the MethodResolveError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-12}</h4>
<pre><code class="language-rust">pub enum MethodResolveError {
    MethodEmptyName,
    MethodUTF8Error,
    MethodNotFound,
    MethodInvalidSignature,
}
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#methodresolveerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the CompilationError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-13}</h4>
<pre><code class="language-rust">pub enum CompilationError {
    CodeDoesNotExist { account_id: String },
    PrepareError(PrepareError),
    WasmerCompileError { msg: String },
}
</code></pre>
<h4>Error Messages {#error-messages-9}</h4>
<pre><code class="language-rust">CompilationError::CodeDoesNotExist
  &quot;cannot find contract code for account {}&quot;
CompilationError::PrepareError(p)
  &quot;PrepareError: {}&quot;
CompilationError::WasmerCompileError
  &quot;Wasmer compilation error: {}&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#compilationerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the PrepareError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-14}</h4>
<pre><code class="language-rust">/// Error that can occur while preparing or executing Wasm smart-contract.
pub enum PrepareError {
    /// Error happened while serializing the module.
    Serialization,
    /// Error happened while deserializing the module.
    Deserialization,
    /// Internal memory declaration has been found in the module.
    InternalMemoryDeclared,
    /// Gas instrumentation failed.
    ///
    /// This most likely indicates the module isn't valid.
    GasInstrumentation,
    /// Stack instrumentation failed.
    ///
    /// This  most likely indicates the module isn't valid.
    StackHeightInstrumentation,
    /// Error happened during instantiation.
    ///
    /// This might indicate that `start` function trapped, or module isn't
    /// instantiable and/or unlinkable.
    Instantiate,
    /// Error creating memory.
    Memory,
}
</code></pre>
<h4>Error Messages {#error-messages-10}</h4>
<pre><code class="language-rust">Serialization
  &quot;Error happened while serializing the module.&quot;
Deserialization
  &quot;Error happened while deserializing the module.&quot;
InternalMemoryDeclared
  &quot;Internal memory declaration has been found in the module.&quot;
GasInstrumentation
  &quot;Gas instrumentation failed.&quot;
StackHeightInstrumentation
  &quot;Stack instrumentation failed.&quot;
Instantiate
  &quot;Error happened during instantiation.&quot;
Memory
  &quot;Error creating memory&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#prepareerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the HostError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-15}</h4>
<pre><code class="language-rust">pub enum HostError {
    /// String encoding is bad UTF-16 sequence
    BadUTF16,
    /// String encoding is bad UTF-8 sequence
    BadUTF8,
    /// Exceeded the prepaid gas
    GasExceeded,
    /// Exceeded the maximum amount of gas allowed to burn per contract
    GasLimitExceeded,
    /// Exceeded the account balance
    BalanceExceeded,
    /// Tried to call an empty method name
    EmptyMethodName,
    /// Smart contract panicked
    GuestPanic { panic_msg: String },
    /// IntegerOverflow happened during a contract execution
    IntegerOverflow,
    /// `promise_idx` does not correspond to existing promises
    InvalidPromiseIndex { promise_idx: u64 },
    /// Actions can only be appended to non-joint promise.
    CannotAppendActionToJointPromise,
    /// Returning joint promise is currently prohibited
    CannotReturnJointPromise,
    /// Accessed invalid promise result index
    InvalidPromiseResultIndex { result_idx: u64 },
    /// Accessed invalid register id
    InvalidRegisterId { register_id: u64 },
    /// Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie
    IteratorWasInvalidated { iterator_index: u64 },
    /// Accessed memory outside the bounds
    MemoryAccessViolation,
    /// VM Logic returned an invalid receipt index
    InvalidReceiptIndex { receipt_index: u64 },
    /// Iterator index `iterator_index` does not exist
    InvalidIteratorIndex { iterator_index: u64 },
    /// VM Logic returned an invalid account id
    InvalidAccountId,
    /// VM Logic returned an invalid method name
    InvalidMethodName,
    /// VM Logic provided an invalid public key
    InvalidPublicKey,
    /// `method_name` is not allowed in view calls
    ProhibitedInView { method_name: String },
    /// The total number of logs will exceed the limit.
    NumberOfLogsExceeded { limit: u64 },
    /// The storage key length exceeded the limit.
    KeyLengthExceeded { length: u64, limit: u64 },
    /// The storage value length exceeded the limit.
    ValueLengthExceeded { length: u64, limit: u64 },
    /// The total log length exceeded the limit.
    TotalLogLengthExceeded { length: u64, limit: u64 },
    /// The maximum number of promises within a FunctionCall exceeded the limit.
    NumberPromisesExceeded { number_of_promises: u64, limit: u64 },
    /// The maximum number of input data dependencies exceeded the limit.
    NumberInputDataDependenciesExceeded { number_of_input_data_dependencies: u64, limit: u64 },
    /// The returned value length exceeded the limit.
    ReturnedValueLengthExceeded { length: u64, limit: u64 },
    /// The contract size for DeployContract action exceeded the limit.
    ContractSizeExceeded { size: u64, limit: u64 },
}
</code></pre>
<h4>Error Messages {#error-messages-11}</h4>
<pre><code class="language-rust">BadUTF8 
  &quot;String encoding is bad UTF-8 sequence.&quot;
BadUTF16 
  &quot;String encoding is bad UTF-16 sequence.&quot;
GasExceeded 
  &quot;Exceeded the prepaid gas.&quot;
GasLimitExceeded 
  &quot;Exceeded the maximum amount of gas allowed to burn per contract.&quot;
BalanceExceeded 
  &quot;Exceeded the account balance.&quot;
EmptyMethodName 
  &quot;Tried to call an empty method name.&quot;
GuestPanic { panic_msg } 
  &quot;Smart contract panicked: {}&quot;
IntegerOverflow 
  &quot;Integer overflow.&quot;
InvalidIteratorIndex { iterator_index } 
  &quot;Iterator index {:?} does not exist&quot;
InvalidPromiseIndex { promise_idx } 
  &quot;{:?} does not correspond to existing promises&quot;
CannotAppendActionToJointPromise 
  &quot;Actions can only be appended to non-joint promise.&quot;
CannotReturnJointPromise 
  &quot;Returning joint promise is currently prohibited.&quot;
InvalidPromiseResultIndex { result_idx } 
  &quot;Accessed invalid promise result index: {:?}&quot;
InvalidRegisterId { register_id } 
  &quot;Accessed invalid register id: {:?}&quot;
IteratorWasInvalidated { iterator_index } 
  &quot;Iterator {:?} was invalidated after its creation by performing a mutable operation on trie&quot;
MemoryAccessViolation 
  &quot;Accessed memory outside the bounds.&quot;
InvalidReceiptIndex { receipt_index } 
  &quot;VM Logic returned an invalid receipt index: {:?}&quot;
InvalidAccountId 
  &quot;VM Logic returned an invalid account id&quot;
InvalidMethodName 
  &quot;VM Logic returned an invalid method name&quot;
InvalidPublicKey 
  &quot;VM Logic provided an invalid public key&quot;
ProhibitedInView { method_name } 
  &quot;{} is not allowed in view calls&quot;
NumberOfLogsExceeded { limit } 
  &quot;The number of logs will exceed the limit {}&quot;
KeyLengthExceeded { length, limit } 
  &quot;The length of a storage key {} exceeds the limit {}&quot;
ValueLengthExceeded { length, limit } 
  &quot;The length of a storage value {} exceeds the limit {}&quot;
TotalLogLengthExceeded{ length, limit } 
  &quot;The length of a log message {} exceeds the limit {}&quot;
NumberPromisesExceeded { number_of_promises, limit } 
  &quot;The number of promises within a FunctionCall {} exceeds the limit {}&quot;
NumberInputDataDependenciesExceeded { number_of_input_data_dependencies, limit } 
  &quot;The number of input data dependencies {} exceeds the limit {}&quot;
ReturnedValueLengthExceeded { length, limit } 
  &quot;The length of a returned value {} exceeds the limit {}&quot;
ContractSizeExceeded { size, limit } 
  &quot;The size of a contract code in DeployContract action {} exceeds the limit {}&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#hosterror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the VMLogicError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-16}</h4>
<pre><code class="language-rust">pub enum VMLogicError {
    HostError(HostError),
    /// Serialized external error from External trait implementation.
    ExternalError(Vec&lt;u8&gt;),
    /// An error that is caused by an operation on an inconsistent state.
    InconsistentStateError(InconsistentStateError),
}
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#vmlogicerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the InconsistentStateError?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><h4>Definition {#definition-17}</h4>
<pre><code class="language-rust">pub enum InconsistentStateError {
    /// Math operation with a value from the state resulted in a integer overflow.
    IntegerOverflow,
}
</code></pre>
<h4>Error Messages {#error-messages-12}</h4>
<pre><code class="language-rust">InconsistentStateError::IntegerOverflow
    &quot;Math operation with a value from the state resulted in a integer overflow.&quot;
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#inconsistentstateerror">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the RPC interface?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>error name</li>
<li>error subtype(s)</li>
<li>error properties</li>
</ul>
<p><a href="https://docs.near.org/integrator/errors/error-implementation#rpc-interface">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is  The life of a transaction:?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>A client creates a transaction, computes the transaction hash and signs this hash to get a signed transaction. Now this signed transaction can be sent to a node.</li>
<li>The RPC interface receives the transaction and routes it to the correct physical node using <code>signer_id</code>.  Since the <code>signer_id</code> must be a NEAR Account ID which lives on a single shard, the account is mapped to a shard which is followed by at least one validator running at least one machine with an IP address.</li>
<li>When a node receives a new signed transaction, it validates the transaction for signer, receiver, account balance, cost overflow, signature, etc. (<a href="https://nomicon.io/RuntimeSpec/Scenarios/FinancialTransaction.html#transaction-to-receipt">see here</a>) and gossips it to all peers following the same shard. If a transaction has an invalid signature or would be invalid on the latest state, it is rejected quickly and returns an error to the original RPC call.</li>
<li>Valid transactions are added to the transaction pool (every validating node has its own independent copy of a transaction pool). The transaction pool maintains transactions that are not yet discarded and not yet included into the chain.</li>
<li>A pool iterator is used to pick transactions from the pool one at a time, ordered from the smallest nonce to largest, until the pool is drained or some chunk limit is reached (max number of transactions per chunk or max gas burnt per chunk to process transactions).  Please refer to articles on the <a href="https://nomicon.io/ChainSpec/Transactions.html?highlight=pool#pool-iterator">pool iterator</a> and <a href="https://docs.near.org/integrator/errors/concepts/basics/transactions/gas">gas</a> for more details.</li>
<li>To accommodate the distributed nature of a sharded blockchain, all transactions are subsequently returned to a segmented transaction pool having 3 distinct layers: accepted transactions (which will be processed on the next chunk), pending transactions (which exceeded the limits of the current chunk and will be included in a later round of processing) and invalid transactions (which will be rejected at the next available opportunity).</li>
<li>Before producing a chunk, transactions are ordered and validated again. This is done to produce chunks with only valid transactions across a distributed system.</li>
<li>While a transaction is being processed on to a chunk, any errors raised by the application of its actions are also returned via RPC.</li>
</ul>
<p><a href="https://docs.near.org/integrator/errors/introduction#the-life-of-a-transaction">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the NEAR Platform Errors?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Errors raised by the NEAR platform are implemented in the following locations in <code>nearcore</code>:</p>
<ul>
<li><a href="https://github.com/near/nearcore/blob/master/core/primitives/src/errors.rs">nearcore/core/primitives/src/errors.rs</a></li>
<li><a href="https://github.com/near/nearcore/blob/master/runtime/near-vm-errors/src/lib.rs">nearcore/runtime/near-vm-errors/src/lib.rs</a>
This page includes:</li>
<li><strong>RuntimeError and subtypes</strong>: errors raised when a transaction is first received by the destination node and again before it's processed and applied to a chunk</li>
<li><strong>TxExecutionError and subtypes</strong>: errors raised while a transaction and its component action(s) are being validated and applied to a chunk</li>
<li><strong>VMerror and subtypes</strong>: errors raised during the execution of a Wasm contract by the NEAR VM</li>
</ul>
<p><a href="https://docs.near.org/integrator/errors/introduction#near-platform-errors">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the RuntimeError and subtypes?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-text">RuntimeError                                              Error returned from `Runtime::apply  
  StorageError                                            Unexpected error which is typically related to the node storage corruption.account
  BalanceMismatchError                                    An error happens if `check_balance` fails, which is likely an indication of an invalid state
  InvalidTxError                                          An error happened during TX verification and account charging
    InvalidAccessKeyError                                 Describes the error for validating access key
    ActionsValidationError                                Describes the error for validating a list of actions    
      TotalPrepaidGasExceeded                             The total prepaid gas (for all given actions) exceeded the limit.
      TotalNumberOfActionsExceeded                        The number of actions exceeded the given limit.
      AddKeyMethodNamesNumberOfBytesExceeded              The total number of bytes of the method names exceeded the limit in a Add Key action.
      AddKeyMethodNameLengthExceeded                      The length of some method name exceeded the limit in a Add Key action.
      IntegerOverflow                                     Integer overflow during a compute.
      InvalidAccountId                                    Invalid account ID.
      ContractSizeExceeded                                The size of the contract code exceeded the limit in a DeployContract action.
      FunctionCallMethodNameLengthExceeded                The length of the method name exceeded the limit in a Function Call action.
      FunctionCallArgumentsLengthExceeded                 The length of the arguments exceeded the limit in a Function Call action.
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/introduction#runtimeerror-and-subtypes">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the TxExecutionError and subtypes?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-text">TxExecutionError                                          Error returned in the ExecutionOutcome in case of failure
  InvalidTxError                                          An error happened during Transaction execution
    InvalidAccessKeyError                                 Describes the error for validating access key
    ActionsValidationError                                Describes the error for validating a list of actions
      TotalPrepaidGasExceeded                             The total prepaid gas (for all given actions) exceeded the limit.
      TotalNumberOfActionsExceeded                        The number of actions exceeded the given limit.
      AddKeyMethodNamesNumberOfBytesExceeded              The total number of bytes of the method names exceeded the limit in a Add Key action.
      AddKeyMethodNameLengthExceeded                      The length of some method name exceeded the limit in a Add Key action.
      IntegerOverflow                                     Integer overflow during a compute.
      InvalidAccountId                                    Invalid account ID.
      ContractSizeExceeded                                The size of the contract code exceeded the limit in a DeployContract action.
      FunctionCallMethodNameLengthExceeded                The length of the method name exceeded the limit in a Function Call action.
      FunctionCallArgumentsLengthExceeded                 The length of the arguments exceeded the limit in a Function Call action.
  ActionError                                             An error happened during Acton execution
    ActionErrorKind                                       The kind of ActionError happened
      RuntimeCallError 
      ReceiptValidationError                              Describes the error for validating a receipt
        ActionsValidationError                            Describes the error for validating a list of actions    
          TotalPrepaidGasExceeded                         The total prepaid gas (for all given actions) exceeded the limit.
          TotalNumberOfActionsExceeded                    The number of actions exceeded the given limit.
          AddKeyMethodNamesNumberOfBytesExceeded          The total number of bytes of the method names exceeded the limit in a Add Key action.
          AddKeyMethodNameLengthExceeded                  The length of some method name exceeded the limit in a Add Key action.
          IntegerOverflow                                 Integer overflow during a compute.
          InvalidAccountId                                Invalid account ID.
          ContractSizeExceeded                            The size of the contract code exceeded the limit in a DeployContract action.
          FunctionCallMethodNameLengthExceeded            The length of the method name exceeded the limit in a Function Call action.
          FunctionCallArgumentsLengthExceeded             The length of the arguments exceeded the limit in a Function Call action.
</code></pre>
<p><a href="https://docs.near.org/integrator/errors/introduction#txexecutionerror-and-subtypes">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Integration Reference?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li><a href="https://docs.near.org/integrator/integrator/balance-changes">Balance Changes</a></li>
<li><a href="https://docs.near.org/integrator/integrator/accounts">Accounts</a></li>
<li><a href="https://docs.near.org/integrator/integrator/fungible-tokens">Fungible Tokens</a></li>
<li><a href="https://docs.near.org/integrator/integrator/implicit-accounts">Implicit Accounts</a></li>
</ul>
<p><a href="https://docs.near.org/integrator/exchange-integration#integration-reference">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What are the Transaction Reference Links?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li><a href="https://docs.near.org/integrator/concepts/basics/transactions/overview">Basics</a></li>
<li><a href="https://nomicon.io/RuntimeSpec/Transactions">Specifications</a></li>
<li><a href="https://docs.near.org/integrator/integrator/create-transactions">Constructing Transactions</a></li>
</ul>
<p><a href="https://docs.near.org/integrator/exchange-integration#transaction-reference-links">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Blocks and Finality?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Some important pieces of information regarding blocks and finality include:</p>
<ul>
<li>Expected block time is around 1s and expected time to finality is around 2s. The last final block can be queried by
specifying <code>{&quot;finality&quot;: &quot;final&quot;}</code> in the block query. For example, to get the latest final block on mainnet, one can run</li>
</ul>
<pre><code class="language-bash">http post https://rpc.mainnet.near.org method=block params:='{&quot;finality&quot;:&quot;final&quot;}' id=123 jsonrpc=2.0
</code></pre>
<ul>
<li>Block height are not necessarily continuous and certain heights may be skipped if, for example, a block producer for that height is offline. For example, after a block at height 100 is produced, the block at height 101 may be skipped. When block at height 102 is produced, its previous block is the block at height 100.</li>
<li>Some blocks may not include new chunks if, for example, the previous chunk producer is offline. Even though in the RPC
return result every block will have non-empty <code>chunks</code> field, it does not imply that there is a new chunk included in the block.
The way to tell whether the chunk is included in the block is to check whether <code>height_included</code> in the chunk is the same
as the height of the block.</li>
</ul>
<p><a href="https://docs.near.org/integrator/exchange-integration#blocks-and-finality">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Running an Archival Node?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Please refer to configuration changes required in <code>config.json</code> for archival node by referring to the documentation on <a href="https://near-nodes.io/archival/run-archival-node-with-nearup">Run an Archival Node</a>.</p>
<p><a href="https://docs.near.org/integrator/exchange-integration#running-an-archival-node">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is a good project summary for NEAR?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR is a sharded, public, proof-of-stake blockchain and smart contract platform. It is built in Rust and contracts compile to WASM. It is conceptually similar to Ethereum 2.0.</p>
<p><a href="https://docs.near.org/integrator/faq#what-is-a-good-project-summary-for-near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What's special about NEAR?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR is the blockchain for builders.
If you understand the basics of web development, you can write, test and deploy scalable decentralized applications in minutes on the most developer-friendly blockchain without having to learn new tools or languages.</p>
<p><a href="https://docs.near.org/integrator/faq#whats-special-about-near">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Is NEAR open source?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Yes. Have look at our <a href="https://github.com/near">GitHub organization</a>.</p>
<p><a href="https://docs.near.org/integrator/faq#is-near-open-source">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How are cryptographic functions used?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>We support both <code>secp256k1</code> and <code>ed25519</code> for account keys and <code>ed25519</code> for signing transactions. We currently use the <code>ed25519_dalek</code> and <code>sha2</code> libraries for crypto.</p>
<p><a href="https://docs.near.org/integrator/faq#how-are-cryptographic-functions-used">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Do you have any on-chain governance mechanisms?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR does not have any on-chain governance at the moment. Any changes to state or state transition function must be done through a hard fork.</p>
<p><a href="https://docs.near.org/integrator/faq#do-you-have-any-on-chain-governance-mechanisms">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Do you have a bug-bounty program?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Our plan is to have a transparent Bug Bounty program with clear guidelines for paying out to those reporting issues. Payments will likely be based on publicly available rankings provided by protocol developers based on issue severity.</p>
<p><a href="https://docs.near.org/integrator/faq#do-you-have-a-bug-bounty-program">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What contracts should we be aware of right now?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>We have developed a number of <a href="https://github.com/near/initial-contracts">initial contracts</a> with <strong>ones in bold</strong> being most mature at time of writing</p>
<ul>
<li><strong>Staking Pool / Delegation contract</strong></li>
<li><strong>Lockup / Vesting contract</strong></li>
<li>Whitelist Contract</li>
<li>Staking Pool Factory</li>
<li>Multisig contract</li>
</ul>
<p><a href="https://docs.near.org/integrator/faq#what-contracts-should-we-be-aware-of-right-now">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Do you have a cold wallet implementation (ie. Ledger)?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>https://github.com/near/near-ledger-app</p>
<p><a href="https://docs.near.org/integrator/faq#do-you-have-a-cold-wallet-implementation-ie-ledger">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the process for becoming a validator?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Validation is permissionless and determined via auction. Parties who want to become a validator submit a special transaction to the chain one day ahead which indicates how many tokens they want to stake. An auction is run which determines the minimum necessary stake to get a validation seat during the next epoch and, if the amount submitted is greater than the minimum threshold, the submitter will validate at least one shard during the next epoch.</p>
<p><a href="https://docs.near.org/integrator/faq#what-is-the-process-for-becoming-a-validator">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How long does a validator remain a validator?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>A validator will stop being a validator for the following reasons:</p>
<ul>
<li>Not producing enough blocks or chunks.</li>
<li>Not getting elected in the auction for next epoch because their stake is not large enough.</li>
<li>Getting slashed.
Otherwise a validator will remain a validator indefinitely.
Validator election happens in epochs. The <a href="https://near.org/downloads/Nightshade.pdf">Nightshade whitepaper</a> introduces epochs this way: &quot;the maintenance of the network is done in epochs&quot; where an epoch is a period of time on the order of half a day.
At the beginning of each epoch, some computation produces a list of validators for the <em>very next epoch</em>.
The input to this computation includes all accounts that have &quot;raised their hand to be a validator&quot;
by submitting a special transaction (<a href="https://nomicon.io/RuntimeSpec/Actions.html#stakeaction"><code>StakeAction</code></a>)
expressing the commitment of some amount of tokens over the system's staking threshold,
as well as validators from the previous epoch.
The output of this computation is a list of the validators for the very next epoch.</li>
</ul>
<p><a href="https://docs.near.org/integrator/faq#how-long-does-a-validator-remain-a-validator">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the penalty for misbehaving validators?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Validators are not slashed for being offline but they do miss out on the rewards of validating. Validators who miss too many blocks or chunks will be removed from the validation set in the next auction and not get any reward (but, again, without slashing).
Any foul play on the part of the validator that is detected by the system may result is a &quot;slashing event&quot; where the validator is marked as out of integrity and forfeit their stake (according to some formula of progressive severity). The slashed stake is burnt.</p>
<p><a href="https://docs.near.org/integrator/faq#what-is-the-penalty-for-misbehaving-validators">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the mechanism for for delegating stake to validators?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR supports separate validation keys that can be used in smart contracts to delegate stake. Delegation is done via smart contract which allows for a validator to define a custom way to collect stake, manage it and split rewards. This also allows validators to provide leverage or derivatives on stake. Delegated stake will be slashed like any other stake if the node misbehaves.
If a validator misbehaves the funds of the delegators are also slashed. There is no waiting period for delegators to withdraw their stake.</p>
<p><a href="https://docs.near.org/integrator/faq#what-is-the-mechanism-for-for-delegating-stake-to-validators">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Does a validator control funds that have been delegated to them?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Delegation is custodial (you are transferring funds to a different account, the smart contract that implements staking pool). We provide a reference implementation being security reviewed and tested by 100 validators at time of writing.
We allow validators to write and deploy new contracts but it is up to users to decide if they want to delegate. Validators can compete for delegation by choosing different logic and conditions around tax optimization, etc.
Currently no slashing but will be added as we add shards into the system. At some point validators will be able to add an option to shield delegators from slashing (similar to Tezos model).</p>
<p><a href="https://docs.near.org/integrator/faq#does-a-validator-control-funds-that-have-been-delegated-to-them">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How do we get the balance of an account after it has delegated funds?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>One would need to query the staking pool contract to get balance.</p>
<p><a href="https://docs.near.org/integrator/faq#how-do-we-get-the-balance-of-an-account-after-it-has-delegated-funds">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Can a node be configured to archive all blockchain data since genesis?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>v
Yes. Start the node using the following command:</p>
<pre><code class="language-sh">./target/release/near run --archive
</code></pre>
<p><a href="https://docs.near.org/integrator/faq#can-a-node-be-configured-to-archive-all-blockchain-data-since-genesis">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Can a node be configured to expose an RPC (ex: HTTP) interface?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Yes. All nodes expose this interface by default which can be configured by setting the value of <code>listen_addr:port</code> in the node's <code>config.json</code> file.</p>
<p><a href="https://docs.near.org/integrator/faq#can-a-node-be-configured-to-expose-an-rpc-ex-http-interface">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Can a node be gracefully terminated and restarted (using archived data on disk to continue syncing)?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Yes.</p>
<p><a href="https://docs.near.org/integrator/faq#can-a-node-be-gracefully-terminated-and-restarted-using-archived-data-on-disk-to-continue-syncing">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Does a node expose an interface for retrieving health telemetry in a structured format (ex: JSON) over RPC?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Yes. <code>GET /status</code> and <code>GET /health</code> provide this interface.</p>
<ul>
<li><code>/status</code>: block height, syncing status, peer count, etc</li>
<li><code>/health</code>: success/failure if node is up running &amp; progressing</li>
</ul>
<p><a href="https://docs.near.org/integrator/faq#does-a-node-expose-an-interface-for-retrieving-health-telemetry-in-a-structured-format-ex-json-over-rpc">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Can a node can be started using a Dockerfile without human supervision?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Yes.</p>
<pre><code class="language-sh">docker run &lt;port mapping&gt; &lt;mount data folder&gt; &lt;ENV vars&gt; nearprotocol/nearcore:latest
</code></pre>
<p>See <code>nearcore/scripts/nodelib.py</code> for different examples of configuration.</p>
<p><a href="https://docs.near.org/integrator/faq#can-a-node-can-be-started-using-a-dockerfile-without-human-supervision">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the source of truth for current block height exposed via API?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>MainNet
<ul>
<li>https://explorer.mainnet.near.org (also https://explorer.near.org)</li>
<li><a href="https://docs.near.org/integrator/./">https://rpc.mainnet.near.org/status</a></li>
</ul>
</li>
<li>TestNet
<ul>
<li>https://explorer.testnet.near.org</li>
<li><a href="https://docs.near.org/integrator/./">https://rpc.testnet.near.org/status</a></li>
</ul>
</li>
<li>BetaNet
<ul>
<li>https://explorer.betanet.near.org</li>
<li><a href="https://docs.near.org/integrator/./">https://rpc.betanet.near.org/status</a></li>
</ul>
</li>
</ul>
<p><a href="https://docs.near.org/integrator/faq#what-is-the-source-of-truth-for-current-block-height-exposed-via-api">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How old can the referenced block hash be before it's invalid?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>There is a genesis parameter which can be discovered for any network using:</p>
<pre><code class="language-sh">http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_genesis_config
# in the line above, testnet may be replaced with mainnet or betanet
</code></pre>
<p>It's <code>43200</code> seconds or <code>~12</code> hours. You can view the live configuration for <code>epoch_length</code> using the <a href="https://docs.near.org/integrator/api/rpc/setup#protocol-config"><code>protocol_config</code> RPC endpoint</a>.
In the response we find <code>transaction_validity_period&quot;: 86400</code> (and since it takes about 1 second to produce a block, this period is about 24 hrs)</p>
<p><a href="https://docs.near.org/integrator/faq#how-old-can-the-referenced-block-hash-be-before-its-invalid">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How will the network will be bootstrapped?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Distribution at genesis will be spread among the NEAR team, our contributors, project partners (ie. contributor, beta applications, infrastructure developers, etc.) and the NEAR foundation (with many portions of that segregated for post-MainNet distribution activity and unavailable to stake so the foundation isn’t able to control the network).
There will be auctions occurring on the platform after launch which will allocate large amounts of tokens over the next 2 years. Additionally we are planning to run TestNet where any validator who participates will receive rewards in real tokens. We are planning to onboard at least 50 separate entities to be validators at launch.</p>
<p><a href="https://docs.near.org/integrator/faq#how-will-the-network-will-be-bootstrapped">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the network upgrade process?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>We are currently upgrading via restarting with a new genesis block.</p>
<p><a href="https://docs.near.org/integrator/faq#what-is-the-network-upgrade-process">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Which consensus algorithm does NEAR use?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR is a sharded <strong>proof-of-stake</strong> blockchain.
<em>You can read more in our <a href="https://near.org/downloads/Nightshade.pdf">Nightshade whitepaper</a>.</em></p>
<blockquote>
<p><em>A few relevant details have been extracted here for convenience:</em></p>
<p>[Since NEAR is a sharded blockchain, there are challenges that need to be overcome] including state validity and data
availability problems. <em>Nightshade</em> is the solution NEAR Protocol is built upon that addresses these issues.</p>
<p>Nightshade uses the heaviest chain consensus. Specifically when a block producer produces a block (see section 3.3), they can collect signatures from other block producers and validators attesting to the previous block. The weight of a block is then the cumulative stake of all the signers whose signatures are included in the block. The weight of a chain is the sum of the block weights.</p>
<p>On top of the heaviest chain consensus we use a finality gadget that uses the attestations to finalize the blocks. To reduce the complexity of the system, we use a finality gadget that doesn’t influence the fork choice rule in any way, and instead only introduces extra slashing conditions, such that once a block is finalized by the finality gadget, a fork is impossible unless a very large percentage of the total stake is slashed.</p>
</blockquote>
<p><a href="https://docs.near.org/integrator/faq#which-consensus-algorithm-does-near-use">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How does on-chain transaction finality work?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Finality is deterministic, and requires at least 3 blocks as well as (2/3 +1) signatures of the current validator set.
In a normal operation, we expect this to happen right at 3 blocks but it is not guaranteed.
Finality will be exposed via RPC when querying block or transaction.
Our definition of finality is BOTH:</p>
<ul>
<li>Block has quorum pre-commit from the finality gadget. See details of the finality gadget <a href="https://near.org/downloads/PoST.pdf">[here]</a></li>
<li>At least 120 blocks (2-3 minutes) built on top of the block of interest. This is relevant in case of invalid state transition in some shard and provides enough time for state change challenges. In case all shards are tracked and some mechanics to pause across nodes is employed, this is not needed. We recommend exchanges track all shards.</li>
</ul>
<p><a href="https://docs.near.org/integrator/faq#how-does-on-chain-transaction-finality-work">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How are addresses generated?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Please check out the spec here on accounts https://nomicon.io/DataStructures/Account.html.</p>
<p><a href="https://docs.near.org/integrator/faq#how-are-addresses-generated">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the balance record-keeping model on the NEAR platform?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR uses an <code>Account</code>-based model. All users and contracts are associated with at least 1 account. Each account lives on a single shard. Each account can have multiple keys for signing transactions.
<em>You can read <a href="https://nomicon.io/DataStructures/Account.html">more about NEAR accounts here</a></em></p>
<p><a href="https://docs.near.org/integrator/faq#what-is-the-balance-record-keeping-model-on-the-near-platform">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How are user accounts represented on-chain?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Users create accounts with human-readable names (eg <code>alice</code>) which can contain multiple keypairs with individual permissions. Accounts can be atomically and securely transferred between parties as a native transaction on the network. Permissions are programmable with smart contracts as well. For example, a lock up contract is just an account with permission on the key that does not allow to transfer funds greater than those unlocked.</p>
<p><a href="https://docs.near.org/integrator/faq#how-are-user-accounts-represented-on-chain">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Is there a minimum account balance?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>To limit on-chain &quot;dust&quot;, accounts (and contracts) are charged rent for storing data on the chain. This means that if the balance of the account goes below some <code>threshold * rent_on_block</code> then account can be removed by anyone. Also any user can remove their own account and transfer left over balance to another (beneficiary) account.
There will be a restoration mechanism for accounts removed (or slept) in this way implemented in the future.</p>
<p><a href="https://docs.near.org/integrator/faq#is-there-a-minimum-account-balance">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How many keys are used?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>An account can have arbitrarily many keys, as long as it has enough tokens for their storage.</p>
<p><a href="https://docs.near.org/integrator/faq#how-many-keys-are-used">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>Which balance look-ups exists? What is required?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>We have an <a href="https://docs.near.org/integrator/api/rpc/setup#view_account">RPC method for viewing account</a>.
The <a href="https://github.com/near/near-api-js/blob/d7f0cb87ec320b723734045a4ee9d17d94574a19/src/providers/json-rpc-provider.ts#L73">JS implementation is here</a>. Note that in this RPC interface you can specify the finality requirement (whether to query the latest state or finalized state).
For custody purposes, it is recommended not to rely on latest state but only what is finfalized.</p>
<p><a href="https://docs.near.org/integrator/faq#which-balance-look-ups-exists-what-is-required">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the fee structure for on-chain transactions?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>NEAR uses a gas-based model where prices are generally deterministically adjusted based on congestion of the network.
We avoid making changes that are too large through re-sharding by changing number of available shards (and thus throughput).
Accounts don’t have associated resources. Gas amount is predetermined for all transactions except function calls. For function call transactions the user (or more likely the developer) attaches the required amount of gas. If some gas is left over after the function call, it is converted back to NEAR and refunded to the original funding account.</p>
<p><a href="https://docs.near.org/integrator/faq#what-is-the-fee-structure-for-on-chain-transactions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How do we know how much gas to add to a transaction?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><ul>
<li>See reference documentation here: https://nomicon.io/Economics/</li>
<li>See API documentation for <a href="https://docs.near.org/integrator/api/rpc/setup#gas-price">discovering gas price via RPC here</a>.
The issuer of a transaction should attach some amount of gas by taking a guess at budget which will get the transaction processed. The contract knows how much to fund different cross contract calls. Gas price is calculated and fixed per block, but may change from block to block depending on how full / busy the block is. If blocks become more than half full then gas price increases.
We're also considering adding a max gas price limit.</li>
</ul>
<p><a href="https://docs.near.org/integrator/faq#how-do-we-know-how-much-gas-to-add-to-a-transaction">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How do we follow Tx status?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>See related <a href="https://docs.near.org/integrator/api/rpc/setup#transaction-status">RPC interface for fetching transaction status here</a>.</p>
<p><a href="https://docs.near.org/integrator/faq#how-do-we-follow-tx-status">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How are transactions constructed and signed?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Transactions are a collection of related data that is composed and cryptographically signed by the sender using their private key. The related public key is part of the transaction and used for signature verification. Only signed transactions may be sent to the network for processing.
Transactions can be constructed and signed offline. Nodes are not required for signing. We are planning to add optional recent block hash to help prevent various replay attacks.
See <a href="https://docs.near.org/integrator/concepts/basics/transactions/overview">transactions</a> in the concepts section of our documentation.</p>
<p><a href="https://docs.near.org/integrator/faq#how-are-transactions-constructed-and-signed">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How is the hash preimage generated? Which fields does the raw transaction consist of?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>For a transaction, we sign the hash of the transaction. More specifically, what is signed is the <code>sha256</code> of the transaction object serialized in borsh (https://github.com/near/borsh).</p>
<p><a href="https://docs.near.org/integrator/faq#how-is-the-hash-preimage-generated-which-fields-does-the-raw-transaction-consist-of">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How do transactions work on the NEAR platform?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>A <code>Transaction</code> is made up of one of more <code>Action</code>s. An action can (currently) be one of 8 types: <code>CreateAccount</code>,
<code>DeployContract</code>, <code>FunctionCall</code>, <code>Transfer</code>, <code>Stake</code>, <code>AddKey</code>, <code>DeleteKey</code> and <code>DeleteAccount</code>. Transactions are composed by a sender and then signed using the private keys of a valid NEAR account to create a <code>SignedTransaction</code>. This signed transaction is considered ready to send to the network for processing.
Transactions are received via our JSON-RPC endpoint and routed to the shared where the <code>sender</code> account lives. This &quot;home shard&quot; for the sender account is then responsible for processing the transaction and generating related receipts to be applied across the network.
Once received by the network, signed transactions are verified (using the embedded public key of the signer) and transformed into a collection of <code>Receipt</code>s, one per action. Receipts are of two types: <code>Action Receipt</code> is the most common and represents almost all actions on the network while <code>Data Receipt</code> handles the very special case of &quot;a <code>FunctionCallAction</code> which includes a Promise&quot;. These receipts are then propagated and applied across the network according to the &quot;home shard&quot; rule for all affected receiver accounts.
These receipts are then propagated around the network using the receiver account's &quot;home shard&quot; since each account lives on one and only one shard. Once located on the correct shard, receipts are pulled from a nonce-based <a href="https://nomicon.io/ChainSpec/Transactions#pool-iterator">queue</a>.
Receipts may generate other, new receipts which in turn are propagated around the network until all receipts have been applied. If any action within a transaction fails, the entire transaction is rolled back and any unburnt fees are refunded to the proper accounts.
For more detail, see specs on <a href="https://nomicon.io/RuntimeSpec/Transactions"><code>Transactions</code></a>, <a href="https://nomicon.io/RuntimeSpec/Actions.html"><code>Actions</code></a>, <a href="https://nomicon.io/RuntimeSpec/Receipts"><code>Receipts</code></a></p>
<p><a href="https://docs.near.org/integrator/faq#how-do-transactions-work-on-the-near-platform">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>How does NEAR serialize transactions?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>We use a simple binary serialization format that's deterministic: https://borsh.io</p>
<p><a href="https://docs.near.org/integrator/faq#how-does-near-serialize-transactions">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Background?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Implicit accounts work similarly to Bitcoin/Ethereum accounts.</p>
<ul>
<li>They allow you to reserve an account ID before it's created by generating a ED25519 key-pair locally.</li>
<li>This key-pair has a public key that maps to the account ID.</li>
<li>The account ID is a lowercase hex representation of the public key.</li>
<li>An ED25519 Public key contains 32 bytes that maps to 64 characters account ID.</li>
<li>The corresponding secret key allows you to sign transactions on behalf of this account once it's created on chain.</li>
</ul>
<p><a href="https://docs.near.org/integrator/implicit-accounts#background">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Creating an account locally?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>For a purpose of this demo, we'll use the <code>betanet</code> network.</p>
<p><a href="https://docs.near.org/integrator/implicit-accounts#creating-an-account-locally">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Set <code>betanet</code> network?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-bash">export NEAR_ENV=betanet
</code></pre>
<p><a href="https://docs.near.org/integrator/implicit-accounts#set-betanet-network">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Generating a key-pair first?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><pre><code class="language-bash">near generate-key tmp1
</code></pre>
<p>Example Output</p>
<pre><code>Generated key pair with ed25519:BGCCDDHfysuuVnaNVtEhhqeT4k9Muyem3Kpgq2U1m9HX public key
</code></pre>
<p>It generates a key-pair for <code>tmp1</code> account ID. The new public key is <code>ed25519:BGCCDDHfysuuVnaNVtEhhqeT4k9Muyem3Kpgq2U1m9HX</code>.
NEAR's string representation of a public key is <code>&lt;curve&gt;:&lt;data&gt;</code>.</p>
<ul>
<li>Curve is either <code>ed25519</code> or <code>secp256k1</code>. For implicit accounts we only support <code>ed25519</code>.</li>
<li>Data is a base58 encoding of the public key. For <code>ed25519</code> it contains 32 bytes.
This command generated a key-pair locally and stored it locally at:</li>
</ul>
<pre><code>~/.near-credentials/betanet/tmp1.json
</code></pre>
<p><a href="https://docs.near.org/integrator/implicit-accounts#generating-a-key-pair-first">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Viewing the key-pair?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Run this command to print the content of the key-pair file:</p>
<pre><code class="language-bash">cat ~/.near-credentials/betanet/tmp1.json
</code></pre>
<p>Content:</p>
<pre><code class="language-json">{&quot;account_id&quot;:&quot;tmp1&quot;,&quot;public_key&quot;:&quot;ed25519:BGCCDDHfysuuVnaNVtEhhqeT4k9Muyem3Kpgq2U1m9HX&quot;,&quot;private_key&quot;:&quot;ed25519:4qAABW9HfVW4UNQjuQAaAWpB21jqoP58kGqDia18FZDRat6Lg6TLWdAD9FyvAd3PPQLYF4hhx2mZAotJudVjoqfs&quot;}
</code></pre>
<p>As you can see, it's a valid json-file and public key matches the one we generated.
The <code>private_key</code> is a secret/private key of the key pair that can be used to sign transactions with the corresponding public key.</p>
<p><a href="https://docs.near.org/integrator/implicit-accounts#viewing-the-key-pair">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Converting a public key to an account ID.?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Let's convert a public key from NEAR string representation <code>ed25519:BGCCDDHfysuuVnaNVtEhhqeT4k9Muyem3Kpgq2U1m9HX</code>
The easiest way is to use <code>near-cli</code> with interactive console <code>repl</code></p>
<ol>
<li>Start <code>near repl</code>:</li>
</ol>
<pre><code class="language-bash">near repl
</code></pre>
<ol start="2">
<li>Store your base58 public key to a local constant:</li>
</ol>
<pre><code class="language-javascript">const pk58 = 'ed25519:BGCCDDHfysuuVnaNVtEhhqeT4k9Muyem3Kpgq2U1m9HX'
</code></pre>
<ol start="3">
<li>Now let's parse the public key and convert it to the hex in one line:</li>
</ol>
<pre><code class="language-javascript">nearAPI.utils.PublicKey.fromString(pk58).data.hexSlice()
</code></pre>
<p>The output string is the account ID in hex (without <code>'</code>):</p>
<pre><code class="language-javascript">'98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de'
</code></pre>
<p>Now the new account ID is <code>98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de</code>.
4) We can now give this account ID to someone and ask them to transfer tokens.</p>
<p><a href="https://docs.near.org/integrator/implicit-accounts#converting-a-public-key-to-an-account-id">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Moving the temporary key-pair?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Finally, we need to move <code>tmp1.json</code> key-pair to the real account ID, so that <code>near-cli</code> can use it to sign transactions.
Let's first export our account ID to a bash env variable:</p>
<pre><code class="language-bash">export ACCOUNT=&quot;98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de&quot;
</code></pre>
<p>Now we can move the <code>tmp1.json</code> file:</p>
<pre><code class="language-bash">mv ~/.near-credentials/betanet/tmp1.json ~/.near-credentials/betanet/$ACCOUNT.json
</code></pre>
<p><em>NOTE: While <code>.json</code> key-pair file still contains the <code>&quot;account_id&quot;:&quot;tmp1&quot;</code>, it's okay. Because <code>near-cli</code> doesn't care.</em>
Assuming you've received tokens on your new account, you can transfer from it using the following command:</p>
<pre><code class="language-bash">near $ACCOUNT &lt;receiver&gt; &lt;amount&gt;
</code></pre>
<p>You can also replace <code>$ACCOUNT</code> with your actual account ID, e.g.</p>
<pre><code class="language-bash">near send 98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de &lt;receiver&gt; &lt;amount&gt;
</code></pre>
<p><a href="https://docs.near.org/integrator/implicit-accounts#moving-the-temporary-key-pair">Read more...</a></p></p>
        </div>
    </div>
</div><hr />

<div itemscope itemprop="mainEntity" itemtype="https://schema.org/Question" class="item">
        <h2 itemprop="name" class="question"><p>What is the Transferring to the implicit account?</p>
</h2>
        <div itemscope itemprop="acceptedAnswer" itemtype="https://schema.org/Answer" class="answer">
            <div itemprop="text"><p>Let's say someone gives you their account ID <code>0861ea8ddd696525696ccf3148dd706c4fda981c64d8a597490472594400c223</code>. You can just transfer to it by running:</p>
<pre><code class="language-bash">near send &lt;your_account_id&gt; 0861ea8ddd696525696ccf3148dd706c4fda981c64d8a597490472594400c223 &lt;amount&gt;
</code></pre>
<p><a href="https://docs.near.org/integrator/implicit-accounts#transferring-to-the-implicit-account">Read more...</a></p></p>
        </div>
    </div>
</div></body>
</html>